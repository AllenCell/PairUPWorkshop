/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "?34f5":
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4407":
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?e0d3":
/*!*********************!*\
  !*** url (ignored) ***!
  \*********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?82fe":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "../volume-viewer/es/Channel.js":
/*!**************************************!*\
  !*** ../volume-viewer/es/Channel.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Channel)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"../volume-viewer/node_modules/three/build/three.module.js\");\n/* harmony import */ var _Histogram_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Histogram.js */ \"../volume-viewer/es/Histogram.js\");\n/* harmony import */ var _Lut_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Lut.js */ \"../volume-viewer/es/Lut.js\");\n\n\n\n// Data and processing for a single channel\nclass Channel {\n  constructor(name) {\n    this.loaded = false;\n    this.imgData = {\n      data: new Uint8ClampedArray(),\n      width: 0,\n      height: 0\n    };\n    this.rawMin = 0;\n    this.rawMax = 255;\n\n    // on gpu\n    this.dataTexture = new three__WEBPACK_IMPORTED_MODULE_2__.DataTexture(new Uint8Array(), 0, 0);\n    this.lutTexture = new three__WEBPACK_IMPORTED_MODULE_2__.DataTexture(new Uint8Array(_Lut_js__WEBPACK_IMPORTED_MODULE_1__.LUT_ARRAY_LENGTH), 256, 1, three__WEBPACK_IMPORTED_MODULE_2__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_2__.UnsignedByteType);\n    this.lutTexture.minFilter = this.lutTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_2__.LinearFilter;\n    this.lutTexture.generateMipmaps = false;\n    this.volumeData = new Uint8Array();\n    this.name = name;\n    this.histogram = new _Histogram_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](new Uint8Array());\n    this.dims = [0, 0, 0];\n\n    // intensity remapping lookup table\n    this.lut = new _Lut_js__WEBPACK_IMPORTED_MODULE_1__.Lut().createFromMinMax(0, 255);\n\n    // per-intensity color labeling (disabled initially)\n    this.colorPalette = new Uint8Array(_Lut_js__WEBPACK_IMPORTED_MODULE_1__.LUT_ARRAY_LENGTH).fill(0);\n    // store in 0..1 range. 1 means fully colorPalette, 0 means fully lut.\n    this.colorPaletteAlpha = 0.0;\n  }\n\n  // rgbColor is [0..255, 0..255, 0..255]\n  combineLuts(rgbColor, out) {\n    const ret = out ? out : new Uint8Array(_Lut_js__WEBPACK_IMPORTED_MODULE_1__.LUT_ARRAY_LENGTH);\n    if (!rgbColor) {\n      return ret;\n    }\n    const rgb = [rgbColor[0] / 255.0, rgbColor[1] / 255.0, rgbColor[2] / 255.0];\n    // colorPalette*alpha + rgb*lut*(1-alpha)\n    // a tiny bit faster for the edge cases\n    if (this.colorPaletteAlpha === 1.0) {\n      ret.set(this.colorPalette);\n    } else if (this.colorPaletteAlpha === 0.0) {\n      ret.set(this.lut.lut);\n      for (let i = 0; i < _Lut_js__WEBPACK_IMPORTED_MODULE_1__.LUT_ARRAY_LENGTH / 4; ++i) {\n        ret[i * 4 + 0] *= rgb[0];\n        ret[i * 4 + 1] *= rgb[1];\n        ret[i * 4 + 2] *= rgb[2];\n      }\n    } else {\n      for (let i = 0; i < _Lut_js__WEBPACK_IMPORTED_MODULE_1__.LUT_ARRAY_LENGTH / 4; ++i) {\n        ret[i * 4 + 0] = this.colorPalette[i * 4 + 0] * this.colorPaletteAlpha + this.lut.lut[i * 4 + 0] * (1.0 - this.colorPaletteAlpha) * rgb[0];\n        ret[i * 4 + 1] = this.colorPalette[i * 4 + 1] * this.colorPaletteAlpha + this.lut.lut[i * 4 + 1] * (1.0 - this.colorPaletteAlpha) * rgb[1];\n        ret[i * 4 + 2] = this.colorPalette[i * 4 + 2] * this.colorPaletteAlpha + this.lut.lut[i * 4 + 2] * (1.0 - this.colorPaletteAlpha) * rgb[2];\n        ret[i * 4 + 3] = this.colorPalette[i * 4 + 3] * this.colorPaletteAlpha + this.lut.lut[i * 4 + 3] * (1.0 - this.colorPaletteAlpha);\n      }\n    }\n    this.lutTexture.image.data.set(ret);\n    this.lutTexture.needsUpdate = true;\n    return ret;\n  }\n  setRawDataRange(min, max) {\n    // remap the lut which was based on rawMin and rawMax to new min and max\n    // If either of the min/max ranges are both zero, then we have undefined behavior and should\n    // not remap the lut.  This situation can happen at first load, for example,\n    // when one channel has arrived but others haven't.\n    if (!(this.rawMin === 0 && this.rawMax === 0) && !(min === 0 && max === 0)) {\n      this.lut.remapDomains(this.rawMin, this.rawMax, min, max);\n      this.rawMin = min;\n      this.rawMax = max;\n    }\n  }\n  getHistogram() {\n    return this.histogram;\n  }\n  getIntensity(x, y, z) {\n    return this.volumeData[x + y * this.dims[0] + z * (this.dims[0] * this.dims[1])];\n  }\n\n  // how to index into tiled texture atlas\n  getIntensityFromAtlas(x, y, z) {\n    const numXtiles = this.imgData.width / this.dims[0];\n    const tilex = z % numXtiles;\n    const tiley = Math.floor(z / numXtiles);\n    const offset = tilex * this.dims[0] + x + (tiley * this.dims[1] + y) * this.imgData.width;\n    return this.imgData.data[offset];\n  }\n  rebuildDataTexture(data, w, h) {\n    if (this.dataTexture) {\n      this.dataTexture.dispose();\n    }\n    this.dataTexture = new three__WEBPACK_IMPORTED_MODULE_2__.DataTexture(data, w, h);\n    this.dataTexture.format = three__WEBPACK_IMPORTED_MODULE_2__.RedFormat;\n    this.dataTexture.type = three__WEBPACK_IMPORTED_MODULE_2__.UnsignedByteType;\n    this.dataTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_2__.NearestFilter;\n    this.dataTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_2__.NearestFilter;\n    this.dataTexture.generateMipmaps = false;\n    this.dataTexture.needsUpdate = true;\n  }\n\n  // give the channel fresh data and initialize from that data\n  // data is formatted as a texture atlas where each tile is a z slice of the volume\n  setBits(bitsArray, w, h) {\n    this.imgData = {\n      data: new Uint8ClampedArray(bitsArray.buffer),\n      width: w,\n      height: h\n    };\n    this.rebuildDataTexture(this.imgData.data, w, h);\n    this.loaded = true;\n    this.histogram = new _Histogram_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bitsArray);\n    const [hmin, hmax] = this.histogram.findAutoIJBins();\n    const lut = new _Lut_js__WEBPACK_IMPORTED_MODULE_1__.Lut().createFromMinMax(hmin, hmax);\n    this.setLut(lut);\n  }\n\n  // let's rearrange this.imgData.data into a 3d array.\n  // it is assumed to be coming in as a flat Uint8Array of size x*y*z\n  // with x*y*z layout (first row of first plane is the first data in the layout,\n  // then second row of first plane, etc)\n  unpackVolumeFromAtlas(x, y, z) {\n    const volimgdata = this.imgData.data;\n    this.dims = [x, y, z];\n    this.volumeData = new Uint8Array(x * y * z);\n    const numXtiles = this.imgData.width / x;\n    const atlasrow = this.imgData.width;\n    let tilex = 0,\n      tiley = 0,\n      tileoffset = 0,\n      tilerowoffset = 0,\n      destOffset = 0;\n    for (let i = 0; i < z; ++i) {\n      // tile offset\n      tilex = i % numXtiles;\n      tiley = Math.floor(i / numXtiles);\n      tileoffset = tilex * x + tiley * y * atlasrow;\n      for (let j = 0; j < y; ++j) {\n        tilerowoffset = j * atlasrow;\n        destOffset = i * (x * y) + j * x;\n        this.volumeData.set(volimgdata.subarray(tileoffset + tilerowoffset, tileoffset + tilerowoffset + x), destOffset);\n      }\n    }\n  }\n\n  // give the channel fresh volume data and initialize from that data\n  setFromVolumeData(bitsArray, vx, vy, vz, ax, ay, rawMin = 0, rawMax = 255) {\n    this.dims = [vx, vy, vz];\n    this.volumeData = bitsArray;\n    // TODO FIXME performance hit for shuffling the data and storing 2 versions of it (could do this in worker at least?)\n    this.packToAtlas(vx, vy, vz, ax, ay);\n    this.loaded = true;\n    // update from current histogram?\n    this.setRawDataRange(rawMin, rawMax);\n    this.histogram = new _Histogram_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.volumeData);\n  }\n\n  // given this.volumeData, let's unpack it into a flat textureatlas and fill up this.imgData.\n  packToAtlas(vx, vy, vz, ax, ay) {\n    // big assumptions:\n    // atlassize is a perfect multiple of volumesize in both x and y\n    // ax % vx == 0\n    // ay % vy == 0\n    // and num slices <= num possible slices in atlas.\n    // (ax/vx) * (ay/vy) >= vz\n    if (ax % vx !== 0 || ay % vy !== 0 || ax / vx * (ay / vy) < vz) {\n      console.log(\"ERROR - atlas and volume dims are inconsistent\");\n      console.log(ax, ay, vx, vy, vz);\n    }\n    this.imgData = {\n      width: ax,\n      height: ay,\n      data: new Uint8ClampedArray(ax * ay)\n    };\n    this.imgData.data.fill(0);\n\n    // deposit slices one by one into the imgData.data from volData.\n    const volimgdata = this.imgData.data;\n    const x = vx,\n      y = vy,\n      z = vz;\n    const numXtiles = this.imgData.width / x;\n    const atlasrow = this.imgData.width;\n    let tilex = 0,\n      tiley = 0,\n      tileoffset = 0,\n      tilerowoffset = 0,\n      sourceOffset = 0;\n    for (let i = 0; i < z; ++i) {\n      // tile offset\n      tilex = i % numXtiles;\n      tiley = Math.floor(i / numXtiles);\n      tileoffset = tilex * x + tiley * y * atlasrow;\n      for (let j = 0; j < y; ++j) {\n        tilerowoffset = j * atlasrow;\n        sourceOffset = i * (x * y) + j * x;\n        volimgdata.set(this.volumeData.subarray(sourceOffset, sourceOffset + x), tileoffset + tilerowoffset);\n      }\n    }\n    this.rebuildDataTexture(this.imgData.data, ax, ay);\n  }\n  setLut(lut) {\n    this.lut = lut;\n  }\n\n  // palette should be an uint8array of 256*4 elements (256 rgba8 values)\n  setColorPalette(palette) {\n    this.colorPalette = palette;\n  }\n  setColorPaletteAlpha(alpha) {\n    this.colorPaletteAlpha = alpha;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxHQUFHYSxTQUFTO01BQ3JCRSxLQUFLLEdBQUdDLElBQUksQ0FBQ0MsS0FBSyxDQUFDakIsQ0FBQyxHQUFHYSxTQUFTLENBQUM7TUFDakNzQixVQUFVLEdBQUdyQixLQUFLLEdBQUdMLENBQUMsR0FBR00sS0FBSyxHQUFHTCxDQUFDLEdBQUd3QixRQUFRO01BQzdDLEtBQUssSUFBSUksQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHNUIsQ0FBQyxFQUFFLEVBQUU0QixDQUFDLEVBQUU7UUFDMUJGLGFBQWEsR0FBR0UsQ0FBQyxHQUFHSixRQUFRO1FBQzVCZSxZQUFZLEdBQUdqRCxDQUFDLElBQUlTLENBQUMsR0FBR0MsQ0FBQyxDQUFDLEdBQUc0QixDQUFDLEdBQUc3QixDQUFDO1FBQ2xDd0IsVUFBVSxDQUFDbEMsR0FBRyxDQUFDLElBQUksQ0FBQ2IsVUFBVSxDQUFDcUQsUUFBUSxDQUFDVSxZQUFZLEVBQUVBLFlBQVksR0FBR3hDLENBQUMsQ0FBQyxFQUFFMEIsVUFBVSxHQUFHQyxhQUFhLENBQUM7TUFDdEc7SUFDRjtJQUNBLElBQUksQ0FBQ2pCLGtCQUFrQixDQUFDLElBQUksQ0FBQzlDLE9BQU8sQ0FBQ0MsSUFBSSxFQUFFc0UsRUFBRSxFQUFFQyxFQUFFLENBQUM7RUFDcEQ7RUFDQWQsTUFBTUEsQ0FBQzFDLEdBQUcsRUFBRTtJQUNWLElBQUksQ0FBQ0EsR0FBRyxHQUFHQSxHQUFHO0VBQ2hCOztFQUVBO0VBQ0E2RCxlQUFlQSxDQUFDQyxPQUFPLEVBQUU7SUFDdkIsSUFBSSxDQUFDNUQsWUFBWSxHQUFHNEQsT0FBTztFQUM3QjtFQUNBQyxvQkFBb0JBLENBQUNDLEtBQUssRUFBRTtJQUMxQixJQUFJLENBQUM1RCxpQkFBaUIsR0FBRzRELEtBQUs7RUFDaEM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi4vdm9sdW1lLXZpZXdlci9lcy9DaGFubmVsLmpzPzE3YTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGF0YVRleHR1cmUsIFJlZEZvcm1hdCwgVW5zaWduZWRCeXRlVHlwZSwgUkdCQUZvcm1hdCwgTGluZWFyRmlsdGVyLCBOZWFyZXN0RmlsdGVyIH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgSGlzdG9ncmFtIGZyb20gXCIuL0hpc3RvZ3JhbS5qc1wiO1xuaW1wb3J0IHsgTHV0LCBMVVRfQVJSQVlfTEVOR1RIIH0gZnJvbSBcIi4vTHV0LmpzXCI7XG4vLyBEYXRhIGFuZCBwcm9jZXNzaW5nIGZvciBhIHNpbmdsZSBjaGFubmVsXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFubmVsIHtcbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgdGhpcy5pbWdEYXRhID0ge1xuICAgICAgZGF0YTogbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KCksXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdGhpcy5yYXdNaW4gPSAwO1xuICAgIHRoaXMucmF3TWF4ID0gMjU1O1xuXG4gICAgLy8gb24gZ3B1XG4gICAgdGhpcy5kYXRhVGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZShuZXcgVWludDhBcnJheSgpLCAwLCAwKTtcbiAgICB0aGlzLmx1dFRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUobmV3IFVpbnQ4QXJyYXkoTFVUX0FSUkFZX0xFTkdUSCksIDI1NiwgMSwgUkdCQUZvcm1hdCwgVW5zaWduZWRCeXRlVHlwZSk7XG4gICAgdGhpcy5sdXRUZXh0dXJlLm1pbkZpbHRlciA9IHRoaXMubHV0VGV4dHVyZS5tYWdGaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG4gICAgdGhpcy5sdXRUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgIHRoaXMudm9sdW1lRGF0YSA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmhpc3RvZ3JhbSA9IG5ldyBIaXN0b2dyYW0obmV3IFVpbnQ4QXJyYXkoKSk7XG4gICAgdGhpcy5kaW1zID0gWzAsIDAsIDBdO1xuXG4gICAgLy8gaW50ZW5zaXR5IHJlbWFwcGluZyBsb29rdXAgdGFibGVcbiAgICB0aGlzLmx1dCA9IG5ldyBMdXQoKS5jcmVhdGVGcm9tTWluTWF4KDAsIDI1NSk7XG5cbiAgICAvLyBwZXItaW50ZW5zaXR5IGNvbG9yIGxhYmVsaW5nIChkaXNhYmxlZCBpbml0aWFsbHkpXG4gICAgdGhpcy5jb2xvclBhbGV0dGUgPSBuZXcgVWludDhBcnJheShMVVRfQVJSQVlfTEVOR1RIKS5maWxsKDApO1xuICAgIC8vIHN0b3JlIGluIDAuLjEgcmFuZ2UuIDEgbWVhbnMgZnVsbHkgY29sb3JQYWxldHRlLCAwIG1lYW5zIGZ1bGx5IGx1dC5cbiAgICB0aGlzLmNvbG9yUGFsZXR0ZUFscGhhID0gMC4wO1xuICB9XG5cbiAgLy8gcmdiQ29sb3IgaXMgWzAuLjI1NSwgMC4uMjU1LCAwLi4yNTVdXG4gIGNvbWJpbmVMdXRzKHJnYkNvbG9yLCBvdXQpIHtcbiAgICBjb25zdCByZXQgPSBvdXQgPyBvdXQgOiBuZXcgVWludDhBcnJheShMVVRfQVJSQVlfTEVOR1RIKTtcbiAgICBpZiAoIXJnYkNvbG9yKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBjb25zdCByZ2IgPSBbcmdiQ29sb3JbMF0gLyAyNTUuMCwgcmdiQ29sb3JbMV0gLyAyNTUuMCwgcmdiQ29sb3JbMl0gLyAyNTUuMF07XG4gICAgLy8gY29sb3JQYWxldHRlKmFscGhhICsgcmdiKmx1dCooMS1hbHBoYSlcbiAgICAvLyBhIHRpbnkgYml0IGZhc3RlciBmb3IgdGhlIGVkZ2UgY2FzZXNcbiAgICBpZiAodGhpcy5jb2xvclBhbGV0dGVBbHBoYSA9PT0gMS4wKSB7XG4gICAgICByZXQuc2V0KHRoaXMuY29sb3JQYWxldHRlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY29sb3JQYWxldHRlQWxwaGEgPT09IDAuMCkge1xuICAgICAgcmV0LnNldCh0aGlzLmx1dC5sdXQpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBMVVRfQVJSQVlfTEVOR1RIIC8gNDsgKytpKSB7XG4gICAgICAgIHJldFtpICogNCArIDBdICo9IHJnYlswXTtcbiAgICAgICAgcmV0W2kgKiA0ICsgMV0gKj0gcmdiWzFdO1xuICAgICAgICByZXRbaSAqIDQgKyAyXSAqPSByZ2JbMl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTFVUX0FSUkFZX0xFTkdUSCAvIDQ7ICsraSkge1xuICAgICAgICByZXRbaSAqIDQgKyAwXSA9IHRoaXMuY29sb3JQYWxldHRlW2kgKiA0ICsgMF0gKiB0aGlzLmNvbG9yUGFsZXR0ZUFscGhhICsgdGhpcy5sdXQubHV0W2kgKiA0ICsgMF0gKiAoMS4wIC0gdGhpcy5jb2xvclBhbGV0dGVBbHBoYSkgKiByZ2JbMF07XG4gICAgICAgIHJldFtpICogNCArIDFdID0gdGhpcy5jb2xvclBhbGV0dGVbaSAqIDQgKyAxXSAqIHRoaXMuY29sb3JQYWxldHRlQWxwaGEgKyB0aGlzLmx1dC5sdXRbaSAqIDQgKyAxXSAqICgxLjAgLSB0aGlzLmNvbG9yUGFsZXR0ZUFscGhhKSAqIHJnYlsxXTtcbiAgICAgICAgcmV0W2kgKiA0ICsgMl0gPSB0aGlzLmNvbG9yUGFsZXR0ZVtpICogNCArIDJdICogdGhpcy5jb2xvclBhbGV0dGVBbHBoYSArIHRoaXMubHV0Lmx1dFtpICogNCArIDJdICogKDEuMCAtIHRoaXMuY29sb3JQYWxldHRlQWxwaGEpICogcmdiWzJdO1xuICAgICAgICByZXRbaSAqIDQgKyAzXSA9IHRoaXMuY29sb3JQYWxldHRlW2kgKiA0ICsgM10gKiB0aGlzLmNvbG9yUGFsZXR0ZUFscGhhICsgdGhpcy5sdXQubHV0W2kgKiA0ICsgM10gKiAoMS4wIC0gdGhpcy5jb2xvclBhbGV0dGVBbHBoYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubHV0VGV4dHVyZS5pbWFnZS5kYXRhLnNldChyZXQpO1xuICAgIHRoaXMubHV0VGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBzZXRSYXdEYXRhUmFuZ2UobWluLCBtYXgpIHtcbiAgICAvLyByZW1hcCB0aGUgbHV0IHdoaWNoIHdhcyBiYXNlZCBvbiByYXdNaW4gYW5kIHJhd01heCB0byBuZXcgbWluIGFuZCBtYXhcbiAgICAvLyBJZiBlaXRoZXIgb2YgdGhlIG1pbi9tYXggcmFuZ2VzIGFyZSBib3RoIHplcm8sIHRoZW4gd2UgaGF2ZSB1bmRlZmluZWQgYmVoYXZpb3IgYW5kIHNob3VsZFxuICAgIC8vIG5vdCByZW1hcCB0aGUgbHV0LiAgVGhpcyBzaXR1YXRpb24gY2FuIGhhcHBlbiBhdCBmaXJzdCBsb2FkLCBmb3IgZXhhbXBsZSxcbiAgICAvLyB3aGVuIG9uZSBjaGFubmVsIGhhcyBhcnJpdmVkIGJ1dCBvdGhlcnMgaGF2ZW4ndC5cbiAgICBpZiAoISh0aGlzLnJhd01pbiA9PT0gMCAmJiB0aGlzLnJhd01heCA9PT0gMCkgJiYgIShtaW4gPT09IDAgJiYgbWF4ID09PSAwKSkge1xuICAgICAgdGhpcy5sdXQucmVtYXBEb21haW5zKHRoaXMucmF3TWluLCB0aGlzLnJhd01heCwgbWluLCBtYXgpO1xuICAgICAgdGhpcy5yYXdNaW4gPSBtaW47XG4gICAgICB0aGlzLnJhd01heCA9IG1heDtcbiAgICB9XG4gIH1cbiAgZ2V0SGlzdG9ncmFtKCkge1xuICAgIHJldHVybiB0aGlzLmhpc3RvZ3JhbTtcbiAgfVxuICBnZXRJbnRlbnNpdHkoeCwgeSwgeikge1xuICAgIHJldHVybiB0aGlzLnZvbHVtZURhdGFbeCArIHkgKiB0aGlzLmRpbXNbMF0gKyB6ICogKHRoaXMuZGltc1swXSAqIHRoaXMuZGltc1sxXSldO1xuICB9XG5cbiAgLy8gaG93IHRvIGluZGV4IGludG8gdGlsZWQgdGV4dHVyZSBhdGxhc1xuICBnZXRJbnRlbnNpdHlGcm9tQXRsYXMoeCwgeSwgeikge1xuICAgIGNvbnN0IG51bVh0aWxlcyA9IHRoaXMuaW1nRGF0YS53aWR0aCAvIHRoaXMuZGltc1swXTtcbiAgICBjb25zdCB0aWxleCA9IHogJSBudW1YdGlsZXM7XG4gICAgY29uc3QgdGlsZXkgPSBNYXRoLmZsb29yKHogLyBudW1YdGlsZXMpO1xuICAgIGNvbnN0IG9mZnNldCA9IHRpbGV4ICogdGhpcy5kaW1zWzBdICsgeCArICh0aWxleSAqIHRoaXMuZGltc1sxXSArIHkpICogdGhpcy5pbWdEYXRhLndpZHRoO1xuICAgIHJldHVybiB0aGlzLmltZ0RhdGEuZGF0YVtvZmZzZXRdO1xuICB9XG4gIHJlYnVpbGREYXRhVGV4dHVyZShkYXRhLCB3LCBoKSB7XG4gICAgaWYgKHRoaXMuZGF0YVRleHR1cmUpIHtcbiAgICAgIHRoaXMuZGF0YVRleHR1cmUuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLmRhdGFUZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKGRhdGEsIHcsIGgpO1xuICAgIHRoaXMuZGF0YVRleHR1cmUuZm9ybWF0ID0gUmVkRm9ybWF0O1xuICAgIHRoaXMuZGF0YVRleHR1cmUudHlwZSA9IFVuc2lnbmVkQnl0ZVR5cGU7XG4gICAgdGhpcy5kYXRhVGV4dHVyZS5tYWdGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuICAgIHRoaXMuZGF0YVRleHR1cmUubWluRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcbiAgICB0aGlzLmRhdGFUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgIHRoaXMuZGF0YVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgLy8gZ2l2ZSB0aGUgY2hhbm5lbCBmcmVzaCBkYXRhIGFuZCBpbml0aWFsaXplIGZyb20gdGhhdCBkYXRhXG4gIC8vIGRhdGEgaXMgZm9ybWF0dGVkIGFzIGEgdGV4dHVyZSBhdGxhcyB3aGVyZSBlYWNoIHRpbGUgaXMgYSB6IHNsaWNlIG9mIHRoZSB2b2x1bWVcbiAgc2V0Qml0cyhiaXRzQXJyYXksIHcsIGgpIHtcbiAgICB0aGlzLmltZ0RhdGEgPSB7XG4gICAgICBkYXRhOiBuZXcgVWludDhDbGFtcGVkQXJyYXkoYml0c0FycmF5LmJ1ZmZlciksXG4gICAgICB3aWR0aDogdyxcbiAgICAgIGhlaWdodDogaFxuICAgIH07XG4gICAgdGhpcy5yZWJ1aWxkRGF0YVRleHR1cmUodGhpcy5pbWdEYXRhLmRhdGEsIHcsIGgpO1xuICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICB0aGlzLmhpc3RvZ3JhbSA9IG5ldyBIaXN0b2dyYW0oYml0c0FycmF5KTtcbiAgICBjb25zdCBbaG1pbiwgaG1heF0gPSB0aGlzLmhpc3RvZ3JhbS5maW5kQXV0b0lKQmlucygpO1xuICAgIGNvbnN0IGx1dCA9IG5ldyBMdXQoKS5jcmVhdGVGcm9tTWluTWF4KGhtaW4sIGhtYXgpO1xuICAgIHRoaXMuc2V0THV0KGx1dCk7XG4gIH1cblxuICAvLyBsZXQncyByZWFycmFuZ2UgdGhpcy5pbWdEYXRhLmRhdGEgaW50byBhIDNkIGFycmF5LlxuICAvLyBpdCBpcyBhc3N1bWVkIHRvIGJlIGNvbWluZyBpbiBhcyBhIGZsYXQgVWludDhBcnJheSBvZiBzaXplIHgqeSp6XG4gIC8vIHdpdGggeCp5KnogbGF5b3V0IChmaXJzdCByb3cgb2YgZmlyc3QgcGxhbmUgaXMgdGhlIGZpcnN0IGRhdGEgaW4gdGhlIGxheW91dCxcbiAgLy8gdGhlbiBzZWNvbmQgcm93IG9mIGZpcnN0IHBsYW5lLCBldGMpXG4gIHVucGFja1ZvbHVtZUZyb21BdGxhcyh4LCB5LCB6KSB7XG4gICAgY29uc3Qgdm9saW1nZGF0YSA9IHRoaXMuaW1nRGF0YS5kYXRhO1xuICAgIHRoaXMuZGltcyA9IFt4LCB5LCB6XTtcbiAgICB0aGlzLnZvbHVtZURhdGEgPSBuZXcgVWludDhBcnJheSh4ICogeSAqIHopO1xuICAgIGNvbnN0IG51bVh0aWxlcyA9IHRoaXMuaW1nRGF0YS53aWR0aCAvIHg7XG4gICAgY29uc3QgYXRsYXNyb3cgPSB0aGlzLmltZ0RhdGEud2lkdGg7XG4gICAgbGV0IHRpbGV4ID0gMCxcbiAgICAgIHRpbGV5ID0gMCxcbiAgICAgIHRpbGVvZmZzZXQgPSAwLFxuICAgICAgdGlsZXJvd29mZnNldCA9IDAsXG4gICAgICBkZXN0T2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHo7ICsraSkge1xuICAgICAgLy8gdGlsZSBvZmZzZXRcbiAgICAgIHRpbGV4ID0gaSAlIG51bVh0aWxlcztcbiAgICAgIHRpbGV5ID0gTWF0aC5mbG9vcihpIC8gbnVtWHRpbGVzKTtcbiAgICAgIHRpbGVvZmZzZXQgPSB0aWxleCAqIHggKyB0aWxleSAqIHkgKiBhdGxhc3JvdztcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgeTsgKytqKSB7XG4gICAgICAgIHRpbGVyb3dvZmZzZXQgPSBqICogYXRsYXNyb3c7XG4gICAgICAgIGRlc3RPZmZzZXQgPSBpICogKHggKiB5KSArIGogKiB4O1xuICAgICAgICB0aGlzLnZvbHVtZURhdGEuc2V0KHZvbGltZ2RhdGEuc3ViYXJyYXkodGlsZW9mZnNldCArIHRpbGVyb3dvZmZzZXQsIHRpbGVvZmZzZXQgKyB0aWxlcm93b2Zmc2V0ICsgeCksIGRlc3RPZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGdpdmUgdGhlIGNoYW5uZWwgZnJlc2ggdm9sdW1lIGRhdGEgYW5kIGluaXRpYWxpemUgZnJvbSB0aGF0IGRhdGFcbiAgc2V0RnJvbVZvbHVtZURhdGEoYml0c0FycmF5LCB2eCwgdnksIHZ6LCBheCwgYXksIHJhd01pbiA9IDAsIHJhd01heCA9IDI1NSkge1xuICAgIHRoaXMuZGltcyA9IFt2eCwgdnksIHZ6XTtcbiAgICB0aGlzLnZvbHVtZURhdGEgPSBiaXRzQXJyYXk7XG4gICAgLy8gVE9ETyBGSVhNRSBwZXJmb3JtYW5jZSBoaXQgZm9yIHNodWZmbGluZyB0aGUgZGF0YSBhbmQgc3RvcmluZyAyIHZlcnNpb25zIG9mIGl0IChjb3VsZCBkbyB0aGlzIGluIHdvcmtlciBhdCBsZWFzdD8pXG4gICAgdGhpcy5wYWNrVG9BdGxhcyh2eCwgdnksIHZ6LCBheCwgYXkpO1xuICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICAvLyB1cGRhdGUgZnJvbSBjdXJyZW50IGhpc3RvZ3JhbT9cbiAgICB0aGlzLnNldFJhd0RhdGFSYW5nZShyYXdNaW4sIHJhd01heCk7XG4gICAgdGhpcy5oaXN0b2dyYW0gPSBuZXcgSGlzdG9ncmFtKHRoaXMudm9sdW1lRGF0YSk7XG4gIH1cblxuICAvLyBnaXZlbiB0aGlzLnZvbHVtZURhdGEsIGxldCdzIHVucGFjayBpdCBpbnRvIGEgZmxhdCB0ZXh0dXJlYXRsYXMgYW5kIGZpbGwgdXAgdGhpcy5pbWdEYXRhLlxuICBwYWNrVG9BdGxhcyh2eCwgdnksIHZ6LCBheCwgYXkpIHtcbiAgICAvLyBiaWcgYXNzdW1wdGlvbnM6XG4gICAgLy8gYXRsYXNzaXplIGlzIGEgcGVyZmVjdCBtdWx0aXBsZSBvZiB2b2x1bWVzaXplIGluIGJvdGggeCBhbmQgeVxuICAgIC8vIGF4ICUgdnggPT0gMFxuICAgIC8vIGF5ICUgdnkgPT0gMFxuICAgIC8vIGFuZCBudW0gc2xpY2VzIDw9IG51bSBwb3NzaWJsZSBzbGljZXMgaW4gYXRsYXMuXG4gICAgLy8gKGF4L3Z4KSAqIChheS92eSkgPj0gdnpcbiAgICBpZiAoYXggJSB2eCAhPT0gMCB8fCBheSAlIHZ5ICE9PSAwIHx8IGF4IC8gdnggKiAoYXkgLyB2eSkgPCB2eikge1xuICAgICAgY29uc29sZS5sb2coXCJFUlJPUiAtIGF0bGFzIGFuZCB2b2x1bWUgZGltcyBhcmUgaW5jb25zaXN0ZW50XCIpO1xuICAgICAgY29uc29sZS5sb2coYXgsIGF5LCB2eCwgdnksIHZ6KTtcbiAgICB9XG4gICAgdGhpcy5pbWdEYXRhID0ge1xuICAgICAgd2lkdGg6IGF4LFxuICAgICAgaGVpZ2h0OiBheSxcbiAgICAgIGRhdGE6IG5ldyBVaW50OENsYW1wZWRBcnJheShheCAqIGF5KVxuICAgIH07XG4gICAgdGhpcy5pbWdEYXRhLmRhdGEuZmlsbCgwKTtcblxuICAgIC8vIGRlcG9zaXQgc2xpY2VzIG9uZSBieSBvbmUgaW50byB0aGUgaW1nRGF0YS5kYXRhIGZyb20gdm9sRGF0YS5cbiAgICBjb25zdCB2b2xpbWdkYXRhID0gdGhpcy5pbWdEYXRhLmRhdGE7XG4gICAgY29uc3QgeCA9IHZ4LFxuICAgICAgeSA9IHZ5LFxuICAgICAgeiA9IHZ6O1xuICAgIGNvbnN0IG51bVh0aWxlcyA9IHRoaXMuaW1nRGF0YS53aWR0aCAvIHg7XG4gICAgY29uc3QgYXRsYXNyb3cgPSB0aGlzLmltZ0RhdGEud2lkdGg7XG4gICAgbGV0IHRpbGV4ID0gMCxcbiAgICAgIHRpbGV5ID0gMCxcbiAgICAgIHRpbGVvZmZzZXQgPSAwLFxuICAgICAgdGlsZXJvd29mZnNldCA9IDAsXG4gICAgICBzb3VyY2VPZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgejsgKytpKSB7XG4gICAgICAvLyB0aWxlIG9mZnNldFxuICAgICAgdGlsZXggPSBpICUgbnVtWHRpbGVzO1xuICAgICAgdGlsZXkgPSBNYXRoLmZsb29yKGkgLyBudW1YdGlsZXMpO1xuICAgICAgdGlsZW9mZnNldCA9IHRpbGV4ICogeCArIHRpbGV5ICogeSAqIGF0bGFzcm93O1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB5OyArK2opIHtcbiAgICAgICAgdGlsZXJvd29mZnNldCA9IGogKiBhdGxhc3JvdztcbiAgICAgICAgc291cmNlT2Zmc2V0ID0gaSAqICh4ICogeSkgKyBqICogeDtcbiAgICAgICAgdm9saW1nZGF0YS5zZXQodGhpcy52b2x1bWVEYXRhLnN1YmFycmF5KHNvdXJjZU9mZnNldCwgc291cmNlT2Zmc2V0ICsgeCksIHRpbGVvZmZzZXQgKyB0aWxlcm93b2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZWJ1aWxkRGF0YVRleHR1cmUodGhpcy5pbWdEYXRhLmRhdGEsIGF4LCBheSk7XG4gIH1cbiAgc2V0THV0KGx1dCkge1xuICAgIHRoaXMubHV0ID0gbHV0O1xuICB9XG5cbiAgLy8gcGFsZXR0ZSBzaG91bGQgYmUgYW4gdWludDhhcnJheSBvZiAyNTYqNCBlbGVtZW50cyAoMjU2IHJnYmE4IHZhbHVlcylcbiAgc2V0Q29sb3JQYWxldHRlKHBhbGV0dGUpIHtcbiAgICB0aGlzLmNvbG9yUGFsZXR0ZSA9IHBhbGV0dGU7XG4gIH1cbiAgc2V0Q29sb3JQYWxldHRlQWxwaGEoYWxwaGEpIHtcbiAgICB0aGlzLmNvbG9yUGFsZXR0ZUFscGhhID0gYWxwaGE7XG4gIH1cbn0iXSwibmFtZXMiOlsiRGF0YVRleHR1cmUiLCJSZWRGb3JtYXQiLCJVbnNpZ25lZEJ5dGVUeXBlIiwiUkdCQUZvcm1hdCIsIkxpbmVhckZpbHRlciIsIk5lYXJlc3RGaWx0ZXIiLCJIaXN0b2dyYW0iLCJMdXQiLCJMVVRfQVJSQVlfTEVOR1RIIiwiQ2hhbm5lbCIsImNvbnN0cnVjdG9yIiwibmFtZSIsImxvYWRlZCIsImltZ0RhdGEiLCJkYXRhIiwiVWludDhDbGFtcGVkQXJyYXkiLCJ3aWR0aCIsImhlaWdodCIsInJhd01pbiIsInJhd01heCIsImRhdGFUZXh0dXJlIiwiVWludDhBcnJheSIsImx1dFRleHR1cmUiLCJtaW5GaWx0ZXIiLCJtYWdGaWx0ZXIiLCJnZW5lcmF0ZU1pcG1hcHMiLCJ2b2x1bWVEYXRhIiwiaGlzdG9ncmFtIiwiZGltcyIsImx1dCIsImNyZWF0ZUZyb21NaW5NYXgiLCJjb2xvclBhbGV0dGUiLCJmaWxsIiwiY29sb3JQYWxldHRlQWxwaGEiLCJjb21iaW5lTHV0cyIsInJnYkNvbG9yIiwib3V0IiwicmV0IiwicmdiIiwic2V0IiwiaSIsImltYWdlIiwibmVlZHNVcGRhdGUiLCJzZXRSYXdEYXRhUmFuZ2UiLCJtaW4iLCJtYXgiLCJyZW1hcERvbWFpbnMiLCJnZXRIaXN0b2dyYW0iLCJnZXRJbnRlbnNpdHkiLCJ4IiwieSIsInoiLCJnZXRJbnRlbnNpdHlGcm9tQXRsYXMiLCJudW1YdGlsZXMiLCJ0aWxleCIsInRpbGV5IiwiTWF0aCIsImZsb29yIiwib2Zmc2V0IiwicmVidWlsZERhdGFUZXh0dXJlIiwidyIsImgiLCJkaXNwb3NlIiwiZm9ybWF0IiwidHlwZSIsInNldEJpdHMiLCJiaXRzQXJyYXkiLCJidWZmZXIiLCJobWluIiwiaG1heCIsImZpbmRBdXRvSUpCaW5zIiwic2V0THV0IiwidW5wYWNrVm9sdW1lRnJvbUF0bGFzIiwidm9saW1nZGF0YSIsImF0bGFzcm93IiwidGlsZW9mZnNldCIsInRpbGVyb3dvZmZzZXQiLCJkZXN0T2Zmc2V0IiwiaiIsInN1YmFycmF5Iiwic2V0RnJvbVZvbHVtZURhdGEiLCJ2eCIsInZ5IiwidnoiLCJheCIsImF5IiwicGFja1RvQXRsYXMiLCJjb25zb2xlIiwibG9nIiwic291cmNlT2Zmc2V0Iiwic2V0Q29sb3JQYWxldHRlIiwicGFsZXR0ZSIsInNldENvbG9yUGFsZXR0ZUFscGhhIiwiYWxwaGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../volume-viewer/es/Channel.js\n");

/***/ }),

/***/ "../volume-viewer/es/Histogram.js":
/*!****************************************!*\
  !*** ../volume-viewer/es/Histogram.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Histogram)\n/* harmony export */ });\n/**\r\n * Builds a histogram with 256 bins from a data array. Assume data is 8 bit single channel grayscale.\r\n * @class\r\n * @param {Array.<number>} data\r\n */\nclass Histogram {\n  constructor(data) {\n    // no more than 2^32 pixels of any one intensity in the data!?!?!\n    this.bins = new Uint32Array(256);\n    this.bins.fill(0);\n    this.dataMin = 255;\n    this.dataMax = 0;\n    this.maxBin = 0;\n\n    // build up the histogram\n    for (let i = 0; i < data.length; ++i) {\n      this.bins[data[i]]++;\n    }\n    // track the first and last nonzero bins with at least 1 sample\n    for (let i = 1; i < this.bins.length; i++) {\n      if (this.bins[i] > 0) {\n        this.dataMin = i;\n        break;\n      }\n    }\n    for (let i = this.bins.length - 1; i >= 1; i--) {\n      if (this.bins[i] > 0) {\n        this.dataMax = i;\n        break;\n      }\n    }\n\n    // total number of pixels minus the number of zero pixels\n    this.nonzeroPixelCount = data.length - this.bins[0];\n\n    // get the bin with the most frequently occurring NONZERO value\n    this.maxBin = 1;\n    let max = this.bins[1];\n    for (let i = 1; i < this.bins.length; i++) {\n      if (this.bins[i] > max) {\n        this.maxBin = i;\n        max = this.bins[i];\n      }\n    }\n  }\n\n  /**\r\n   * Return the min data value\r\n   * @return {number}\r\n   */\n  getMin() {\n    return this.dataMin;\n  }\n\n  /**\r\n   * Return the max data value\r\n   * @return {number}\r\n   */\n  getMax() {\n    return this.dataMax;\n  }\n  getNumBins() {\n    return this.bins.length;\n  }\n  getBin(i) {\n    return this.bins[i];\n  }\n\n  /**\r\n   * Find the bin that contains the percentage of pixels below it\r\n   * @return {number}\r\n   * @param {number} pct\r\n   */\n  findBinOfPercentile(pct) {\n    const pixcount = this.nonzeroPixelCount + this.bins[0];\n    const limit = pixcount * pct;\n    let i = 0;\n    let count = 0;\n    for (i = 0; i < this.bins.length; ++i) {\n      count += this.bins[i];\n      if (count > limit) {\n        break;\n      }\n    }\n    return i;\n  }\n\n  // Find bins at 10th / 90th percentile\n  findBestFitBins() {\n    const pixcount = this.nonzeroPixelCount;\n    //const pixcount = this.imgData.data.length;\n    const limit = pixcount / 10;\n    let i = 0;\n    let count = 0;\n    for (i = 1; i < this.bins.length; ++i) {\n      count += this.bins[i];\n      if (count > limit) {\n        break;\n      }\n    }\n    const hmin = i;\n    count = 0;\n    for (i = this.bins.length - 1; i >= 1; --i) {\n      count += this.bins[i];\n      if (count > limit) {\n        break;\n      }\n    }\n    const hmax = i;\n    return [hmin, hmax];\n  }\n\n  // Find min and max bins attempting to replicate ImageJ's \"Auto\" button\n  findAutoIJBins() {\n    const AUTO_THRESHOLD = 5000;\n    const pixcount = this.nonzeroPixelCount;\n    //  const pixcount = this.imgData.data.length;\n    const limit = pixcount / 10;\n    const threshold = pixcount / AUTO_THRESHOLD;\n\n    // this will skip the \"zero\" bin which contains pixels of zero intensity.\n    let hmin = this.bins.length - 1;\n    let hmax = 1;\n    for (let i = 1; i < this.bins.length; ++i) {\n      if (this.bins[i] > threshold && this.bins[i] <= limit) {\n        hmin = i;\n        break;\n      }\n    }\n    for (let i = this.bins.length - 1; i >= 1; --i) {\n      if (this.bins[i] > threshold && this.bins[i] <= limit) {\n        hmax = i;\n        break;\n      }\n    }\n    if (hmax < hmin) {\n      hmin = 0;\n      hmax = 255;\n    }\n    return [hmin, hmax];\n  }\n\n  // Find min and max bins using a percentile of the most commonly occurring value\n  findAutoMinMax() {\n    // simple linear mapping cutting elements with small appearence\n    // get 10% threshold\n    const PERCENTAGE = 0.1;\n    const th = Math.floor(this.bins[this.maxBin] * PERCENTAGE);\n    let b = 0;\n    let e = this.bins.length - 1;\n    for (let x = 1; x < this.bins.length; ++x) {\n      if (this.bins[x] > th) {\n        b = x;\n        break;\n      }\n    }\n    for (let x = this.bins.length - 1; x >= 1; --x) {\n      if (this.bins[x] > th) {\n        e = x;\n        break;\n      }\n    }\n    return [b, e];\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQ0QsSUFBSSxFQUFFQyxJQUFJLENBQUM7RUFDckI7O0VBRUE7RUFDQUksY0FBY0EsQ0FBQSxFQUFHO0lBQ2Y7SUFDQTtJQUNBLE1BQU1DLFVBQVUsR0FBRyxHQUFHO0lBQ3RCLE1BQU1DLEVBQUUsR0FBR0MsSUFBSSxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDN0IsSUFBSSxDQUFDLElBQUksQ0FBQ0ssTUFBTSxDQUFDLEdBQUdxQixVQUFVLENBQUM7SUFDMUQsSUFBSUksQ0FBQyxHQUFHLENBQUM7SUFDVCxJQUFJQyxDQUFDLEdBQUcsSUFBSSxDQUFDL0IsSUFBSSxDQUFDTyxNQUFNLEdBQUcsQ0FBQztJQUM1QixLQUFLLElBQUl5QixDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUcsSUFBSSxDQUFDaEMsSUFBSSxDQUFDTyxNQUFNLEVBQUUsRUFBRXlCLENBQUMsRUFBRTtNQUN6QyxJQUFJLElBQUksQ0FBQ2hDLElBQUksQ0FBQ2dDLENBQUMsQ0FBQyxHQUFHTCxFQUFFLEVBQUU7UUFDckJHLENBQUMsR0FBR0UsQ0FBQztRQUNMO01BQ0Y7SUFDRjtJQUNBLEtBQUssSUFBSUEsQ0FBQyxHQUFHLElBQUksQ0FBQ2hDLElBQUksQ0FBQ08sTUFBTSxHQUFHLENBQUMsRUFBRXlCLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRUEsQ0FBQyxFQUFFO01BQzlDLElBQUksSUFBSSxDQUFDaEMsSUFBSSxDQUFDZ0MsQ0FBQyxDQUFDLEdBQUdMLEVBQUUsRUFBRTtRQUNyQkksQ0FBQyxHQUFHQyxDQUFDO1FBQ0w7TUFDRjtJQUNGO0lBQ0EsT0FBTyxDQUFDRixDQUFDLEVBQUVDLENBQUMsQ0FBQztFQUNmO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4uL3ZvbHVtZS12aWV3ZXIvZXMvSGlzdG9ncmFtLmpzPzQ5ODEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEJ1aWxkcyBhIGhpc3RvZ3JhbSB3aXRoIDI1NiBiaW5zIGZyb20gYSBkYXRhIGFycmF5LiBBc3N1bWUgZGF0YSBpcyA4IGJpdCBzaW5nbGUgY2hhbm5lbCBncmF5c2NhbGUuXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkYXRhXHJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGlzdG9ncmFtIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIC8vIG5vIG1vcmUgdGhhbiAyXjMyIHBpeGVscyBvZiBhbnkgb25lIGludGVuc2l0eSBpbiB0aGUgZGF0YSE/IT8hXG4gICAgdGhpcy5iaW5zID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdGhpcy5iaW5zLmZpbGwoMCk7XG4gICAgdGhpcy5kYXRhTWluID0gMjU1O1xuICAgIHRoaXMuZGF0YU1heCA9IDA7XG4gICAgdGhpcy5tYXhCaW4gPSAwO1xuXG4gICAgLy8gYnVpbGQgdXAgdGhlIGhpc3RvZ3JhbVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgdGhpcy5iaW5zW2RhdGFbaV1dKys7XG4gICAgfVxuICAgIC8vIHRyYWNrIHRoZSBmaXJzdCBhbmQgbGFzdCBub256ZXJvIGJpbnMgd2l0aCBhdCBsZWFzdCAxIHNhbXBsZVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5iaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5iaW5zW2ldID4gMCkge1xuICAgICAgICB0aGlzLmRhdGFNaW4gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuYmlucy5sZW5ndGggLSAxOyBpID49IDE7IGktLSkge1xuICAgICAgaWYgKHRoaXMuYmluc1tpXSA+IDApIHtcbiAgICAgICAgdGhpcy5kYXRhTWF4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdG90YWwgbnVtYmVyIG9mIHBpeGVscyBtaW51cyB0aGUgbnVtYmVyIG9mIHplcm8gcGl4ZWxzXG4gICAgdGhpcy5ub256ZXJvUGl4ZWxDb3VudCA9IGRhdGEubGVuZ3RoIC0gdGhpcy5iaW5zWzBdO1xuXG4gICAgLy8gZ2V0IHRoZSBiaW4gd2l0aCB0aGUgbW9zdCBmcmVxdWVudGx5IG9jY3VycmluZyBOT05aRVJPIHZhbHVlXG4gICAgdGhpcy5tYXhCaW4gPSAxO1xuICAgIGxldCBtYXggPSB0aGlzLmJpbnNbMV07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLmJpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmJpbnNbaV0gPiBtYXgpIHtcbiAgICAgICAgdGhpcy5tYXhCaW4gPSBpO1xuICAgICAgICBtYXggPSB0aGlzLmJpbnNbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBtaW4gZGF0YSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cbiAgZ2V0TWluKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFNaW47XG4gIH1cblxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIG1heCBkYXRhIHZhbHVlXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xuICBnZXRNYXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YU1heDtcbiAgfVxuICBnZXROdW1CaW5zKCkge1xuICAgIHJldHVybiB0aGlzLmJpbnMubGVuZ3RoO1xuICB9XG4gIGdldEJpbihpKSB7XG4gICAgcmV0dXJuIHRoaXMuYmluc1tpXTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEZpbmQgdGhlIGJpbiB0aGF0IGNvbnRhaW5zIHRoZSBwZXJjZW50YWdlIG9mIHBpeGVscyBiZWxvdyBpdFxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcGN0XHJcbiAgICovXG4gIGZpbmRCaW5PZlBlcmNlbnRpbGUocGN0KSB7XG4gICAgY29uc3QgcGl4Y291bnQgPSB0aGlzLm5vbnplcm9QaXhlbENvdW50ICsgdGhpcy5iaW5zWzBdO1xuICAgIGNvbnN0IGxpbWl0ID0gcGl4Y291bnQgKiBwY3Q7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYmlucy5sZW5ndGg7ICsraSkge1xuICAgICAgY291bnQgKz0gdGhpcy5iaW5zW2ldO1xuICAgICAgaWYgKGNvdW50ID4gbGltaXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG5cbiAgLy8gRmluZCBiaW5zIGF0IDEwdGggLyA5MHRoIHBlcmNlbnRpbGVcbiAgZmluZEJlc3RGaXRCaW5zKCkge1xuICAgIGNvbnN0IHBpeGNvdW50ID0gdGhpcy5ub256ZXJvUGl4ZWxDb3VudDtcbiAgICAvL2NvbnN0IHBpeGNvdW50ID0gdGhpcy5pbWdEYXRhLmRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGxpbWl0ID0gcGl4Y291bnQgLyAxMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGkgPSAxOyBpIDwgdGhpcy5iaW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb3VudCArPSB0aGlzLmJpbnNbaV07XG4gICAgICBpZiAoY291bnQgPiBsaW1pdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaG1pbiA9IGk7XG4gICAgY291bnQgPSAwO1xuICAgIGZvciAoaSA9IHRoaXMuYmlucy5sZW5ndGggLSAxOyBpID49IDE7IC0taSkge1xuICAgICAgY291bnQgKz0gdGhpcy5iaW5zW2ldO1xuICAgICAgaWYgKGNvdW50ID4gbGltaXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhtYXggPSBpO1xuICAgIHJldHVybiBbaG1pbiwgaG1heF07XG4gIH1cblxuICAvLyBGaW5kIG1pbiBhbmQgbWF4IGJpbnMgYXR0ZW1wdGluZyB0byByZXBsaWNhdGUgSW1hZ2VKJ3MgXCJBdXRvXCIgYnV0dG9uXG4gIGZpbmRBdXRvSUpCaW5zKCkge1xuICAgIGNvbnN0IEFVVE9fVEhSRVNIT0xEID0gNTAwMDtcbiAgICBjb25zdCBwaXhjb3VudCA9IHRoaXMubm9uemVyb1BpeGVsQ291bnQ7XG4gICAgLy8gIGNvbnN0IHBpeGNvdW50ID0gdGhpcy5pbWdEYXRhLmRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGxpbWl0ID0gcGl4Y291bnQgLyAxMDtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBwaXhjb3VudCAvIEFVVE9fVEhSRVNIT0xEO1xuXG4gICAgLy8gdGhpcyB3aWxsIHNraXAgdGhlIFwiemVyb1wiIGJpbiB3aGljaCBjb250YWlucyBwaXhlbHMgb2YgemVybyBpbnRlbnNpdHkuXG4gICAgbGV0IGhtaW4gPSB0aGlzLmJpbnMubGVuZ3RoIC0gMTtcbiAgICBsZXQgaG1heCA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLmJpbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmJpbnNbaV0gPiB0aHJlc2hvbGQgJiYgdGhpcy5iaW5zW2ldIDw9IGxpbWl0KSB7XG4gICAgICAgIGhtaW4gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuYmlucy5sZW5ndGggLSAxOyBpID49IDE7IC0taSkge1xuICAgICAgaWYgKHRoaXMuYmluc1tpXSA+IHRocmVzaG9sZCAmJiB0aGlzLmJpbnNbaV0gPD0gbGltaXQpIHtcbiAgICAgICAgaG1heCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaG1heCA8IGhtaW4pIHtcbiAgICAgIGhtaW4gPSAwO1xuICAgICAgaG1heCA9IDI1NTtcbiAgICB9XG4gICAgcmV0dXJuIFtobWluLCBobWF4XTtcbiAgfVxuXG4gIC8vIEZpbmQgbWluIGFuZCBtYXggYmlucyB1c2luZyBhIHBlcmNlbnRpbGUgb2YgdGhlIG1vc3QgY29tbW9ubHkgb2NjdXJyaW5nIHZhbHVlXG4gIGZpbmRBdXRvTWluTWF4KCkge1xuICAgIC8vIHNpbXBsZSBsaW5lYXIgbWFwcGluZyBjdXR0aW5nIGVsZW1lbnRzIHdpdGggc21hbGwgYXBwZWFyZW5jZVxuICAgIC8vIGdldCAxMCUgdGhyZXNob2xkXG4gICAgY29uc3QgUEVSQ0VOVEFHRSA9IDAuMTtcbiAgICBjb25zdCB0aCA9IE1hdGguZmxvb3IodGhpcy5iaW5zW3RoaXMubWF4QmluXSAqIFBFUkNFTlRBR0UpO1xuICAgIGxldCBiID0gMDtcbiAgICBsZXQgZSA9IHRoaXMuYmlucy5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IHggPSAxOyB4IDwgdGhpcy5iaW5zLmxlbmd0aDsgKyt4KSB7XG4gICAgICBpZiAodGhpcy5iaW5zW3hdID4gdGgpIHtcbiAgICAgICAgYiA9IHg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCB4ID0gdGhpcy5iaW5zLmxlbmd0aCAtIDE7IHggPj0gMTsgLS14KSB7XG4gICAgICBpZiAodGhpcy5iaW5zW3hdID4gdGgpIHtcbiAgICAgICAgZSA9IHg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2IsIGVdO1xuICB9XG59Il0sIm5hbWVzIjpbIkhpc3RvZ3JhbSIsImNvbnN0cnVjdG9yIiwiZGF0YSIsImJpbnMiLCJVaW50MzJBcnJheSIsImZpbGwiLCJkYXRhTWluIiwiZGF0YU1heCIsIm1heEJpbiIsImkiLCJsZW5ndGgiLCJub256ZXJvUGl4ZWxDb3VudCIsIm1heCIsImdldE1pbiIsImdldE1heCIsImdldE51bUJpbnMiLCJnZXRCaW4iLCJmaW5kQmluT2ZQZXJjZW50aWxlIiwicGN0IiwicGl4Y291bnQiLCJsaW1pdCIsImNvdW50IiwiZmluZEJlc3RGaXRCaW5zIiwiaG1pbiIsImhtYXgiLCJmaW5kQXV0b0lKQmlucyIsIkFVVE9fVEhSRVNIT0xEIiwidGhyZXNob2xkIiwiZmluZEF1dG9NaW5NYXgiLCJQRVJDRU5UQUdFIiwidGgiLCJNYXRoIiwiZmxvb3IiLCJiIiwiZSIsIngiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../volume-viewer/es/Histogram.js\n");

/***/ }),

/***/ "../volume-viewer/es/Lut.js":
/*!**********************************!*\
  !*** ../volume-viewer/es/Lut.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LUT_ARRAY_LENGTH: () => (/* binding */ LUT_ARRAY_LENGTH),\n/* harmony export */   LUT_ENTRIES: () => (/* binding */ LUT_ENTRIES),\n/* harmony export */   Lut: () => (/* binding */ Lut),\n/* harmony export */   remapControlPoints: () => (/* binding */ remapControlPoints),\n/* harmony export */   remapLut: () => (/* binding */ remapLut)\n/* harmony export */ });\n/* harmony import */ var _constants_colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/colors.js */ \"../volume-viewer/es/constants/colors.js\");\n\nfunction clamp(val, cmin, cmax) {\n  return Math.min(Math.max(cmin, val), cmax);\n}\nfunction lerp(xmin, xmax, a) {\n  return a * (xmax - xmin) + xmin;\n}\n\n// We have an intensity value that is in the range of valueMin to valueMax.\n// This domain is assumed to have been remapped from oldMin to oldMax.\n// We now wish to find the intensity value that corresponds to the same relative position in the new domain of newMin to newMax.\n// For our Luts valueMin will always be 0, and valueMax will always be 255.\n// oldMin and oldMax will be the domain of the original raw data intensities.\n// newMin and newMax will be the domain of the new raw data intensities.\nfunction remapDomain(value, valueMin, valueMax, oldMin, oldMax, newMin, newMax) {\n  const pctOfRange = (value - valueMin) / (valueMax - valueMin);\n  const newValue = (newMax - newMin) * pctOfRange + newMin;\n  // now locate this value as a relative index in the old range\n  const pctOfOldRange = (newValue - oldMin) / (oldMax - oldMin);\n  const remapped = valueMin + pctOfOldRange * (valueMax - valueMin);\n  return remapped;\n}\n\n// We have an intensity value that is in the range of valueMin to valueMax.\n// The input value range is assumed to represent absolute intensity range oldMin to oldMax.\n// We now wish to find the new position of this intensity value\n// when the valueMin-valueMax represents absolute range newMin to newMax\n// After the remapping, the intensity value will be in the range of valueMin to valueMax.\n// For our Luts valueMin will always be 0, and valueMax will always be 255.\n// oldMin and oldMax will be the domain of the original raw data intensities.\n// newMin and newMax will be the domain of the new raw data intensities.\nfunction remapDomainForCP(value, valueMin, valueMax, oldMin, oldMax, newMin, newMax) {\n  const pctOfRange = (value - valueMin) / (valueMax - valueMin);\n  // find abs intensity from old range\n  const iOld = (oldMax - oldMin) * pctOfRange + oldMin;\n  // now locate this value as a relative index in the new range\n  const pctOfNewRange = (iOld - newMin) / (newMax - newMin);\n  const remapped = valueMin + pctOfNewRange * (valueMax - valueMin);\n  return remapped;\n}\nconst LUT_ENTRIES = 256;\nconst LUT_ARRAY_LENGTH = LUT_ENTRIES * 4;\n\n/**\r\n * @typedef {Object} ControlPoint Used for the TF (transfer function) editor GUI.\r\n * Need to be converted to LUT for rendering.\r\n * @property {number} x The X Coordinate\r\n * @property {number} opacity The Opacity, from 0 to 1\r\n * @property {Array.<number>} color The Color, 3 numbers from 0-255 for r,g,b\r\n */\n\nfunction controlPointToRGBA(controlPoint) {\n  return [controlPoint.color[0], controlPoint.color[1], controlPoint.color[2], Math.floor(controlPoint.opacity * 255)];\n}\n\n/**\r\n * @typedef {Object} Lut Used for rendering.\r\n * @property {Array.<number>} lut LUT_ARRAY_LENGTH element lookup table as array\r\n * (maps scalar intensity to a rgb color plus alpha, with each value from 0-255)\r\n * @property {Array.<ControlPoint>} controlPoints\r\n */\nclass Lut {\n  constructor() {\n    this.lut = new Uint8Array(LUT_ARRAY_LENGTH);\n    this.controlPoints = [];\n    this.createFullRange();\n  }\n\n  /**\r\n   * Generate a piecewise linear lookup table that ramps up from 0 to 1 over the b to e domain.\r\n   * If e === b, then we use a step function with f(b) = 0 and f(b + 1) = 1\r\n   *  |\r\n   * 1|               +---------+-----\r\n   *  |              /\r\n   *  |             /\r\n   *  |            /\r\n   *  |           /\r\n   *  |          /\r\n   * 0+=========+---------------+-----\r\n   *  0         b    e         255\r\n   * @return {Lut}\r\n   * @param {number} b\r\n   * @param {number} e\r\n   */\n  createFromMinMax(b, e) {\n    if (e < b) {\n      // swap\n      const tmp = e;\n      e = b;\n      b = tmp;\n    }\n    const lut = new Uint8Array(LUT_ARRAY_LENGTH);\n    for (let x = 0; x < lut.length / 4; ++x) {\n      lut[x * 4 + 0] = 255;\n      lut[x * 4 + 1] = 255;\n      lut[x * 4 + 2] = 255;\n      if (x > e) {\n        lut[x * 4 + 3] = 255;\n      } else if (x <= b) {\n        lut[x * 4 + 3] = 0;\n      } else {\n        if (e === b) {\n          lut[x * 4 + 3] = 255;\n        } else {\n          const a = (x - b) / (e - b);\n          lut[x * 4 + 3] = lerp(0, 255, a);\n        }\n      }\n    }\n\n    // Edge case: b and e are both out of bounds\n    if (b < 0 && e < 0) {\n      this.lut = lut;\n      this.controlPoints = [{\n        x: 0,\n        opacity: 1,\n        color: [255, 255, 255]\n      }, {\n        x: 255,\n        opacity: 1,\n        color: [255, 255, 255]\n      }];\n      return this;\n    }\n    if (b >= 255 && e >= 255) {\n      this.lut = lut;\n      this.controlPoints = [{\n        x: 0,\n        opacity: 0,\n        color: [255, 255, 255]\n      }, {\n        x: 255,\n        opacity: 0,\n        color: [255, 255, 255]\n      }];\n      return this;\n    }\n\n    // Generate 2 to 4 control points for a minMax LUT, from left to right\n    const controlPoints = [];\n\n    // Add starting point at x = 0\n    let startVal = 0;\n    if (b < 0) {\n      startVal = -b / (e - b);\n    }\n    controlPoints.push({\n      x: 0,\n      opacity: startVal,\n      color: [255, 255, 255]\n    });\n\n    // If b > 0, add another point at (b, 0)\n    if (b > 0) {\n      controlPoints.push({\n        x: b,\n        opacity: 0,\n        color: [255, 255, 255]\n      });\n    }\n\n    // If e < 255, Add another point at (e, 1)\n    if (e < 255) {\n      if (e === b) {\n        // Use b + 0.5 as x value instead of e to create a near-vertical ramp\n        controlPoints.push({\n          x: b + 0.5,\n          opacity: 1,\n          color: [255, 255, 255]\n        });\n      } else {\n        controlPoints.push({\n          x: e,\n          opacity: 1,\n          color: [255, 255, 255]\n        });\n      }\n    }\n\n    // Add ending point at x = 255\n    let endVal = 1;\n    if (e > 255) {\n      endVal = (255 - b) / (e - b);\n    }\n    controlPoints.push({\n      x: 255,\n      opacity: endVal,\n      color: [255, 255, 255]\n    });\n    this.lut = lut;\n    this.controlPoints = controlPoints;\n    return this;\n  }\n\n  // basically, the identity LUT with respect to opacity\n  createFullRange() {\n    const lut = new Uint8Array(LUT_ARRAY_LENGTH);\n\n    // simple linear mapping for actual range\n    for (let x = 0; x < lut.length / 4; ++x) {\n      lut[x * 4 + 0] = 255;\n      lut[x * 4 + 1] = 255;\n      lut[x * 4 + 2] = 255;\n      lut[x * 4 + 3] = x;\n    }\n    this.lut = lut;\n    this.controlPoints = [{\n      x: 0,\n      opacity: 0,\n      color: [255, 255, 255]\n    }, {\n      x: 255,\n      opacity: 1,\n      color: [255, 255, 255]\n    }];\n    return this;\n  }\n\n  /**\r\n   * Generate a Window/level lookup table\r\n   * @return {Lut}\r\n   * @param {number} wnd in 0..1 range\r\n   * @param {number} lvl in 0..1 range\r\n   */\n  createFromWindowLevel(wnd, lvl) {\n    // simple linear mapping for actual range\n    const b = lvl - wnd * 0.5;\n    const e = lvl + wnd * 0.5;\n    return this.createFromMinMax(b * 255, e * 255);\n  }\n\n  // @param {Object[]} controlPoints - array of {x:number 0..255, opacity:number 0..1, color:array of 3 numbers 0..255}\n  // @return {Uint8Array} array of length 256*4 representing the rgba values of the gradient\n  createFromControlPoints(controlPoints) {\n    const lut = new Uint8Array(LUT_ARRAY_LENGTH).fill(0);\n    if (controlPoints.length === 0) {\n      this.lut = lut;\n      this.controlPoints = controlPoints;\n      return this;\n    }\n\n    // ensure they are sorted in ascending order of x\n    controlPoints.sort((a, b) => a.x - b.x);\n\n    // special case only one control point.\n    if (controlPoints.length === 1) {\n      const rgba = controlPointToRGBA(controlPoints[0]);\n      // lut was already filled with zeros\n      // copy val from x to 255.\n      const startx = clamp(controlPoints[0].x, 0, 255);\n      for (let x = startx; x < 256; ++x) {\n        lut[x * 4 + 0] = rgba[0];\n        lut[x * 4 + 1] = rgba[1];\n        lut[x * 4 + 2] = rgba[2];\n        lut[x * 4 + 3] = rgba[3];\n      }\n      this.lut = lut;\n      this.controlPoints = controlPoints;\n      return this;\n    }\n    let c0 = controlPoints[0];\n    let c1 = controlPoints[1];\n    let color0 = controlPointToRGBA(c0);\n    let color1 = controlPointToRGBA(c1);\n    let lastIndex = 1;\n    let a = 0;\n    for (let i = 0; i < 256; ++i) {\n      // find the two control points that i is between\n      while (i > c1.x) {\n        // advance control points\n        c0 = c1;\n        color0 = color1;\n        lastIndex++;\n        if (lastIndex >= controlPoints.length) {\n          // if the last control point is before 255, then we want to continue its value all the way to 255.\n          c1 = {\n            x: 255,\n            color: c1.color,\n            opacity: c1.opacity\n          };\n        } else {\n          c1 = controlPoints[lastIndex];\n        }\n        color1 = controlPointToRGBA(c1);\n      }\n      // find the lerp amount between the two control points\n      if (c1.x === c0.x) {\n        // use c1\n        a = 1.0;\n      } else {\n        a = (i - c0.x) / (c1.x - c0.x);\n      }\n      lut[i * 4 + 0] = clamp(lerp(color0[0], color1[0], a), 0, 255);\n      lut[i * 4 + 1] = clamp(lerp(color0[1], color1[1], a), 0, 255);\n      lut[i * 4 + 2] = clamp(lerp(color0[2], color1[2], a), 0, 255);\n      lut[i * 4 + 3] = clamp(lerp(color0[3], color1[3], a), 0, 255);\n    }\n    this.lut = lut;\n    this.controlPoints = controlPoints;\n    return this;\n  }\n\n  /**\r\n   * Generate an \"equalized\" lookup table\r\n   * @return {Lut}\r\n   */\n  createFromEqHistogram(histogram) {\n    const map = [];\n    for (let i = 0; i < histogram.getNumBins(); ++i) {\n      map[i] = 0;\n    }\n\n    // summed area table?\n    map[0] = histogram.getBin(0);\n    for (let i = 1; i < histogram.getNumBins(); ++i) {\n      map[i] = map[i - 1] + histogram.getBin(i);\n    }\n    const div = map[map.length - 1] - map[0];\n    if (div > 0) {\n      const lut = new Uint8Array(LUT_ARRAY_LENGTH);\n\n      // compute lut and track control points for the piecewise linear sections\n      const lutControlPoints = [{\n        x: 0,\n        opacity: 0,\n        color: [255, 255, 255]\n      }];\n      lut[0] = 255;\n      lut[1] = 255;\n      lut[2] = 255;\n      lut[3] = 0;\n      let slope = 0;\n      let lastSlope = 0;\n      let opacity = 0;\n      let lastOpacity = 0;\n      for (let i = 1; i < lut.length / 4; ++i) {\n        lut[i * 4 + 0] = 255;\n        lut[i * 4 + 1] = 255;\n        lut[i * 4 + 2] = 255;\n        lastOpacity = opacity;\n        opacity = clamp(Math.round(255 * (map[i] - map[0])), 0, 255);\n        lut[i * 4 + 3] = opacity;\n        slope = opacity - lastOpacity;\n        // if map[i]-map[i-1] is the same as map[i+1]-map[i] then we are in a linear segment and do not need a new control point\n        if (slope != lastSlope) {\n          lutControlPoints.push({\n            x: i - 1,\n            opacity: lastOpacity / 255.0,\n            color: [255, 255, 255]\n          });\n          lastSlope = slope;\n        }\n      }\n      lutControlPoints.push({\n        x: 255,\n        opacity: 1,\n        color: [255, 255, 255]\n      });\n      this.lut = lut;\n      this.controlPoints = lutControlPoints;\n      return this;\n    } else {\n      // just reset to whole range in this case...?\n      return this.createFullRange();\n    }\n  }\n\n  /**\r\n   * Generate a lookup table with a different color per intensity value.\r\n   * This translates to a unique color per histogram bin with more than zero pixels.\r\n   * @return {Lut}\r\n   */\n  createLabelColors(histogram) {\n    const lut = new Uint8Array(LUT_ARRAY_LENGTH).fill(0);\n    const controlPoints = [];\n    controlPoints.push({\n      x: 0,\n      opacity: 0,\n      color: [0, 0, 0]\n    });\n    let lastr = 0;\n    let lastg = 0;\n    let lastb = 0;\n    let lasta = 0;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n\n    // assumes exactly one bin per intensity value?\n    // skip zero!!!\n    for (let i = 1; i < histogram.getNumBins(); ++i) {\n      if (histogram.getBin(i) > 0) {\n        const rgb = (0,_constants_colors_js__WEBPACK_IMPORTED_MODULE_0__.getColorByChannelIndex)(i);\n        lut[i * 4 + 0] = rgb[0];\n        lut[i * 4 + 1] = rgb[1];\n        lut[i * 4 + 2] = rgb[2];\n        lut[i * 4 + 3] = 255;\n        r = rgb[0];\n        g = rgb[1];\n        b = rgb[2];\n        a = 1;\n      } else {\n        // add a zero control point?\n        r = 0;\n        g = 0;\n        b = 0;\n        a = 0;\n      }\n      // if current control point is same as last one don't add it\n      if (r !== lastr || g !== lastg || b !== lastb || a !== lasta) {\n        if (lasta === 0) {\n          controlPoints.push({\n            x: i - 0.5,\n            opacity: lasta,\n            color: [lastr, lastg, lastb]\n          });\n        }\n        controlPoints.push({\n          x: i,\n          opacity: a,\n          color: [r, g, b]\n        });\n        lastr = r;\n        lastg = g;\n        lastb = b;\n        lasta = a;\n      }\n    }\n    this.lut = lut;\n    this.controlPoints = controlPoints;\n    return this;\n  }\n\n  // since this is not a \"create\" function, it doesn't need to return the object.\n  remapDomains(oldMin, oldMax, newMin, newMax) {\n    // no attempt is made here to ensure that lut and controlPoints are internally consistent.\n    // if they start out consistent, they should end up consistent. And vice versa.\n    this.lut = remapLut(this.lut, oldMin, oldMax, newMin, newMax);\n    this.controlPoints = remapControlPoints(this.controlPoints, oldMin, oldMax, newMin, newMax);\n  }\n}\n\n// If the new max is greater than the old max, then\n// the lut's max end will move inward to the left.\n// This is another way of saying that the new max's index is greater than 255 in the old lut\n// If the new min is less than the old min, then\n// the lut's min end will move inward to the right.\n// This is another way of saying that the new min's index is less than 0 in the old lut\nfunction remapLut(lut, oldMin, oldMax, newMin, newMax) {\n  const newLut = new Uint8Array(LUT_ARRAY_LENGTH);\n\n  // we will find what intensity is at each index in the new range,\n  // and then try to sample the pre-existing lut as if it spans the old range.\n  // Build new lut by sampling from old lut.\n  for (let i = 0; i < LUT_ENTRIES; ++i) {\n    let iOld = remapDomain(i, 0, LUT_ENTRIES - 1, oldMin, oldMax, newMin, newMax);\n    if (iOld < 0) {\n      iOld = 0;\n    }\n    if (iOld > LUT_ENTRIES - 1) {\n      iOld = LUT_ENTRIES - 1;\n    }\n    // find the indices above and below for interpolation\n    const i0 = Math.floor(iOld);\n    const i1 = Math.ceil(iOld);\n    const pct = iOld - i0;\n\n    //console.log(`interpolating ${iOld}: ${lut[i0 * 4 + 3]}, ${lut[i1 * 4 + 3]}, ${pct}`);\n    newLut[i * 4 + 0] = Math.round(lerp(lut[i0 * 4 + 0], lut[i1 * 4 + 0], pct));\n    newLut[i * 4 + 1] = Math.round(lerp(lut[i0 * 4 + 1], lut[i1 * 4 + 1], pct));\n    newLut[i * 4 + 2] = Math.round(lerp(lut[i0 * 4 + 2], lut[i1 * 4 + 2], pct));\n    newLut[i * 4 + 3] = Math.round(lerp(lut[i0 * 4 + 3], lut[i1 * 4 + 3], pct));\n  }\n  return newLut;\n}\nfunction remapControlPoints(controlPoints, oldMin, oldMax, newMin, newMax) {\n  const newControlPoints = [];\n\n  // assume control point x domain 0-255 is mapped to oldMin-oldMax\n\n  // remap all cp x values.\n  // interpolate all new colors and opacities\n  // Do not clip values outside of 0-255. This is important to\n  // preserve information for remapping many consecutive times.\n  for (let i = 0; i < controlPoints.length; ++i) {\n    const cp = controlPoints[i];\n    const iOld = remapDomainForCP(cp.x, 0, LUT_ENTRIES - 1, oldMin, oldMax, newMin, newMax);\n    const newCP = {\n      x: iOld,\n      opacity: cp.opacity,\n      color: [cp.color[0], cp.color[1], cp.color[2]]\n    };\n    newControlPoints.push(newCP);\n  }\n  return newControlPoints;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHeEIsYUFBYSxDQUFDTyxNQUFNLEVBQUUsRUFBRWlCLENBQUMsRUFBRTtJQUM3QyxNQUFNNkIsRUFBRSxHQUFHckQsYUFBYSxDQUFDd0IsQ0FBQyxDQUFDO0lBQzNCLE1BQU1yQyxJQUFJLEdBQUdELGdCQUFnQixDQUFDbUUsRUFBRSxDQUFDL0MsQ0FBQyxFQUFFLENBQUMsRUFBRWpCLFdBQVcsR0FBRyxDQUFDLEVBQUVYLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLE1BQU0sQ0FBQztJQUN2RixNQUFNeUUsS0FBSyxHQUFHO01BQ1poRCxDQUFDLEVBQUVuQixJQUFJO01BQ1BRLE9BQU8sRUFBRTBELEVBQUUsQ0FBQzFELE9BQU87TUFDbkJGLEtBQUssRUFBRSxDQUFDNEQsRUFBRSxDQUFDNUQsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFNEQsRUFBRSxDQUFDNUQsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFNEQsRUFBRSxDQUFDNUQsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUMvQyxDQUFDO0lBQ0QyRCxnQkFBZ0IsQ0FBQzNDLElBQUksQ0FBQzZDLEtBQUssQ0FBQztFQUM5QjtFQUNBLE9BQU9GLGdCQUFnQjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi4vdm9sdW1lLXZpZXdlci9lcy9MdXQuanM/ZDhmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRDb2xvckJ5Q2hhbm5lbEluZGV4IH0gZnJvbSBcIi4vY29uc3RhbnRzL2NvbG9ycy5qc1wiO1xuZnVuY3Rpb24gY2xhbXAodmFsLCBjbWluLCBjbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChjbWluLCB2YWwpLCBjbWF4KTtcbn1cbmZ1bmN0aW9uIGxlcnAoeG1pbiwgeG1heCwgYSkge1xuICByZXR1cm4gYSAqICh4bWF4IC0geG1pbikgKyB4bWluO1xufVxuXG4vLyBXZSBoYXZlIGFuIGludGVuc2l0eSB2YWx1ZSB0aGF0IGlzIGluIHRoZSByYW5nZSBvZiB2YWx1ZU1pbiB0byB2YWx1ZU1heC5cbi8vIFRoaXMgZG9tYWluIGlzIGFzc3VtZWQgdG8gaGF2ZSBiZWVuIHJlbWFwcGVkIGZyb20gb2xkTWluIHRvIG9sZE1heC5cbi8vIFdlIG5vdyB3aXNoIHRvIGZpbmQgdGhlIGludGVuc2l0eSB2YWx1ZSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBzYW1lIHJlbGF0aXZlIHBvc2l0aW9uIGluIHRoZSBuZXcgZG9tYWluIG9mIG5ld01pbiB0byBuZXdNYXguXG4vLyBGb3Igb3VyIEx1dHMgdmFsdWVNaW4gd2lsbCBhbHdheXMgYmUgMCwgYW5kIHZhbHVlTWF4IHdpbGwgYWx3YXlzIGJlIDI1NS5cbi8vIG9sZE1pbiBhbmQgb2xkTWF4IHdpbGwgYmUgdGhlIGRvbWFpbiBvZiB0aGUgb3JpZ2luYWwgcmF3IGRhdGEgaW50ZW5zaXRpZXMuXG4vLyBuZXdNaW4gYW5kIG5ld01heCB3aWxsIGJlIHRoZSBkb21haW4gb2YgdGhlIG5ldyByYXcgZGF0YSBpbnRlbnNpdGllcy5cbmZ1bmN0aW9uIHJlbWFwRG9tYWluKHZhbHVlLCB2YWx1ZU1pbiwgdmFsdWVNYXgsIG9sZE1pbiwgb2xkTWF4LCBuZXdNaW4sIG5ld01heCkge1xuICBjb25zdCBwY3RPZlJhbmdlID0gKHZhbHVlIC0gdmFsdWVNaW4pIC8gKHZhbHVlTWF4IC0gdmFsdWVNaW4pO1xuICBjb25zdCBuZXdWYWx1ZSA9IChuZXdNYXggLSBuZXdNaW4pICogcGN0T2ZSYW5nZSArIG5ld01pbjtcbiAgLy8gbm93IGxvY2F0ZSB0aGlzIHZhbHVlIGFzIGEgcmVsYXRpdmUgaW5kZXggaW4gdGhlIG9sZCByYW5nZVxuICBjb25zdCBwY3RPZk9sZFJhbmdlID0gKG5ld1ZhbHVlIC0gb2xkTWluKSAvIChvbGRNYXggLSBvbGRNaW4pO1xuICBjb25zdCByZW1hcHBlZCA9IHZhbHVlTWluICsgcGN0T2ZPbGRSYW5nZSAqICh2YWx1ZU1heCAtIHZhbHVlTWluKTtcbiAgcmV0dXJuIHJlbWFwcGVkO1xufVxuXG4vLyBXZSBoYXZlIGFuIGludGVuc2l0eSB2YWx1ZSB0aGF0IGlzIGluIHRoZSByYW5nZSBvZiB2YWx1ZU1pbiB0byB2YWx1ZU1heC5cbi8vIFRoZSBpbnB1dCB2YWx1ZSByYW5nZSBpcyBhc3N1bWVkIHRvIHJlcHJlc2VudCBhYnNvbHV0ZSBpbnRlbnNpdHkgcmFuZ2Ugb2xkTWluIHRvIG9sZE1heC5cbi8vIFdlIG5vdyB3aXNoIHRvIGZpbmQgdGhlIG5ldyBwb3NpdGlvbiBvZiB0aGlzIGludGVuc2l0eSB2YWx1ZVxuLy8gd2hlbiB0aGUgdmFsdWVNaW4tdmFsdWVNYXggcmVwcmVzZW50cyBhYnNvbHV0ZSByYW5nZSBuZXdNaW4gdG8gbmV3TWF4XG4vLyBBZnRlciB0aGUgcmVtYXBwaW5nLCB0aGUgaW50ZW5zaXR5IHZhbHVlIHdpbGwgYmUgaW4gdGhlIHJhbmdlIG9mIHZhbHVlTWluIHRvIHZhbHVlTWF4LlxuLy8gRm9yIG91ciBMdXRzIHZhbHVlTWluIHdpbGwgYWx3YXlzIGJlIDAsIGFuZCB2YWx1ZU1heCB3aWxsIGFsd2F5cyBiZSAyNTUuXG4vLyBvbGRNaW4gYW5kIG9sZE1heCB3aWxsIGJlIHRoZSBkb21haW4gb2YgdGhlIG9yaWdpbmFsIHJhdyBkYXRhIGludGVuc2l0aWVzLlxuLy8gbmV3TWluIGFuZCBuZXdNYXggd2lsbCBiZSB0aGUgZG9tYWluIG9mIHRoZSBuZXcgcmF3IGRhdGEgaW50ZW5zaXRpZXMuXG5mdW5jdGlvbiByZW1hcERvbWFpbkZvckNQKHZhbHVlLCB2YWx1ZU1pbiwgdmFsdWVNYXgsIG9sZE1pbiwgb2xkTWF4LCBuZXdNaW4sIG5ld01heCkge1xuICBjb25zdCBwY3RPZlJhbmdlID0gKHZhbHVlIC0gdmFsdWVNaW4pIC8gKHZhbHVlTWF4IC0gdmFsdWVNaW4pO1xuICAvLyBmaW5kIGFicyBpbnRlbnNpdHkgZnJvbSBvbGQgcmFuZ2VcbiAgY29uc3QgaU9sZCA9IChvbGRNYXggLSBvbGRNaW4pICogcGN0T2ZSYW5nZSArIG9sZE1pbjtcbiAgLy8gbm93IGxvY2F0ZSB0aGlzIHZhbHVlIGFzIGEgcmVsYXRpdmUgaW5kZXggaW4gdGhlIG5ldyByYW5nZVxuICBjb25zdCBwY3RPZk5ld1JhbmdlID0gKGlPbGQgLSBuZXdNaW4pIC8gKG5ld01heCAtIG5ld01pbik7XG4gIGNvbnN0IHJlbWFwcGVkID0gdmFsdWVNaW4gKyBwY3RPZk5ld1JhbmdlICogKHZhbHVlTWF4IC0gdmFsdWVNaW4pO1xuICByZXR1cm4gcmVtYXBwZWQ7XG59XG5leHBvcnQgY29uc3QgTFVUX0VOVFJJRVMgPSAyNTY7XG5leHBvcnQgY29uc3QgTFVUX0FSUkFZX0xFTkdUSCA9IExVVF9FTlRSSUVTICogNDtcblxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvbnRyb2xQb2ludCBVc2VkIGZvciB0aGUgVEYgKHRyYW5zZmVyIGZ1bmN0aW9uKSBlZGl0b3IgR1VJLlxyXG4gKiBOZWVkIHRvIGJlIGNvbnZlcnRlZCB0byBMVVQgZm9yIHJlbmRlcmluZy5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIFggQ29vcmRpbmF0ZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gb3BhY2l0eSBUaGUgT3BhY2l0eSwgZnJvbSAwIHRvIDFcclxuICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPn0gY29sb3IgVGhlIENvbG9yLCAzIG51bWJlcnMgZnJvbSAwLTI1NSBmb3IgcixnLGJcclxuICovXG5cbmZ1bmN0aW9uIGNvbnRyb2xQb2ludFRvUkdCQShjb250cm9sUG9pbnQpIHtcbiAgcmV0dXJuIFtjb250cm9sUG9pbnQuY29sb3JbMF0sIGNvbnRyb2xQb2ludC5jb2xvclsxXSwgY29udHJvbFBvaW50LmNvbG9yWzJdLCBNYXRoLmZsb29yKGNvbnRyb2xQb2ludC5vcGFjaXR5ICogMjU1KV07XG59XG5cbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMdXQgVXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fSBsdXQgTFVUX0FSUkFZX0xFTkdUSCBlbGVtZW50IGxvb2t1cCB0YWJsZSBhcyBhcnJheVxyXG4gKiAobWFwcyBzY2FsYXIgaW50ZW5zaXR5IHRvIGEgcmdiIGNvbG9yIHBsdXMgYWxwaGEsIHdpdGggZWFjaCB2YWx1ZSBmcm9tIDAtMjU1KVxyXG4gKiBAcHJvcGVydHkge0FycmF5LjxDb250cm9sUG9pbnQ+fSBjb250cm9sUG9pbnRzXHJcbiAqL1xuZXhwb3J0IGNsYXNzIEx1dCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubHV0ID0gbmV3IFVpbnQ4QXJyYXkoTFVUX0FSUkFZX0xFTkdUSCk7XG4gICAgdGhpcy5jb250cm9sUG9pbnRzID0gW107XG4gICAgdGhpcy5jcmVhdGVGdWxsUmFuZ2UoKTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGEgcGllY2V3aXNlIGxpbmVhciBsb29rdXAgdGFibGUgdGhhdCByYW1wcyB1cCBmcm9tIDAgdG8gMSBvdmVyIHRoZSBiIHRvIGUgZG9tYWluLlxyXG4gICAqIElmIGUgPT09IGIsIHRoZW4gd2UgdXNlIGEgc3RlcCBmdW5jdGlvbiB3aXRoIGYoYikgPSAwIGFuZCBmKGIgKyAxKSA9IDFcclxuICAgKiAgfFxyXG4gICAqIDF8ICAgICAgICAgICAgICAgKy0tLS0tLS0tLSstLS0tLVxyXG4gICAqICB8ICAgICAgICAgICAgICAvXHJcbiAgICogIHwgICAgICAgICAgICAgL1xyXG4gICAqICB8ICAgICAgICAgICAgL1xyXG4gICAqICB8ICAgICAgICAgICAvXHJcbiAgICogIHwgICAgICAgICAgL1xyXG4gICAqIDArPT09PT09PT09Ky0tLS0tLS0tLS0tLS0tLSstLS0tLVxyXG4gICAqICAwICAgICAgICAgYiAgICBlICAgICAgICAgMjU1XHJcbiAgICogQHJldHVybiB7THV0fVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVcclxuICAgKi9cbiAgY3JlYXRlRnJvbU1pbk1heChiLCBlKSB7XG4gICAgaWYgKGUgPCBiKSB7XG4gICAgICAvLyBzd2FwXG4gICAgICBjb25zdCB0bXAgPSBlO1xuICAgICAgZSA9IGI7XG4gICAgICBiID0gdG1wO1xuICAgIH1cbiAgICBjb25zdCBsdXQgPSBuZXcgVWludDhBcnJheShMVVRfQVJSQVlfTEVOR1RIKTtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGx1dC5sZW5ndGggLyA0OyArK3gpIHtcbiAgICAgIGx1dFt4ICogNCArIDBdID0gMjU1O1xuICAgICAgbHV0W3ggKiA0ICsgMV0gPSAyNTU7XG4gICAgICBsdXRbeCAqIDQgKyAyXSA9IDI1NTtcbiAgICAgIGlmICh4ID4gZSkge1xuICAgICAgICBsdXRbeCAqIDQgKyAzXSA9IDI1NTtcbiAgICAgIH0gZWxzZSBpZiAoeCA8PSBiKSB7XG4gICAgICAgIGx1dFt4ICogNCArIDNdID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlID09PSBiKSB7XG4gICAgICAgICAgbHV0W3ggKiA0ICsgM10gPSAyNTU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYSA9ICh4IC0gYikgLyAoZSAtIGIpO1xuICAgICAgICAgIGx1dFt4ICogNCArIDNdID0gbGVycCgwLCAyNTUsIGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRWRnZSBjYXNlOiBiIGFuZCBlIGFyZSBib3RoIG91dCBvZiBib3VuZHNcbiAgICBpZiAoYiA8IDAgJiYgZSA8IDApIHtcbiAgICAgIHRoaXMubHV0ID0gbHV0O1xuICAgICAgdGhpcy5jb250cm9sUG9pbnRzID0gW3tcbiAgICAgICAgeDogMCxcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1XVxuICAgICAgfSwge1xuICAgICAgICB4OiAyNTUsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGNvbG9yOiBbMjU1LCAyNTUsIDI1NV1cbiAgICAgIH1dO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChiID49IDI1NSAmJiBlID49IDI1NSkge1xuICAgICAgdGhpcy5sdXQgPSBsdXQ7XG4gICAgICB0aGlzLmNvbnRyb2xQb2ludHMgPSBbe1xuICAgICAgICB4OiAwLFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBjb2xvcjogWzI1NSwgMjU1LCAyNTVdXG4gICAgICB9LCB7XG4gICAgICAgIHg6IDI1NSxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1XVxuICAgICAgfV07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSAyIHRvIDQgY29udHJvbCBwb2ludHMgZm9yIGEgbWluTWF4IExVVCwgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgY29uc3QgY29udHJvbFBvaW50cyA9IFtdO1xuXG4gICAgLy8gQWRkIHN0YXJ0aW5nIHBvaW50IGF0IHggPSAwXG4gICAgbGV0IHN0YXJ0VmFsID0gMDtcbiAgICBpZiAoYiA8IDApIHtcbiAgICAgIHN0YXJ0VmFsID0gLWIgLyAoZSAtIGIpO1xuICAgIH1cbiAgICBjb250cm9sUG9pbnRzLnB1c2goe1xuICAgICAgeDogMCxcbiAgICAgIG9wYWNpdHk6IHN0YXJ0VmFsLFxuICAgICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1XVxuICAgIH0pO1xuXG4gICAgLy8gSWYgYiA+IDAsIGFkZCBhbm90aGVyIHBvaW50IGF0IChiLCAwKVxuICAgIGlmIChiID4gMCkge1xuICAgICAgY29udHJvbFBvaW50cy5wdXNoKHtcbiAgICAgICAgeDogYixcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1XVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSWYgZSA8IDI1NSwgQWRkIGFub3RoZXIgcG9pbnQgYXQgKGUsIDEpXG4gICAgaWYgKGUgPCAyNTUpIHtcbiAgICAgIGlmIChlID09PSBiKSB7XG4gICAgICAgIC8vIFVzZSBiICsgMC41IGFzIHggdmFsdWUgaW5zdGVhZCBvZiBlIHRvIGNyZWF0ZSBhIG5lYXItdmVydGljYWwgcmFtcFxuICAgICAgICBjb250cm9sUG9pbnRzLnB1c2goe1xuICAgICAgICAgIHg6IGIgKyAwLjUsXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICBjb2xvcjogWzI1NSwgMjU1LCAyNTVdXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbFBvaW50cy5wdXNoKHtcbiAgICAgICAgICB4OiBlLFxuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgZW5kaW5nIHBvaW50IGF0IHggPSAyNTVcbiAgICBsZXQgZW5kVmFsID0gMTtcbiAgICBpZiAoZSA+IDI1NSkge1xuICAgICAgZW5kVmFsID0gKDI1NSAtIGIpIC8gKGUgLSBiKTtcbiAgICB9XG4gICAgY29udHJvbFBvaW50cy5wdXNoKHtcbiAgICAgIHg6IDI1NSxcbiAgICAgIG9wYWNpdHk6IGVuZFZhbCxcbiAgICAgIGNvbG9yOiBbMjU1LCAyNTUsIDI1NV1cbiAgICB9KTtcbiAgICB0aGlzLmx1dCA9IGx1dDtcbiAgICB0aGlzLmNvbnRyb2xQb2ludHMgPSBjb250cm9sUG9pbnRzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gYmFzaWNhbGx5LCB0aGUgaWRlbnRpdHkgTFVUIHdpdGggcmVzcGVjdCB0byBvcGFjaXR5XG4gIGNyZWF0ZUZ1bGxSYW5nZSgpIHtcbiAgICBjb25zdCBsdXQgPSBuZXcgVWludDhBcnJheShMVVRfQVJSQVlfTEVOR1RIKTtcblxuICAgIC8vIHNpbXBsZSBsaW5lYXIgbWFwcGluZyBmb3IgYWN0dWFsIHJhbmdlXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCBsdXQubGVuZ3RoIC8gNDsgKyt4KSB7XG4gICAgICBsdXRbeCAqIDQgKyAwXSA9IDI1NTtcbiAgICAgIGx1dFt4ICogNCArIDFdID0gMjU1O1xuICAgICAgbHV0W3ggKiA0ICsgMl0gPSAyNTU7XG4gICAgICBsdXRbeCAqIDQgKyAzXSA9IHg7XG4gICAgfVxuICAgIHRoaXMubHV0ID0gbHV0O1xuICAgIHRoaXMuY29udHJvbFBvaW50cyA9IFt7XG4gICAgICB4OiAwLFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIGNvbG9yOiBbMjU1LCAyNTUsIDI1NV1cbiAgICB9LCB7XG4gICAgICB4OiAyNTUsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1XVxuICAgIH1dO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYSBXaW5kb3cvbGV2ZWwgbG9va3VwIHRhYmxlXHJcbiAgICogQHJldHVybiB7THV0fVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3bmQgaW4gMC4uMSByYW5nZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsdmwgaW4gMC4uMSByYW5nZVxyXG4gICAqL1xuICBjcmVhdGVGcm9tV2luZG93TGV2ZWwod25kLCBsdmwpIHtcbiAgICAvLyBzaW1wbGUgbGluZWFyIG1hcHBpbmcgZm9yIGFjdHVhbCByYW5nZVxuICAgIGNvbnN0IGIgPSBsdmwgLSB3bmQgKiAwLjU7XG4gICAgY29uc3QgZSA9IGx2bCArIHduZCAqIDAuNTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVGcm9tTWluTWF4KGIgKiAyNTUsIGUgKiAyNTUpO1xuICB9XG5cbiAgLy8gQHBhcmFtIHtPYmplY3RbXX0gY29udHJvbFBvaW50cyAtIGFycmF5IG9mIHt4Om51bWJlciAwLi4yNTUsIG9wYWNpdHk6bnVtYmVyIDAuLjEsIGNvbG9yOmFycmF5IG9mIDMgbnVtYmVycyAwLi4yNTV9XG4gIC8vIEByZXR1cm4ge1VpbnQ4QXJyYXl9IGFycmF5IG9mIGxlbmd0aCAyNTYqNCByZXByZXNlbnRpbmcgdGhlIHJnYmEgdmFsdWVzIG9mIHRoZSBncmFkaWVudFxuICBjcmVhdGVGcm9tQ29udHJvbFBvaW50cyhjb250cm9sUG9pbnRzKSB7XG4gICAgY29uc3QgbHV0ID0gbmV3IFVpbnQ4QXJyYXkoTFVUX0FSUkFZX0xFTkdUSCkuZmlsbCgwKTtcbiAgICBpZiAoY29udHJvbFBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMubHV0ID0gbHV0O1xuICAgICAgdGhpcy5jb250cm9sUG9pbnRzID0gY29udHJvbFBvaW50cztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSB0aGV5IGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIG9mIHhcbiAgICBjb250cm9sUG9pbnRzLnNvcnQoKGEsIGIpID0+IGEueCAtIGIueCk7XG5cbiAgICAvLyBzcGVjaWFsIGNhc2Ugb25seSBvbmUgY29udHJvbCBwb2ludC5cbiAgICBpZiAoY29udHJvbFBvaW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IHJnYmEgPSBjb250cm9sUG9pbnRUb1JHQkEoY29udHJvbFBvaW50c1swXSk7XG4gICAgICAvLyBsdXQgd2FzIGFscmVhZHkgZmlsbGVkIHdpdGggemVyb3NcbiAgICAgIC8vIGNvcHkgdmFsIGZyb20geCB0byAyNTUuXG4gICAgICBjb25zdCBzdGFydHggPSBjbGFtcChjb250cm9sUG9pbnRzWzBdLngsIDAsIDI1NSk7XG4gICAgICBmb3IgKGxldCB4ID0gc3RhcnR4OyB4IDwgMjU2OyArK3gpIHtcbiAgICAgICAgbHV0W3ggKiA0ICsgMF0gPSByZ2JhWzBdO1xuICAgICAgICBsdXRbeCAqIDQgKyAxXSA9IHJnYmFbMV07XG4gICAgICAgIGx1dFt4ICogNCArIDJdID0gcmdiYVsyXTtcbiAgICAgICAgbHV0W3ggKiA0ICsgM10gPSByZ2JhWzNdO1xuICAgICAgfVxuICAgICAgdGhpcy5sdXQgPSBsdXQ7XG4gICAgICB0aGlzLmNvbnRyb2xQb2ludHMgPSBjb250cm9sUG9pbnRzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxldCBjMCA9IGNvbnRyb2xQb2ludHNbMF07XG4gICAgbGV0IGMxID0gY29udHJvbFBvaW50c1sxXTtcbiAgICBsZXQgY29sb3IwID0gY29udHJvbFBvaW50VG9SR0JBKGMwKTtcbiAgICBsZXQgY29sb3IxID0gY29udHJvbFBvaW50VG9SR0JBKGMxKTtcbiAgICBsZXQgbGFzdEluZGV4ID0gMTtcbiAgICBsZXQgYSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgLy8gZmluZCB0aGUgdHdvIGNvbnRyb2wgcG9pbnRzIHRoYXQgaSBpcyBiZXR3ZWVuXG4gICAgICB3aGlsZSAoaSA+IGMxLngpIHtcbiAgICAgICAgLy8gYWR2YW5jZSBjb250cm9sIHBvaW50c1xuICAgICAgICBjMCA9IGMxO1xuICAgICAgICBjb2xvcjAgPSBjb2xvcjE7XG4gICAgICAgIGxhc3RJbmRleCsrO1xuICAgICAgICBpZiAobGFzdEluZGV4ID49IGNvbnRyb2xQb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGxhc3QgY29udHJvbCBwb2ludCBpcyBiZWZvcmUgMjU1LCB0aGVuIHdlIHdhbnQgdG8gY29udGludWUgaXRzIHZhbHVlIGFsbCB0aGUgd2F5IHRvIDI1NS5cbiAgICAgICAgICBjMSA9IHtcbiAgICAgICAgICAgIHg6IDI1NSxcbiAgICAgICAgICAgIGNvbG9yOiBjMS5jb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHk6IGMxLm9wYWNpdHlcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGMxID0gY29udHJvbFBvaW50c1tsYXN0SW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGNvbG9yMSA9IGNvbnRyb2xQb2ludFRvUkdCQShjMSk7XG4gICAgICB9XG4gICAgICAvLyBmaW5kIHRoZSBsZXJwIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gY29udHJvbCBwb2ludHNcbiAgICAgIGlmIChjMS54ID09PSBjMC54KSB7XG4gICAgICAgIC8vIHVzZSBjMVxuICAgICAgICBhID0gMS4wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYSA9IChpIC0gYzAueCkgLyAoYzEueCAtIGMwLngpO1xuICAgICAgfVxuICAgICAgbHV0W2kgKiA0ICsgMF0gPSBjbGFtcChsZXJwKGNvbG9yMFswXSwgY29sb3IxWzBdLCBhKSwgMCwgMjU1KTtcbiAgICAgIGx1dFtpICogNCArIDFdID0gY2xhbXAobGVycChjb2xvcjBbMV0sIGNvbG9yMVsxXSwgYSksIDAsIDI1NSk7XG4gICAgICBsdXRbaSAqIDQgKyAyXSA9IGNsYW1wKGxlcnAoY29sb3IwWzJdLCBjb2xvcjFbMl0sIGEpLCAwLCAyNTUpO1xuICAgICAgbHV0W2kgKiA0ICsgM10gPSBjbGFtcChsZXJwKGNvbG9yMFszXSwgY29sb3IxWzNdLCBhKSwgMCwgMjU1KTtcbiAgICB9XG4gICAgdGhpcy5sdXQgPSBsdXQ7XG4gICAgdGhpcy5jb250cm9sUG9pbnRzID0gY29udHJvbFBvaW50cztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGFuIFwiZXF1YWxpemVkXCIgbG9va3VwIHRhYmxlXHJcbiAgICogQHJldHVybiB7THV0fVxyXG4gICAqL1xuICBjcmVhdGVGcm9tRXFIaXN0b2dyYW0oaGlzdG9ncmFtKSB7XG4gICAgY29uc3QgbWFwID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoaXN0b2dyYW0uZ2V0TnVtQmlucygpOyArK2kpIHtcbiAgICAgIG1hcFtpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gc3VtbWVkIGFyZWEgdGFibGU/XG4gICAgbWFwWzBdID0gaGlzdG9ncmFtLmdldEJpbigwKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhpc3RvZ3JhbS5nZXROdW1CaW5zKCk7ICsraSkge1xuICAgICAgbWFwW2ldID0gbWFwW2kgLSAxXSArIGhpc3RvZ3JhbS5nZXRCaW4oaSk7XG4gICAgfVxuICAgIGNvbnN0IGRpdiA9IG1hcFttYXAubGVuZ3RoIC0gMV0gLSBtYXBbMF07XG4gICAgaWYgKGRpdiA+IDApIHtcbiAgICAgIGNvbnN0IGx1dCA9IG5ldyBVaW50OEFycmF5KExVVF9BUlJBWV9MRU5HVEgpO1xuXG4gICAgICAvLyBjb21wdXRlIGx1dCBhbmQgdHJhY2sgY29udHJvbCBwb2ludHMgZm9yIHRoZSBwaWVjZXdpc2UgbGluZWFyIHNlY3Rpb25zXG4gICAgICBjb25zdCBsdXRDb250cm9sUG9pbnRzID0gW3tcbiAgICAgICAgeDogMCxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1XVxuICAgICAgfV07XG4gICAgICBsdXRbMF0gPSAyNTU7XG4gICAgICBsdXRbMV0gPSAyNTU7XG4gICAgICBsdXRbMl0gPSAyNTU7XG4gICAgICBsdXRbM10gPSAwO1xuICAgICAgbGV0IHNsb3BlID0gMDtcbiAgICAgIGxldCBsYXN0U2xvcGUgPSAwO1xuICAgICAgbGV0IG9wYWNpdHkgPSAwO1xuICAgICAgbGV0IGxhc3RPcGFjaXR5ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbHV0Lmxlbmd0aCAvIDQ7ICsraSkge1xuICAgICAgICBsdXRbaSAqIDQgKyAwXSA9IDI1NTtcbiAgICAgICAgbHV0W2kgKiA0ICsgMV0gPSAyNTU7XG4gICAgICAgIGx1dFtpICogNCArIDJdID0gMjU1O1xuICAgICAgICBsYXN0T3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgIG9wYWNpdHkgPSBjbGFtcChNYXRoLnJvdW5kKDI1NSAqIChtYXBbaV0gLSBtYXBbMF0pKSwgMCwgMjU1KTtcbiAgICAgICAgbHV0W2kgKiA0ICsgM10gPSBvcGFjaXR5O1xuICAgICAgICBzbG9wZSA9IG9wYWNpdHkgLSBsYXN0T3BhY2l0eTtcbiAgICAgICAgLy8gaWYgbWFwW2ldLW1hcFtpLTFdIGlzIHRoZSBzYW1lIGFzIG1hcFtpKzFdLW1hcFtpXSB0aGVuIHdlIGFyZSBpbiBhIGxpbmVhciBzZWdtZW50IGFuZCBkbyBub3QgbmVlZCBhIG5ldyBjb250cm9sIHBvaW50XG4gICAgICAgIGlmIChzbG9wZSAhPSBsYXN0U2xvcGUpIHtcbiAgICAgICAgICBsdXRDb250cm9sUG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgeDogaSAtIDEsXG4gICAgICAgICAgICBvcGFjaXR5OiBsYXN0T3BhY2l0eSAvIDI1NS4wLFxuICAgICAgICAgICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1XVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxhc3RTbG9wZSA9IHNsb3BlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsdXRDb250cm9sUG9pbnRzLnB1c2goe1xuICAgICAgICB4OiAyNTUsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGNvbG9yOiBbMjU1LCAyNTUsIDI1NV1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5sdXQgPSBsdXQ7XG4gICAgICB0aGlzLmNvbnRyb2xQb2ludHMgPSBsdXRDb250cm9sUG9pbnRzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGp1c3QgcmVzZXQgdG8gd2hvbGUgcmFuZ2UgaW4gdGhpcyBjYXNlLi4uP1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRnVsbFJhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYSBsb29rdXAgdGFibGUgd2l0aCBhIGRpZmZlcmVudCBjb2xvciBwZXIgaW50ZW5zaXR5IHZhbHVlLlxyXG4gICAqIFRoaXMgdHJhbnNsYXRlcyB0byBhIHVuaXF1ZSBjb2xvciBwZXIgaGlzdG9ncmFtIGJpbiB3aXRoIG1vcmUgdGhhbiB6ZXJvIHBpeGVscy5cclxuICAgKiBAcmV0dXJuIHtMdXR9XHJcbiAgICovXG4gIGNyZWF0ZUxhYmVsQ29sb3JzKGhpc3RvZ3JhbSkge1xuICAgIGNvbnN0IGx1dCA9IG5ldyBVaW50OEFycmF5KExVVF9BUlJBWV9MRU5HVEgpLmZpbGwoMCk7XG4gICAgY29uc3QgY29udHJvbFBvaW50cyA9IFtdO1xuICAgIGNvbnRyb2xQb2ludHMucHVzaCh7XG4gICAgICB4OiAwLFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIGNvbG9yOiBbMCwgMCwgMF1cbiAgICB9KTtcbiAgICBsZXQgbGFzdHIgPSAwO1xuICAgIGxldCBsYXN0ZyA9IDA7XG4gICAgbGV0IGxhc3RiID0gMDtcbiAgICBsZXQgbGFzdGEgPSAwO1xuICAgIGxldCByID0gMDtcbiAgICBsZXQgZyA9IDA7XG4gICAgbGV0IGIgPSAwO1xuICAgIGxldCBhID0gMDtcblxuICAgIC8vIGFzc3VtZXMgZXhhY3RseSBvbmUgYmluIHBlciBpbnRlbnNpdHkgdmFsdWU/XG4gICAgLy8gc2tpcCB6ZXJvISEhXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBoaXN0b2dyYW0uZ2V0TnVtQmlucygpOyArK2kpIHtcbiAgICAgIGlmIChoaXN0b2dyYW0uZ2V0QmluKGkpID4gMCkge1xuICAgICAgICBjb25zdCByZ2IgPSBnZXRDb2xvckJ5Q2hhbm5lbEluZGV4KGkpO1xuICAgICAgICBsdXRbaSAqIDQgKyAwXSA9IHJnYlswXTtcbiAgICAgICAgbHV0W2kgKiA0ICsgMV0gPSByZ2JbMV07XG4gICAgICAgIGx1dFtpICogNCArIDJdID0gcmdiWzJdO1xuICAgICAgICBsdXRbaSAqIDQgKyAzXSA9IDI1NTtcbiAgICAgICAgciA9IHJnYlswXTtcbiAgICAgICAgZyA9IHJnYlsxXTtcbiAgICAgICAgYiA9IHJnYlsyXTtcbiAgICAgICAgYSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhZGQgYSB6ZXJvIGNvbnRyb2wgcG9pbnQ/XG4gICAgICAgIHIgPSAwO1xuICAgICAgICBnID0gMDtcbiAgICAgICAgYiA9IDA7XG4gICAgICAgIGEgPSAwO1xuICAgICAgfVxuICAgICAgLy8gaWYgY3VycmVudCBjb250cm9sIHBvaW50IGlzIHNhbWUgYXMgbGFzdCBvbmUgZG9uJ3QgYWRkIGl0XG4gICAgICBpZiAociAhPT0gbGFzdHIgfHwgZyAhPT0gbGFzdGcgfHwgYiAhPT0gbGFzdGIgfHwgYSAhPT0gbGFzdGEpIHtcbiAgICAgICAgaWYgKGxhc3RhID09PSAwKSB7XG4gICAgICAgICAgY29udHJvbFBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgIHg6IGkgLSAwLjUsXG4gICAgICAgICAgICBvcGFjaXR5OiBsYXN0YSxcbiAgICAgICAgICAgIGNvbG9yOiBbbGFzdHIsIGxhc3RnLCBsYXN0Yl1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sUG9pbnRzLnB1c2goe1xuICAgICAgICAgIHg6IGksXG4gICAgICAgICAgb3BhY2l0eTogYSxcbiAgICAgICAgICBjb2xvcjogW3IsIGcsIGJdXG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0ciA9IHI7XG4gICAgICAgIGxhc3RnID0gZztcbiAgICAgICAgbGFzdGIgPSBiO1xuICAgICAgICBsYXN0YSA9IGE7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubHV0ID0gbHV0O1xuICAgIHRoaXMuY29udHJvbFBvaW50cyA9IGNvbnRyb2xQb2ludHM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzaW5jZSB0aGlzIGlzIG5vdCBhIFwiY3JlYXRlXCIgZnVuY3Rpb24sIGl0IGRvZXNuJ3QgbmVlZCB0byByZXR1cm4gdGhlIG9iamVjdC5cbiAgcmVtYXBEb21haW5zKG9sZE1pbiwgb2xkTWF4LCBuZXdNaW4sIG5ld01heCkge1xuICAgIC8vIG5vIGF0dGVtcHQgaXMgbWFkZSBoZXJlIHRvIGVuc3VyZSB0aGF0IGx1dCBhbmQgY29udHJvbFBvaW50cyBhcmUgaW50ZXJuYWxseSBjb25zaXN0ZW50LlxuICAgIC8vIGlmIHRoZXkgc3RhcnQgb3V0IGNvbnNpc3RlbnQsIHRoZXkgc2hvdWxkIGVuZCB1cCBjb25zaXN0ZW50LiBBbmQgdmljZSB2ZXJzYS5cbiAgICB0aGlzLmx1dCA9IHJlbWFwTHV0KHRoaXMubHV0LCBvbGRNaW4sIG9sZE1heCwgbmV3TWluLCBuZXdNYXgpO1xuICAgIHRoaXMuY29udHJvbFBvaW50cyA9IHJlbWFwQ29udHJvbFBvaW50cyh0aGlzLmNvbnRyb2xQb2ludHMsIG9sZE1pbiwgb2xkTWF4LCBuZXdNaW4sIG5ld01heCk7XG4gIH1cbn1cblxuLy8gSWYgdGhlIG5ldyBtYXggaXMgZ3JlYXRlciB0aGFuIHRoZSBvbGQgbWF4LCB0aGVuXG4vLyB0aGUgbHV0J3MgbWF4IGVuZCB3aWxsIG1vdmUgaW53YXJkIHRvIHRoZSBsZWZ0LlxuLy8gVGhpcyBpcyBhbm90aGVyIHdheSBvZiBzYXlpbmcgdGhhdCB0aGUgbmV3IG1heCdzIGluZGV4IGlzIGdyZWF0ZXIgdGhhbiAyNTUgaW4gdGhlIG9sZCBsdXRcbi8vIElmIHRoZSBuZXcgbWluIGlzIGxlc3MgdGhhbiB0aGUgb2xkIG1pbiwgdGhlblxuLy8gdGhlIGx1dCdzIG1pbiBlbmQgd2lsbCBtb3ZlIGlud2FyZCB0byB0aGUgcmlnaHQuXG4vLyBUaGlzIGlzIGFub3RoZXIgd2F5IG9mIHNheWluZyB0aGF0IHRoZSBuZXcgbWluJ3MgaW5kZXggaXMgbGVzcyB0aGFuIDAgaW4gdGhlIG9sZCBsdXRcbmV4cG9ydCBmdW5jdGlvbiByZW1hcEx1dChsdXQsIG9sZE1pbiwgb2xkTWF4LCBuZXdNaW4sIG5ld01heCkge1xuICBjb25zdCBuZXdMdXQgPSBuZXcgVWludDhBcnJheShMVVRfQVJSQVlfTEVOR1RIKTtcblxuICAvLyB3ZSB3aWxsIGZpbmQgd2hhdCBpbnRlbnNpdHkgaXMgYXQgZWFjaCBpbmRleCBpbiB0aGUgbmV3IHJhbmdlLFxuICAvLyBhbmQgdGhlbiB0cnkgdG8gc2FtcGxlIHRoZSBwcmUtZXhpc3RpbmcgbHV0IGFzIGlmIGl0IHNwYW5zIHRoZSBvbGQgcmFuZ2UuXG4gIC8vIEJ1aWxkIG5ldyBsdXQgYnkgc2FtcGxpbmcgZnJvbSBvbGQgbHV0LlxuICBmb3IgKGxldCBpID0gMDsgaSA8IExVVF9FTlRSSUVTOyArK2kpIHtcbiAgICBsZXQgaU9sZCA9IHJlbWFwRG9tYWluKGksIDAsIExVVF9FTlRSSUVTIC0gMSwgb2xkTWluLCBvbGRNYXgsIG5ld01pbiwgbmV3TWF4KTtcbiAgICBpZiAoaU9sZCA8IDApIHtcbiAgICAgIGlPbGQgPSAwO1xuICAgIH1cbiAgICBpZiAoaU9sZCA+IExVVF9FTlRSSUVTIC0gMSkge1xuICAgICAgaU9sZCA9IExVVF9FTlRSSUVTIC0gMTtcbiAgICB9XG4gICAgLy8gZmluZCB0aGUgaW5kaWNlcyBhYm92ZSBhbmQgYmVsb3cgZm9yIGludGVycG9sYXRpb25cbiAgICBjb25zdCBpMCA9IE1hdGguZmxvb3IoaU9sZCk7XG4gICAgY29uc3QgaTEgPSBNYXRoLmNlaWwoaU9sZCk7XG4gICAgY29uc3QgcGN0ID0gaU9sZCAtIGkwO1xuXG4gICAgLy9jb25zb2xlLmxvZyhgaW50ZXJwb2xhdGluZyAke2lPbGR9OiAke2x1dFtpMCAqIDQgKyAzXX0sICR7bHV0W2kxICogNCArIDNdfSwgJHtwY3R9YCk7XG4gICAgbmV3THV0W2kgKiA0ICsgMF0gPSBNYXRoLnJvdW5kKGxlcnAobHV0W2kwICogNCArIDBdLCBsdXRbaTEgKiA0ICsgMF0sIHBjdCkpO1xuICAgIG5ld0x1dFtpICogNCArIDFdID0gTWF0aC5yb3VuZChsZXJwKGx1dFtpMCAqIDQgKyAxXSwgbHV0W2kxICogNCArIDFdLCBwY3QpKTtcbiAgICBuZXdMdXRbaSAqIDQgKyAyXSA9IE1hdGgucm91bmQobGVycChsdXRbaTAgKiA0ICsgMl0sIGx1dFtpMSAqIDQgKyAyXSwgcGN0KSk7XG4gICAgbmV3THV0W2kgKiA0ICsgM10gPSBNYXRoLnJvdW5kKGxlcnAobHV0W2kwICogNCArIDNdLCBsdXRbaTEgKiA0ICsgM10sIHBjdCkpO1xuICB9XG4gIHJldHVybiBuZXdMdXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVtYXBDb250cm9sUG9pbnRzKGNvbnRyb2xQb2ludHMsIG9sZE1pbiwgb2xkTWF4LCBuZXdNaW4sIG5ld01heCkge1xuICBjb25zdCBuZXdDb250cm9sUG9pbnRzID0gW107XG5cbiAgLy8gYXNzdW1lIGNvbnRyb2wgcG9pbnQgeCBkb21haW4gMC0yNTUgaXMgbWFwcGVkIHRvIG9sZE1pbi1vbGRNYXhcblxuICAvLyByZW1hcCBhbGwgY3AgeCB2YWx1ZXMuXG4gIC8vIGludGVycG9sYXRlIGFsbCBuZXcgY29sb3JzIGFuZCBvcGFjaXRpZXNcbiAgLy8gRG8gbm90IGNsaXAgdmFsdWVzIG91dHNpZGUgb2YgMC0yNTUuIFRoaXMgaXMgaW1wb3J0YW50IHRvXG4gIC8vIHByZXNlcnZlIGluZm9ybWF0aW9uIGZvciByZW1hcHBpbmcgbWFueSBjb25zZWN1dGl2ZSB0aW1lcy5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250cm9sUG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY3AgPSBjb250cm9sUG9pbnRzW2ldO1xuICAgIGNvbnN0IGlPbGQgPSByZW1hcERvbWFpbkZvckNQKGNwLngsIDAsIExVVF9FTlRSSUVTIC0gMSwgb2xkTWluLCBvbGRNYXgsIG5ld01pbiwgbmV3TWF4KTtcbiAgICBjb25zdCBuZXdDUCA9IHtcbiAgICAgIHg6IGlPbGQsXG4gICAgICBvcGFjaXR5OiBjcC5vcGFjaXR5LFxuICAgICAgY29sb3I6IFtjcC5jb2xvclswXSwgY3AuY29sb3JbMV0sIGNwLmNvbG9yWzJdXVxuICAgIH07XG4gICAgbmV3Q29udHJvbFBvaW50cy5wdXNoKG5ld0NQKTtcbiAgfVxuICByZXR1cm4gbmV3Q29udHJvbFBvaW50cztcbn0iXSwibmFtZXMiOlsiZ2V0Q29sb3JCeUNoYW5uZWxJbmRleCIsImNsYW1wIiwidmFsIiwiY21pbiIsImNtYXgiLCJNYXRoIiwibWluIiwibWF4IiwibGVycCIsInhtaW4iLCJ4bWF4IiwiYSIsInJlbWFwRG9tYWluIiwidmFsdWUiLCJ2YWx1ZU1pbiIsInZhbHVlTWF4Iiwib2xkTWluIiwib2xkTWF4IiwibmV3TWluIiwibmV3TWF4IiwicGN0T2ZSYW5nZSIsIm5ld1ZhbHVlIiwicGN0T2ZPbGRSYW5nZSIsInJlbWFwcGVkIiwicmVtYXBEb21haW5Gb3JDUCIsImlPbGQiLCJwY3RPZk5ld1JhbmdlIiwiTFVUX0VOVFJJRVMiLCJMVVRfQVJSQVlfTEVOR1RIIiwiY29udHJvbFBvaW50VG9SR0JBIiwiY29udHJvbFBvaW50IiwiY29sb3IiLCJmbG9vciIsIm9wYWNpdHkiLCJMdXQiLCJjb25zdHJ1Y3RvciIsImx1dCIsIlVpbnQ4QXJyYXkiLCJjb250cm9sUG9pbnRzIiwiY3JlYXRlRnVsbFJhbmdlIiwiY3JlYXRlRnJvbU1pbk1heCIsImIiLCJlIiwidG1wIiwieCIsImxlbmd0aCIsInN0YXJ0VmFsIiwicHVzaCIsImVuZFZhbCIsImNyZWF0ZUZyb21XaW5kb3dMZXZlbCIsInduZCIsImx2bCIsImNyZWF0ZUZyb21Db250cm9sUG9pbnRzIiwiZmlsbCIsInNvcnQiLCJyZ2JhIiwic3RhcnR4IiwiYzAiLCJjMSIsImNvbG9yMCIsImNvbG9yMSIsImxhc3RJbmRleCIsImkiLCJjcmVhdGVGcm9tRXFIaXN0b2dyYW0iLCJoaXN0b2dyYW0iLCJtYXAiLCJnZXROdW1CaW5zIiwiZ2V0QmluIiwiZGl2IiwibHV0Q29udHJvbFBvaW50cyIsInNsb3BlIiwibGFzdFNsb3BlIiwibGFzdE9wYWNpdHkiLCJyb3VuZCIsImNyZWF0ZUxhYmVsQ29sb3JzIiwibGFzdHIiLCJsYXN0ZyIsImxhc3RiIiwibGFzdGEiLCJyIiwiZyIsInJnYiIsInJlbWFwRG9tYWlucyIsInJlbWFwTHV0IiwicmVtYXBDb250cm9sUG9pbnRzIiwibmV3THV0IiwiaTAiLCJpMSIsImNlaWwiLCJwY3QiLCJuZXdDb250cm9sUG9pbnRzIiwiY3AiLCJuZXdDUCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../volume-viewer/es/Lut.js\n");

/***/ }),

/***/ "../volume-viewer/es/Volume.js":
/*!*************************************!*\
  !*** ../volume-viewer/es/Volume.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Volume),\n/* harmony export */   getDefaultImageInfo: () => (/* binding */ getDefaultImageInfo)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"../volume-viewer/node_modules/three/build/three.module.js\");\n/* harmony import */ var _Channel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Channel.js */ \"../volume-viewer/es/Channel.js\");\n/* harmony import */ var _constants_colors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants/colors.js */ \"../volume-viewer/es/constants/colors.js\");\n/* harmony import */ var _loaders_IVolumeLoader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loaders/IVolumeLoader.js */ \"../volume-viewer/es/loaders/IVolumeLoader.js\");\n/* harmony import */ var _loaders_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loaders/VolumeLoaderUtils.js */ \"../volume-viewer/es/loaders/VolumeLoaderUtils.js\");\n\n\n\n\n\nconst getDefaultImageInfo = () => ({\n  name: \"\",\n  originalSize: new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(1, 1, 1),\n  atlasTileDims: new three__WEBPACK_IMPORTED_MODULE_4__.Vector2(1, 1),\n  volumeSize: new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(1, 1, 1),\n  subregionSize: new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(1, 1, 1),\n  subregionOffset: new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0),\n  physicalPixelSize: new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(1, 1, 1),\n  spatialUnit: \"\",\n  numChannels: 0,\n  channelNames: [],\n  channelColors: [],\n  times: 1,\n  timeScale: 1,\n  timeUnit: \"\",\n  numMultiscaleLevels: 1,\n  multiscaleLevel: 0,\n  transform: {\n    translation: new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0),\n    rotation: new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0)\n  }\n});\n/**\r\n * Provide dimensions of the volume data, including dimensions for texture atlas data in which the volume z slices\r\n * are tiled across a single large 2d image plane.\r\n * @typedef {Object} ImageInfo\r\n * @property {string} name Base name of image\r\n * @property {string} [version] Schema version preferably in semver format.\r\n * @property {Vector2} originalSize XY size of the *original* (not downsampled) volume, in pixels\r\n * @property {Vector2} atlasDims Number of rows and columns of z-slice tiles (not pixels) in the texture atlas\r\n * @property {Vector3} volumeSize Size of the volume, in pixels\r\n * @property {Vector3} regionSize Size of the currently loaded subregion, in pixels\r\n * @property {Vector3} regionOffset Offset of the loaded subregion into the total volume, in pixels\r\n * @property {Vector3} pixelSize Size of a single *original* (not downsampled) pixel, in spatial units\r\n * @property {string} spatialUnit Symbol of physical spatial unit used by `pixelSize`\r\n * @property {number} numChannels Number of channels\r\n * @property {Array.<string>} channelNames Names of each of the channels to be rendered, in order. Unique identifier expected\r\n * @property {Array.<Array.<number>>} [channelColors] Colors of each of the channels to be rendered, as an ordered list of [r, g, b] arrays\r\n * @property {number} times Number of times (default = 1)\r\n * @property {number} timeScale Size of each time step in `timeUnit` units\r\n * @property {number} timeUnit Unit symbol for `timeScale` (e.g. min)\r\n * @property {Object} transform translation and rotation as arrays of 3 numbers. Translation is in voxels (to be multiplied by pixel_size values). Rotation is Euler angles in radians, appled in XYZ order.\r\n * @property {Object} userData Arbitrary metadata not covered by above properties\r\n * @example const imgdata = {\r\n  \"name\": \"AICS-10_5_5\",\r\n  \"version\": \"0.0.0\",\r\n  originalSize: new Vector2(306, 494),\r\n  atlasDims: new Vector2(10, 7),\r\n  volumeSize: new Vector3(204, 292, 65),\r\n  regionSize: new Vector3(204, 292, 65),\r\n  regionOffset: new Vector3(0, 0, 0),\r\n  pixelSize: new Vector3(0.065, 0.065, 0.29),\r\n  spatialUnit: \"m\",\r\n  \"numChannels\": 9,\r\n  \"channelNames\": [\"DRAQ5\", \"EGFP\", \"Hoechst 33258\", \"TL Brightfield\", \"SEG_STRUCT\", \"SEG_Memb\", \"SEG_DNA\", \"CON_Memb\", \"CON_DNA\"],\r\n  \"times\": 5,\r\n  \"timeScale\": 1,\r\n  \"timeUnit\": \"hr\",\r\n  \"transform\": {\r\n    \"translation\": new Vector3(5, 5, 1),\r\n    \"rotation\": new Vector3(0, 3.14159, 1.57),\r\n  },\r\n  };\r\n */\n\n/**\r\n * A renderable multichannel volume image with 8-bits per channel intensity values.\r\n * @class\r\n * @param {ImageInfo} imageInfo\r\n */\nclass Volume {\n  // `LoadSpec` representing the minimum data required to display what's in the viewer (subregion, channels, etc.).\n  // Used to intelligently issue load requests whenever required by a state change. Modify with `updateRequiredData`.\n\n  constructor(imageInfo = getDefaultImageInfo(), loadSpec = new _loaders_IVolumeLoader_js__WEBPACK_IMPORTED_MODULE_2__.LoadSpec(), loader) {\n    this.loaded = false;\n    this.imageInfo = imageInfo;\n    this.name = this.imageInfo.name;\n    this.loadSpec = {\n      // Fill in defaults for optional properties\n      multiscaleLevel: 0,\n      scaleLevelBias: 0,\n      maxAtlasEdge: _loaders_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_3__.MAX_ATLAS_EDGE,\n      channels: Array.from({\n        length: this.imageInfo.numChannels\n      }, (_val, idx) => idx),\n      ...loadSpec\n    };\n    this.loadSpecRequired = {\n      ...this.loadSpec,\n      channels: this.loadSpec.channels.slice(),\n      subregion: this.loadSpec.subregion.clone()\n    };\n    this.loader = loader;\n    // imageMetadata to be filled in by Volume Loaders\n    this.imageMetadata = {};\n    this.normRegionSize = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(1, 1, 1);\n    this.normRegionOffset = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0);\n    this.physicalSize = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(1, 1, 1);\n    this.physicalScale = 1;\n    this.normPhysicalSize = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(1, 1, 1);\n    this.physicalPixelSize = this.imageInfo.physicalPixelSize;\n    this.tickMarkPhysicalLength = 1;\n    this.setVoxelSize(this.physicalPixelSize);\n    this.numChannels = this.imageInfo.numChannels;\n    this.channelNames = this.imageInfo.channelNames.slice();\n    this.channelColorsDefault = this.imageInfo.channelColors ? this.imageInfo.channelColors.slice() : this.channelNames.map((name, index) => (0,_constants_colors_js__WEBPACK_IMPORTED_MODULE_1__.getColorByChannelIndex)(index));\n    // fill in gaps\n    if (this.channelColorsDefault.length < this.imageInfo.numChannels) {\n      for (let i = this.channelColorsDefault.length - 1; i < this.imageInfo.numChannels; ++i) {\n        this.channelColorsDefault[i] = (0,_constants_colors_js__WEBPACK_IMPORTED_MODULE_1__.getColorByChannelIndex)(i);\n      }\n    }\n    this.channels = [];\n    for (let i = 0; i < this.imageInfo.numChannels; ++i) {\n      const channel = new _Channel_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.channelNames[i]);\n      this.channels.push(channel);\n      // TODO pass in channel constructor...\n      channel.dims = this.imageInfo.subregionSize.toArray();\n    }\n    this.physicalUnitSymbol = this.imageInfo.spatialUnit;\n    this.volumeDataObservers = [];\n  }\n  setUnloaded() {\n    this.loaded = false;\n    this.channels.forEach(channel => {\n      channel.loaded = false;\n    });\n  }\n  isLoaded() {\n    return this.loaded;\n  }\n  updateDimensions() {\n    const {\n      volumeSize,\n      subregionSize,\n      subregionOffset\n    } = this.imageInfo;\n    this.setVoxelSize(this.physicalPixelSize);\n    this.normRegionSize = subregionSize.clone().divide(volumeSize);\n    this.normRegionOffset = subregionOffset.clone().divide(volumeSize);\n  }\n\n  /** Returns `true` iff differences between `loadSpec` and `loadSpecRequired` indicate new data *must* be loaded. */\n  mustLoadNewData() {\n    return this.loadSpec.time !== this.loadSpecRequired.time ||\n    // time point changed\n    !this.loadSpec.subregion.containsBox(this.loadSpecRequired.subregion) ||\n    // new subregion not contained in old\n    this.loadSpecRequired.channels.some(channel => !this.loadSpec.channels.includes(channel)) // new channel(s)\n    ;\n  }\n\n  /**\r\n   * Returns `true` iff differences between `loadSpec` and `loadSpecRequired` indicate a new load *may* get a\r\n   * different scale level than is currently loaded.\r\n   *\r\n   * This checks for changes in properties that *can*, but do not *always*, change the scale level the loader picks.\r\n   * For example, a smaller `subregion` *may* mean a higher scale level will fit within memory constraints, or it may\r\n   * not. A higher `scaleLevelBias` *may* nudge the volume into a higher scale level, or we may already be at the max\r\n   * imposed by `multiscaleLevel`.\r\n   */\n  mayLoadNewScaleLevel() {\n    return !this.loadSpec.subregion.equals(this.loadSpecRequired.subregion) || this.loadSpecRequired.maxAtlasEdge !== this.loadSpec.maxAtlasEdge || this.loadSpecRequired.multiscaleLevel !== this.loadSpec.multiscaleLevel || this.loadSpecRequired.scaleLevelBias !== this.loadSpec.scaleLevelBias;\n  }\n\n  /** Call on any state update that may require new data to be loaded (subregion, enabled channels, time, etc.) */\n  async updateRequiredData(required, onChannelLoaded) {\n    this.loadSpecRequired = {\n      ...this.loadSpecRequired,\n      ...required\n    };\n    let shouldReload = this.mustLoadNewData();\n\n    // If we're not reloading due to required data changes, check if we should load a new scale level\n    if (!shouldReload && this.mayLoadNewScaleLevel()) {\n      // Loaders should cache loaded dimensions so that this call blocks no more than once per valid `LoadSpec`.\n      const dims = await this.loadScaleLevelDims();\n      if (dims) {\n        const dimsZYX = dims.map(({\n          shape\n        }) => [shape[2], shape[3], shape[4]]);\n        // Determine which scale level *would* be loaded, and see if it's different than what we have\n        const levelToLoad = (0,_loaders_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_3__.pickLevelToLoadUnscaled)(this.loadSpecRequired, dimsZYX);\n        shouldReload = this.imageInfo.multiscaleLevel !== levelToLoad;\n      }\n    }\n    if (shouldReload) {\n      this.loadNewData(onChannelLoaded);\n    }\n  }\n  async loadScaleLevelDims() {\n    try {\n      return await this.loader?.loadDims(this.loadSpecRequired);\n    } catch (e) {\n      this.volumeDataObservers.forEach(observer => observer.onVolumeLoadError(this, e));\n      return undefined;\n    }\n  }\n\n  /**\r\n   * Loads new data as specified in `this.loadSpecRequired`. Clones `loadSpecRequired` into `loadSpec` to indicate\r\n   * that the data that *must* be loaded is now the data that *has* been loaded.\r\n   */\n  async loadNewData(onChannelLoaded) {\n    this.setUnloaded();\n    this.loadSpec = {\n      ...this.loadSpecRequired,\n      subregion: this.loadSpecRequired.subregion.clone()\n    };\n    try {\n      await this.loader?.loadVolumeData(this, undefined, onChannelLoaded);\n    } catch (e) {\n      this.volumeDataObservers.forEach(observer => observer.onVolumeLoadError(this, e));\n      throw e;\n    }\n  }\n\n  // we calculate the physical size of the volume (voxels*pixel_size)\n  // and then normalize to the max physical dimension\n  setVoxelSize(size) {\n    // only set the data if it is > 0.  zero is not an allowed value.\n    size.x = size.x > 0 ? size.x : 1.0;\n    size.y = size.y > 0 ? size.y : 1.0;\n    size.z = size.z > 0 ? size.z : 1.0;\n    this.physicalPixelSize = size;\n    this.physicalSize = this.imageInfo.originalSize.clone().multiply(this.physicalPixelSize);\n    // Volume is scaled such that its largest physical dimension is 1 world unit - save that dimension for conversions\n    this.physicalScale = Math.max(this.physicalSize.x, this.physicalSize.y, this.physicalSize.z);\n    // Compute the volume's max extent - scaled to max dimension.\n    this.normPhysicalSize = this.physicalSize.clone().divideScalar(this.physicalScale);\n    // While we're here, pick a power of 10 that divides into our max dimension a reasonable number of times\n    // and save it to be the length of tick marks in 3d.\n    this.tickMarkPhysicalLength = 10 ** Math.floor(Math.log10(this.physicalScale / 2));\n  }\n  setUnitSymbol(symbol) {\n    this.physicalUnitSymbol = symbol;\n  }\n\n  /** Computes the center of the volume subset */\n  getContentCenter() {\n    // center point: (normRegionSize / 2 + normRegionOffset - 0.5) * normPhysicalSize;\n    return this.normRegionSize.clone().divideScalar(2).add(this.normRegionOffset).subScalar(0.5).multiply(this.normPhysicalSize);\n  }\n  cleanup() {\n    // no op\n  }\n  getChannel(channelIndex) {\n    return this.channels[channelIndex];\n  }\n  onChannelLoaded(batch) {\n    // check to see if all channels are now loaded, and fire an event(?)\n    if (this.loadSpec.channels.every(channelIndex => this.channels[channelIndex].loaded)) {\n      this.loaded = true;\n    }\n    batch.forEach(channelIndex => this.channelLoadCallback?.(this, channelIndex));\n    this.volumeDataObservers.forEach(observer => observer.onVolumeData(this, batch));\n  }\n\n  /**\r\n   * Assign volume data via a 2d array containing the z slices as tiles across it.  Assumes that the incoming data is consistent with the image's pre-existing imageInfo tile metadata.\r\n   * @param {number} channelIndex\r\n   * @param {Uint8Array} atlasdata\r\n   * @param {number} atlaswidth\r\n   * @param {number} atlasheight\r\n   */\n  setChannelDataFromAtlas(channelIndex, atlasdata, atlaswidth, atlasheight) {\n    this.channels[channelIndex].setBits(atlasdata, atlaswidth, atlasheight);\n    const {\n      x,\n      y,\n      z\n    } = this.imageInfo.subregionSize;\n    this.channels[channelIndex].unpackVolumeFromAtlas(x, y, z);\n    this.onChannelLoaded([channelIndex]);\n  }\n\n  // ASSUMES that this.channelData.options is already set and incoming data is consistent with it\n  /**\r\n   * Assign volume data as a 3d array ordered x,y,z. The xy size must be equal to tilewidth*tileheight from the imageInfo used to construct this Volume.  Assumes that the incoming data is consistent with the image's pre-existing imageInfo tile metadata.\r\n   * @param {number} channelIndex\r\n   * @param {Uint8Array} volumeData\r\n   */\n  setChannelDataFromVolume(channelIndex, volumeData, range) {\n    const {\n      subregionSize,\n      atlasTileDims\n    } = this.imageInfo;\n    this.channels[channelIndex].setFromVolumeData(volumeData, subregionSize.x, subregionSize.y, subregionSize.z, atlasTileDims.x * subregionSize.x, atlasTileDims.y * subregionSize.y, range[0], range[1]);\n    this.onChannelLoaded([channelIndex]);\n  }\n\n  // TODO: decide if this should update imageInfo or not. For now, leave imageInfo alone as the \"original\" data\n  /**\r\n   * Add a new channel ready to receive data from one of the setChannelDataFrom* calls.\r\n   * Name and color will be defaulted if not provided. For now, leave imageInfo alone as the \"original\" data\r\n   * @param {string} name\r\n   * @param {Array.<number>} color [r,g,b]\r\n   */\n  appendEmptyChannel(name, color) {\n    const idx = this.imageInfo.numChannels;\n    const chname = name || \"channel_\" + idx;\n    const chcolor = color || (0,_constants_colors_js__WEBPACK_IMPORTED_MODULE_1__.getColorByChannelIndex)(idx);\n    this.numChannels += 1;\n    this.channelNames.push(chname);\n    this.channelColorsDefault.push(chcolor);\n    this.channels.push(new _Channel_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](chname));\n    for (let i = 0; i < this.volumeDataObservers.length; ++i) {\n      this.volumeDataObservers[i].onVolumeChannelAdded(this, idx);\n    }\n    return idx;\n  }\n\n  /**\r\n   * Get a value from the volume data\r\n   * @return {number} the intensity value from the given channel at the given xyz location\r\n   * @param {number} c The channel index\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} z\r\n   */\n  getIntensity(c, x, y, z) {\n    return this.channels[c].getIntensity(x, y, z);\n  }\n\n  /**\r\n   * Get the 256-bin histogram for the given channel\r\n   * @return {Histogram} the histogram\r\n   * @param {number} c The channel index\r\n   */\n  getHistogram(c) {\n    return this.channels[c].getHistogram();\n  }\n\n  /**\r\n   * Set the lut for the given channel\r\n   * @param {number} c The channel index\r\n   * @param {Array.<number>} lut The lut as a 256 element array\r\n   */\n  setLut(c, lut) {\n    this.channels[c].setLut(lut);\n  }\n\n  /**\r\n   * Set the color palette for the given channel\r\n   * @param {number} c The channel index\r\n   * @param {Array.<number>} palette The colors as a 256 element array * RGBA\r\n   */\n  setColorPalette(c, palette) {\n    this.channels[c].setColorPalette(palette);\n  }\n\n  /**\r\n   * Set the color palette alpha multiplier for the given channel.\r\n   * This will blend between the ordinary color lut and this colorPalette lut.\r\n   * @param {number} c The channel index\r\n   * @param {number} alpha The alpha value as a number from 0 to 1\r\n   */\n  setColorPaletteAlpha(c, alpha) {\n    this.channels[c].setColorPaletteAlpha(alpha);\n  }\n\n  /**\r\n   * Return the intrinsic rotation associated with this volume (radians)\r\n   * @return {Array.<number>} the xyz Euler angles (radians)\r\n   */\n  getRotation() {\n    // default axis order is XYZ\n    return this.imageInfo.transform.rotation.toArray();\n  }\n\n  /**\r\n   * Return the intrinsic translation (pivot center delta) associated with this volume, in normalized volume units\r\n   * @return {Array.<number>} the xyz translation in normalized volume units\r\n   */\n  getTranslation() {\n    return this.voxelsToWorldSpace(this.imageInfo.transform.translation.toArray());\n  }\n\n  /**\r\n   * Return a translation in normalized volume units, given a translation in image voxels\r\n   * @return {Array.<number>} the xyz translation in normalized volume units\r\n   */\n  voxelsToWorldSpace(xyz) {\n    // ASSUME: translation is in original image voxels.\n    // account for pixel_size and normalized scaling in the threejs volume representation we're using\n    const m = 1.0 / Math.max(this.physicalSize.x, Math.max(this.physicalSize.y, this.physicalSize.z));\n    return new three__WEBPACK_IMPORTED_MODULE_4__.Vector3().fromArray(xyz).multiply(this.physicalPixelSize).multiplyScalar(m).toArray();\n  }\n  addVolumeDataObserver(o) {\n    this.volumeDataObservers.push(o);\n  }\n  removeVolumeDataObserver(o) {\n    if (o) {\n      const i = this.volumeDataObservers.indexOf(o);\n      if (i !== -1) {\n        this.volumeDataObservers.splice(i, 1);\n      }\n    }\n  }\n  removeAllVolumeDataObservers() {\n    this.volumeDataObservers = [];\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy9Wb2x1bWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF5QztBQUNOO0FBQzRCO0FBQ1Q7QUFDbUM7QUFDbEYsTUFBTU8sbUJBQW1CLEdBQUdBLENBQUEsTUFBTztFQUN4Q0MsSUFBSSxFQUFFLEVBQUU7RUFDUkMsWUFBWSxFQUFFLElBQUlSLDBDQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDbENTLGFBQWEsRUFBRSxJQUFJViwwQ0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDaENXLFVBQVUsRUFBRSxJQUFJViwwQ0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0VBQ2hDVyxhQUFhLEVBQUUsSUFBSVgsMENBQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztFQUNuQ1ksZUFBZSxFQUFFLElBQUlaLDBDQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDckNhLGlCQUFpQixFQUFFLElBQUliLDBDQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDdkNjLFdBQVcsRUFBRSxFQUFFO0VBQ2ZDLFdBQVcsRUFBRSxDQUFDO0VBQ2RDLFlBQVksRUFBRSxFQUFFO0VBQ2hCQyxhQUFhLEVBQUUsRUFBRTtFQUNqQkMsS0FBSyxFQUFFLENBQUM7RUFDUkMsU0FBUyxFQUFFLENBQUM7RUFDWkMsUUFBUSxFQUFFLEVBQUU7RUFDWkMsbUJBQW1CLEVBQUUsQ0FBQztFQUN0QkMsZUFBZSxFQUFFLENBQUM7RUFDbEJDLFNBQVMsRUFBRTtJQUNUQyxXQUFXLEVBQUUsSUFBSXhCLDBDQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDakN5QixRQUFRLEVBQUUsSUFBSXpCLDBDQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0VBQy9CO0FBQ0YsQ0FBQyxDQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZSxNQUFNMEIsTUFBTSxDQUFDO0VBQzFCO0VBQ0E7O0VBRUFDLFdBQVdBLENBQUNDLFNBQVMsR0FBR3RCLG1CQUFtQixDQUFDLENBQUMsRUFBRXVCLFFBQVEsR0FBRyxJQUFJMUIsK0RBQVEsQ0FBQyxDQUFDLEVBQUUyQixNQUFNLEVBQUU7SUFDaEYsSUFBSSxDQUFDQyxNQUFNLEdBQUcsS0FBSztJQUNuQixJQUFJLENBQUNILFNBQVMsR0FBR0EsU0FBUztJQUMxQixJQUFJLENBQUNyQixJQUFJLEdBQUcsSUFBSSxDQUFDcUIsU0FBUyxDQUFDckIsSUFBSTtJQUMvQixJQUFJLENBQUNzQixRQUFRLEdBQUc7TUFDZDtNQUNBUCxlQUFlLEVBQUUsQ0FBQztNQUNsQlUsY0FBYyxFQUFFLENBQUM7TUFDakJDLFlBQVksRUFBRTdCLHlFQUFjO01BQzVCOEIsUUFBUSxFQUFFQyxLQUFLLENBQUNDLElBQUksQ0FBQztRQUNuQkMsTUFBTSxFQUFFLElBQUksQ0FBQ1QsU0FBUyxDQUFDYjtNQUN6QixDQUFDLEVBQUUsQ0FBQ3VCLElBQUksRUFBRUMsR0FBRyxLQUFLQSxHQUFHLENBQUM7TUFDdEIsR0FBR1Y7SUFDTCxDQUFDO0lBQ0QsSUFBSSxDQUFDVyxnQkFBZ0IsR0FBRztNQUN0QixHQUFHLElBQUksQ0FBQ1gsUUFBUTtNQUNoQkssUUFBUSxFQUFFLElBQUksQ0FBQ0wsUUFBUSxDQUFDSyxRQUFRLENBQUNPLEtBQUssQ0FBQyxDQUFDO01BQ3hDQyxTQUFTLEVBQUUsSUFBSSxDQUFDYixRQUFRLENBQUNhLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDO0lBQzNDLENBQUM7SUFDRCxJQUFJLENBQUNiLE1BQU0sR0FBR0EsTUFBTTtJQUNwQjtJQUNBLElBQUksQ0FBQ2MsYUFBYSxHQUFHLENBQUMsQ0FBQztJQUN2QixJQUFJLENBQUNDLGNBQWMsR0FBRyxJQUFJN0MsMENBQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUMxQyxJQUFJLENBQUM4QyxnQkFBZ0IsR0FBRyxJQUFJOUMsMENBQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUM1QyxJQUFJLENBQUMrQyxZQUFZLEdBQUcsSUFBSS9DLDBDQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDeEMsSUFBSSxDQUFDZ0QsYUFBYSxHQUFHLENBQUM7SUFDdEIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxJQUFJakQsMENBQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUM1QyxJQUFJLENBQUNhLGlCQUFpQixHQUFHLElBQUksQ0FBQ2UsU0FBUyxDQUFDZixpQkFBaUI7SUFDekQsSUFBSSxDQUFDcUMsc0JBQXNCLEdBQUcsQ0FBQztJQUMvQixJQUFJLENBQUNDLFlBQVksQ0FBQyxJQUFJLENBQUN0QyxpQkFBaUIsQ0FBQztJQUN6QyxJQUFJLENBQUNFLFdBQVcsR0FBRyxJQUFJLENBQUNhLFNBQVMsQ0FBQ2IsV0FBVztJQUM3QyxJQUFJLENBQUNDLFlBQVksR0FBRyxJQUFJLENBQUNZLFNBQVMsQ0FBQ1osWUFBWSxDQUFDeUIsS0FBSyxDQUFDLENBQUM7SUFDdkQsSUFBSSxDQUFDVyxvQkFBb0IsR0FBRyxJQUFJLENBQUN4QixTQUFTLENBQUNYLGFBQWEsR0FBRyxJQUFJLENBQUNXLFNBQVMsQ0FBQ1gsYUFBYSxDQUFDd0IsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUN6QixZQUFZLENBQUNxQyxHQUFHLENBQUMsQ0FBQzlDLElBQUksRUFBRStDLEtBQUssS0FBS3BELDRFQUFzQixDQUFDb0QsS0FBSyxDQUFDLENBQUM7SUFDdks7SUFDQSxJQUFJLElBQUksQ0FBQ0Ysb0JBQW9CLENBQUNmLE1BQU0sR0FBRyxJQUFJLENBQUNULFNBQVMsQ0FBQ2IsV0FBVyxFQUFFO01BQ2pFLEtBQUssSUFBSXdDLENBQUMsR0FBRyxJQUFJLENBQUNILG9CQUFvQixDQUFDZixNQUFNLEdBQUcsQ0FBQyxFQUFFa0IsQ0FBQyxHQUFHLElBQUksQ0FBQzNCLFNBQVMsQ0FBQ2IsV0FBVyxFQUFFLEVBQUV3QyxDQUFDLEVBQUU7UUFDdEYsSUFBSSxDQUFDSCxvQkFBb0IsQ0FBQ0csQ0FBQyxDQUFDLEdBQUdyRCw0RUFBc0IsQ0FBQ3FELENBQUMsQ0FBQztNQUMxRDtJQUNGO0lBQ0EsSUFBSSxDQUFDckIsUUFBUSxHQUFHLEVBQUU7SUFDbEIsS0FBSyxJQUFJcUIsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHLElBQUksQ0FBQzNCLFNBQVMsQ0FBQ2IsV0FBVyxFQUFFLEVBQUV3QyxDQUFDLEVBQUU7TUFDbkQsTUFBTUMsT0FBTyxHQUFHLElBQUl2RCxtREFBTyxDQUFDLElBQUksQ0FBQ2UsWUFBWSxDQUFDdUMsQ0FBQyxDQUFDLENBQUM7TUFDakQsSUFBSSxDQUFDckIsUUFBUSxDQUFDdUIsSUFBSSxDQUFDRCxPQUFPLENBQUM7TUFDM0I7TUFDQUEsT0FBTyxDQUFDRSxJQUFJLEdBQUcsSUFBSSxDQUFDOUIsU0FBUyxDQUFDakIsYUFBYSxDQUFDZ0QsT0FBTyxDQUFDLENBQUM7SUFDdkQ7SUFDQSxJQUFJLENBQUNDLGtCQUFrQixHQUFHLElBQUksQ0FBQ2hDLFNBQVMsQ0FBQ2QsV0FBVztJQUNwRCxJQUFJLENBQUMrQyxtQkFBbUIsR0FBRyxFQUFFO0VBQy9CO0VBQ0FDLFdBQVdBLENBQUEsRUFBRztJQUNaLElBQUksQ0FBQy9CLE1BQU0sR0FBRyxLQUFLO0lBQ25CLElBQUksQ0FBQ0csUUFBUSxDQUFDNkIsT0FBTyxDQUFDUCxPQUFPLElBQUk7TUFDL0JBLE9BQU8sQ0FBQ3pCLE1BQU0sR0FBRyxLQUFLO0lBQ3hCLENBQUMsQ0FBQztFQUNKO0VBQ0FpQyxRQUFRQSxDQUFBLEVBQUc7SUFDVCxPQUFPLElBQUksQ0FBQ2pDLE1BQU07RUFDcEI7RUFDQWtDLGdCQUFnQkEsQ0FBQSxFQUFHO0lBQ2pCLE1BQU07TUFDSnZELFVBQVU7TUFDVkMsYUFBYTtNQUNiQztJQUNGLENBQUMsR0FBRyxJQUFJLENBQUNnQixTQUFTO0lBQ2xCLElBQUksQ0FBQ3VCLFlBQVksQ0FBQyxJQUFJLENBQUN0QyxpQkFBaUIsQ0FBQztJQUN6QyxJQUFJLENBQUNnQyxjQUFjLEdBQUdsQyxhQUFhLENBQUNnQyxLQUFLLENBQUMsQ0FBQyxDQUFDdUIsTUFBTSxDQUFDeEQsVUFBVSxDQUFDO0lBQzlELElBQUksQ0FBQ29DLGdCQUFnQixHQUFHbEMsZUFBZSxDQUFDK0IsS0FBSyxDQUFDLENBQUMsQ0FBQ3VCLE1BQU0sQ0FBQ3hELFVBQVUsQ0FBQztFQUNwRTs7RUFFQTtFQUNBeUQsZUFBZUEsQ0FBQSxFQUFHO0lBQ2hCLE9BQU8sSUFBSSxDQUFDdEMsUUFBUSxDQUFDdUMsSUFBSSxLQUFLLElBQUksQ0FBQzVCLGdCQUFnQixDQUFDNEIsSUFBSTtJQUN4RDtJQUNBLENBQUMsSUFBSSxDQUFDdkMsUUFBUSxDQUFDYSxTQUFTLENBQUMyQixXQUFXLENBQUMsSUFBSSxDQUFDN0IsZ0JBQWdCLENBQUNFLFNBQVMsQ0FBQztJQUNyRTtJQUNBLElBQUksQ0FBQ0YsZ0JBQWdCLENBQUNOLFFBQVEsQ0FBQ29DLElBQUksQ0FBQ2QsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDM0IsUUFBUSxDQUFDSyxRQUFRLENBQUNxQyxRQUFRLENBQUNmLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFBQTtFQUU1Rjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRWdCLG9CQUFvQkEsQ0FBQSxFQUFHO0lBQ3JCLE9BQU8sQ0FBQyxJQUFJLENBQUMzQyxRQUFRLENBQUNhLFNBQVMsQ0FBQytCLE1BQU0sQ0FBQyxJQUFJLENBQUNqQyxnQkFBZ0IsQ0FBQ0UsU0FBUyxDQUFDLElBQUksSUFBSSxDQUFDRixnQkFBZ0IsQ0FBQ1AsWUFBWSxLQUFLLElBQUksQ0FBQ0osUUFBUSxDQUFDSSxZQUFZLElBQUksSUFBSSxDQUFDTyxnQkFBZ0IsQ0FBQ2xCLGVBQWUsS0FBSyxJQUFJLENBQUNPLFFBQVEsQ0FBQ1AsZUFBZSxJQUFJLElBQUksQ0FBQ2tCLGdCQUFnQixDQUFDUixjQUFjLEtBQUssSUFBSSxDQUFDSCxRQUFRLENBQUNHLGNBQWM7RUFDbFM7O0VBRUE7RUFDQSxNQUFNMEMsa0JBQWtCQSxDQUFDQyxRQUFRLEVBQUVDLGVBQWUsRUFBRTtJQUNsRCxJQUFJLENBQUNwQyxnQkFBZ0IsR0FBRztNQUN0QixHQUFHLElBQUksQ0FBQ0EsZ0JBQWdCO01BQ3hCLEdBQUdtQztJQUNMLENBQUM7SUFDRCxJQUFJRSxZQUFZLEdBQUcsSUFBSSxDQUFDVixlQUFlLENBQUMsQ0FBQzs7SUFFekM7SUFDQSxJQUFJLENBQUNVLFlBQVksSUFBSSxJQUFJLENBQUNMLG9CQUFvQixDQUFDLENBQUMsRUFBRTtNQUNoRDtNQUNBLE1BQU1kLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQ29CLGtCQUFrQixDQUFDLENBQUM7TUFDNUMsSUFBSXBCLElBQUksRUFBRTtRQUNSLE1BQU1xQixPQUFPLEdBQUdyQixJQUFJLENBQUNMLEdBQUcsQ0FBQyxDQUFDO1VBQ3hCMkI7UUFDRixDQUFDLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFQSxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUVBLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JDO1FBQ0EsTUFBTUMsV0FBVyxHQUFHNUUsc0ZBQXVCLENBQUMsSUFBSSxDQUFDbUMsZ0JBQWdCLEVBQUV1QyxPQUFPLENBQUM7UUFDM0VGLFlBQVksR0FBRyxJQUFJLENBQUNqRCxTQUFTLENBQUNOLGVBQWUsS0FBSzJELFdBQVc7TUFDL0Q7SUFDRjtJQUNBLElBQUlKLFlBQVksRUFBRTtNQUNoQixJQUFJLENBQUNLLFdBQVcsQ0FBQ04sZUFBZSxDQUFDO0lBQ25DO0VBQ0Y7RUFDQSxNQUFNRSxrQkFBa0JBLENBQUEsRUFBRztJQUN6QixJQUFJO01BQ0YsT0FBTyxNQUFNLElBQUksQ0FBQ2hELE1BQU0sRUFBRXFELFFBQVEsQ0FBQyxJQUFJLENBQUMzQyxnQkFBZ0IsQ0FBQztJQUMzRCxDQUFDLENBQUMsT0FBTzRDLENBQUMsRUFBRTtNQUNWLElBQUksQ0FBQ3ZCLG1CQUFtQixDQUFDRSxPQUFPLENBQUNzQixRQUFRLElBQUlBLFFBQVEsQ0FBQ0MsaUJBQWlCLENBQUMsSUFBSSxFQUFFRixDQUFDLENBQUMsQ0FBQztNQUNqRixPQUFPRyxTQUFTO0lBQ2xCO0VBQ0Y7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxNQUFNTCxXQUFXQSxDQUFDTixlQUFlLEVBQUU7SUFDakMsSUFBSSxDQUFDZCxXQUFXLENBQUMsQ0FBQztJQUNsQixJQUFJLENBQUNqQyxRQUFRLEdBQUc7TUFDZCxHQUFHLElBQUksQ0FBQ1csZ0JBQWdCO01BQ3hCRSxTQUFTLEVBQUUsSUFBSSxDQUFDRixnQkFBZ0IsQ0FBQ0UsU0FBUyxDQUFDQyxLQUFLLENBQUM7SUFDbkQsQ0FBQztJQUNELElBQUk7TUFDRixNQUFNLElBQUksQ0FBQ2IsTUFBTSxFQUFFMEQsY0FBYyxDQUFDLElBQUksRUFBRUQsU0FBUyxFQUFFWCxlQUFlLENBQUM7SUFDckUsQ0FBQyxDQUFDLE9BQU9RLENBQUMsRUFBRTtNQUNWLElBQUksQ0FBQ3ZCLG1CQUFtQixDQUFDRSxPQUFPLENBQUNzQixRQUFRLElBQUlBLFFBQVEsQ0FBQ0MsaUJBQWlCLENBQUMsSUFBSSxFQUFFRixDQUFDLENBQUMsQ0FBQztNQUNqRixNQUFNQSxDQUFDO0lBQ1Q7RUFDRjs7RUFFQTtFQUNBO0VBQ0FqQyxZQUFZQSxDQUFDc0MsSUFBSSxFQUFFO0lBQ2pCO0lBQ0FBLElBQUksQ0FBQ0MsQ0FBQyxHQUFHRCxJQUFJLENBQUNDLENBQUMsR0FBRyxDQUFDLEdBQUdELElBQUksQ0FBQ0MsQ0FBQyxHQUFHLEdBQUc7SUFDbENELElBQUksQ0FBQ0UsQ0FBQyxHQUFHRixJQUFJLENBQUNFLENBQUMsR0FBRyxDQUFDLEdBQUdGLElBQUksQ0FBQ0UsQ0FBQyxHQUFHLEdBQUc7SUFDbENGLElBQUksQ0FBQ0csQ0FBQyxHQUFHSCxJQUFJLENBQUNHLENBQUMsR0FBRyxDQUFDLEdBQUdILElBQUksQ0FBQ0csQ0FBQyxHQUFHLEdBQUc7SUFDbEMsSUFBSSxDQUFDL0UsaUJBQWlCLEdBQUc0RSxJQUFJO0lBQzdCLElBQUksQ0FBQzFDLFlBQVksR0FBRyxJQUFJLENBQUNuQixTQUFTLENBQUNwQixZQUFZLENBQUNtQyxLQUFLLENBQUMsQ0FBQyxDQUFDa0QsUUFBUSxDQUFDLElBQUksQ0FBQ2hGLGlCQUFpQixDQUFDO0lBQ3hGO0lBQ0EsSUFBSSxDQUFDbUMsYUFBYSxHQUFHOEMsSUFBSSxDQUFDQyxHQUFHLENBQUMsSUFBSSxDQUFDaEQsWUFBWSxDQUFDMkMsQ0FBQyxFQUFFLElBQUksQ0FBQzNDLFlBQVksQ0FBQzRDLENBQUMsRUFBRSxJQUFJLENBQUM1QyxZQUFZLENBQUM2QyxDQUFDLENBQUM7SUFDNUY7SUFDQSxJQUFJLENBQUMzQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUNGLFlBQVksQ0FBQ0osS0FBSyxDQUFDLENBQUMsQ0FBQ3FELFlBQVksQ0FBQyxJQUFJLENBQUNoRCxhQUFhLENBQUM7SUFDbEY7SUFDQTtJQUNBLElBQUksQ0FBQ0Usc0JBQXNCLEdBQUcsRUFBRSxJQUFJNEMsSUFBSSxDQUFDRyxLQUFLLENBQUNILElBQUksQ0FBQ0ksS0FBSyxDQUFDLElBQUksQ0FBQ2xELGFBQWEsR0FBRyxDQUFDLENBQUMsQ0FBQztFQUNwRjtFQUNBbUQsYUFBYUEsQ0FBQ0MsTUFBTSxFQUFFO0lBQ3BCLElBQUksQ0FBQ3hDLGtCQUFrQixHQUFHd0MsTUFBTTtFQUNsQzs7RUFFQTtFQUNBQyxnQkFBZ0JBLENBQUEsRUFBRztJQUNqQjtJQUNBLE9BQU8sSUFBSSxDQUFDeEQsY0FBYyxDQUFDRixLQUFLLENBQUMsQ0FBQyxDQUFDcUQsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDTSxHQUFHLENBQUMsSUFBSSxDQUFDeEQsZ0JBQWdCLENBQUMsQ0FBQ3lELFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQ1YsUUFBUSxDQUFDLElBQUksQ0FBQzVDLGdCQUFnQixDQUFDO0VBQzlIO0VBQ0F1RCxPQUFPQSxDQUFBLEVBQUc7SUFDUjtFQUFBO0VBRUZDLFVBQVVBLENBQUNDLFlBQVksRUFBRTtJQUN2QixPQUFPLElBQUksQ0FBQ3hFLFFBQVEsQ0FBQ3dFLFlBQVksQ0FBQztFQUNwQztFQUNBOUIsZUFBZUEsQ0FBQytCLEtBQUssRUFBRTtJQUNyQjtJQUNBLElBQUksSUFBSSxDQUFDOUUsUUFBUSxDQUFDSyxRQUFRLENBQUMwRSxLQUFLLENBQUNGLFlBQVksSUFBSSxJQUFJLENBQUN4RSxRQUFRLENBQUN3RSxZQUFZLENBQUMsQ0FBQzNFLE1BQU0sQ0FBQyxFQUFFO01BQ3BGLElBQUksQ0FBQ0EsTUFBTSxHQUFHLElBQUk7SUFDcEI7SUFDQTRFLEtBQUssQ0FBQzVDLE9BQU8sQ0FBQzJDLFlBQVksSUFBSSxJQUFJLENBQUNHLG1CQUFtQixHQUFHLElBQUksRUFBRUgsWUFBWSxDQUFDLENBQUM7SUFDN0UsSUFBSSxDQUFDN0MsbUJBQW1CLENBQUNFLE9BQU8sQ0FBQ3NCLFFBQVEsSUFBSUEsUUFBUSxDQUFDeUIsWUFBWSxDQUFDLElBQUksRUFBRUgsS0FBSyxDQUFDLENBQUM7RUFDbEY7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRUksdUJBQXVCQSxDQUFDTCxZQUFZLEVBQUVNLFNBQVMsRUFBRUMsVUFBVSxFQUFFQyxXQUFXLEVBQUU7SUFDeEUsSUFBSSxDQUFDaEYsUUFBUSxDQUFDd0UsWUFBWSxDQUFDLENBQUNTLE9BQU8sQ0FBQ0gsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLFdBQVcsQ0FBQztJQUN2RSxNQUFNO01BQ0p4QixDQUFDO01BQ0RDLENBQUM7TUFDREM7SUFDRixDQUFDLEdBQUcsSUFBSSxDQUFDaEUsU0FBUyxDQUFDakIsYUFBYTtJQUNoQyxJQUFJLENBQUN1QixRQUFRLENBQUN3RSxZQUFZLENBQUMsQ0FBQ1UscUJBQXFCLENBQUMxQixDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxDQUFDO0lBQzFELElBQUksQ0FBQ2hCLGVBQWUsQ0FBQyxDQUFDOEIsWUFBWSxDQUFDLENBQUM7RUFDdEM7O0VBRUE7RUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0VXLHdCQUF3QkEsQ0FBQ1gsWUFBWSxFQUFFWSxVQUFVLEVBQUVDLEtBQUssRUFBRTtJQUN4RCxNQUFNO01BQ0o1RyxhQUFhO01BQ2JGO0lBQ0YsQ0FBQyxHQUFHLElBQUksQ0FBQ21CLFNBQVM7SUFDbEIsSUFBSSxDQUFDTSxRQUFRLENBQUN3RSxZQUFZLENBQUMsQ0FBQ2MsaUJBQWlCLENBQUNGLFVBQVUsRUFBRTNHLGFBQWEsQ0FBQytFLENBQUMsRUFBRS9FLGFBQWEsQ0FBQ2dGLENBQUMsRUFBRWhGLGFBQWEsQ0FBQ2lGLENBQUMsRUFBRW5GLGFBQWEsQ0FBQ2lGLENBQUMsR0FBRy9FLGFBQWEsQ0FBQytFLENBQUMsRUFBRWpGLGFBQWEsQ0FBQ2tGLENBQUMsR0FBR2hGLGFBQWEsQ0FBQ2dGLENBQUMsRUFBRTRCLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRUEsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3RNLElBQUksQ0FBQzNDLGVBQWUsQ0FBQyxDQUFDOEIsWUFBWSxDQUFDLENBQUM7RUFDdEM7O0VBRUE7RUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRWUsa0JBQWtCQSxDQUFDbEgsSUFBSSxFQUFFbUgsS0FBSyxFQUFFO0lBQzlCLE1BQU1uRixHQUFHLEdBQUcsSUFBSSxDQUFDWCxTQUFTLENBQUNiLFdBQVc7SUFDdEMsTUFBTTRHLE1BQU0sR0FBR3BILElBQUksSUFBSSxVQUFVLEdBQUdnQyxHQUFHO0lBQ3ZDLE1BQU1xRixPQUFPLEdBQUdGLEtBQUssSUFBSXhILDRFQUFzQixDQUFDcUMsR0FBRyxDQUFDO0lBQ3BELElBQUksQ0FBQ3hCLFdBQVcsSUFBSSxDQUFDO0lBQ3JCLElBQUksQ0FBQ0MsWUFBWSxDQUFDeUMsSUFBSSxDQUFDa0UsTUFBTSxDQUFDO0lBQzlCLElBQUksQ0FBQ3ZFLG9CQUFvQixDQUFDSyxJQUFJLENBQUNtRSxPQUFPLENBQUM7SUFDdkMsSUFBSSxDQUFDMUYsUUFBUSxDQUFDdUIsSUFBSSxDQUFDLElBQUl4RCxtREFBTyxDQUFDMEgsTUFBTSxDQUFDLENBQUM7SUFDdkMsS0FBSyxJQUFJcEUsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHLElBQUksQ0FBQ00sbUJBQW1CLENBQUN4QixNQUFNLEVBQUUsRUFBRWtCLENBQUMsRUFBRTtNQUN4RCxJQUFJLENBQUNNLG1CQUFtQixDQUFDTixDQUFDLENBQUMsQ0FBQ3NFLG9CQUFvQixDQUFDLElBQUksRUFBRXRGLEdBQUcsQ0FBQztJQUM3RDtJQUNBLE9BQU9BLEdBQUc7RUFDWjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0V1RixZQUFZQSxDQUFDQyxDQUFDLEVBQUVyQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFO0lBQ3ZCLE9BQU8sSUFBSSxDQUFDMUQsUUFBUSxDQUFDNkYsQ0FBQyxDQUFDLENBQUNELFlBQVksQ0FBQ3BDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLENBQUM7RUFDL0M7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFb0MsWUFBWUEsQ0FBQ0QsQ0FBQyxFQUFFO0lBQ2QsT0FBTyxJQUFJLENBQUM3RixRQUFRLENBQUM2RixDQUFDLENBQUMsQ0FBQ0MsWUFBWSxDQUFDLENBQUM7RUFDeEM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFQyxNQUFNQSxDQUFDRixDQUFDLEVBQUVHLEdBQUcsRUFBRTtJQUNiLElBQUksQ0FBQ2hHLFFBQVEsQ0FBQzZGLENBQUMsQ0FBQyxDQUFDRSxNQUFNLENBQUNDLEdBQUcsQ0FBQztFQUM5Qjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0VDLGVBQWVBLENBQUNKLENBQUMsRUFBRUssT0FBTyxFQUFFO0lBQzFCLElBQUksQ0FBQ2xHLFFBQVEsQ0FBQzZGLENBQUMsQ0FBQyxDQUFDSSxlQUFlLENBQUNDLE9BQU8sQ0FBQztFQUMzQzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRUMsb0JBQW9CQSxDQUFDTixDQUFDLEVBQUVPLEtBQUssRUFBRTtJQUM3QixJQUFJLENBQUNwRyxRQUFRLENBQUM2RixDQUFDLENBQUMsQ0FBQ00sb0JBQW9CLENBQUNDLEtBQUssQ0FBQztFQUM5Qzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNFQyxXQUFXQSxDQUFBLEVBQUc7SUFDWjtJQUNBLE9BQU8sSUFBSSxDQUFDM0csU0FBUyxDQUFDTCxTQUFTLENBQUNFLFFBQVEsQ0FBQ2tDLE9BQU8sQ0FBQyxDQUFDO0VBQ3BEOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0VBQ0U2RSxjQUFjQSxDQUFBLEVBQUc7SUFDZixPQUFPLElBQUksQ0FBQ0Msa0JBQWtCLENBQUMsSUFBSSxDQUFDN0csU0FBUyxDQUFDTCxTQUFTLENBQUNDLFdBQVcsQ0FBQ21DLE9BQU8sQ0FBQyxDQUFDLENBQUM7RUFDaEY7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRThFLGtCQUFrQkEsQ0FBQ0MsR0FBRyxFQUFFO0lBQ3RCO0lBQ0E7SUFDQSxNQUFNQyxDQUFDLEdBQUcsR0FBRyxHQUFHN0MsSUFBSSxDQUFDQyxHQUFHLENBQUMsSUFBSSxDQUFDaEQsWUFBWSxDQUFDMkMsQ0FBQyxFQUFFSSxJQUFJLENBQUNDLEdBQUcsQ0FBQyxJQUFJLENBQUNoRCxZQUFZLENBQUM0QyxDQUFDLEVBQUUsSUFBSSxDQUFDNUMsWUFBWSxDQUFDNkMsQ0FBQyxDQUFDLENBQUM7SUFDakcsT0FBTyxJQUFJNUYsMENBQU8sQ0FBQyxDQUFDLENBQUM0SSxTQUFTLENBQUNGLEdBQUcsQ0FBQyxDQUFDN0MsUUFBUSxDQUFDLElBQUksQ0FBQ2hGLGlCQUFpQixDQUFDLENBQUNnSSxjQUFjLENBQUNGLENBQUMsQ0FBQyxDQUFDaEYsT0FBTyxDQUFDLENBQUM7RUFDbEc7RUFDQW1GLHFCQUFxQkEsQ0FBQ0MsQ0FBQyxFQUFFO0lBQ3ZCLElBQUksQ0FBQ2xGLG1CQUFtQixDQUFDSixJQUFJLENBQUNzRixDQUFDLENBQUM7RUFDbEM7RUFDQUMsd0JBQXdCQSxDQUFDRCxDQUFDLEVBQUU7SUFDMUIsSUFBSUEsQ0FBQyxFQUFFO01BQ0wsTUFBTXhGLENBQUMsR0FBRyxJQUFJLENBQUNNLG1CQUFtQixDQUFDb0YsT0FBTyxDQUFDRixDQUFDLENBQUM7TUFDN0MsSUFBSXhGLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtRQUNaLElBQUksQ0FBQ00sbUJBQW1CLENBQUNxRixNQUFNLENBQUMzRixDQUFDLEVBQUUsQ0FBQyxDQUFDO01BQ3ZDO0lBQ0Y7RUFDRjtFQUNBNEYsNEJBQTRCQSxDQUFBLEVBQUc7SUFDN0IsSUFBSSxDQUFDdEYsbUJBQW1CLEdBQUcsRUFBRTtFQUMvQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uLi92b2x1bWUtdmlld2VyL2VzL1ZvbHVtZS5qcz80ZmUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjIsIFZlY3RvcjMgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCBDaGFubmVsIGZyb20gXCIuL0NoYW5uZWwuanNcIjtcbmltcG9ydCB7IGdldENvbG9yQnlDaGFubmVsSW5kZXggfSBmcm9tIFwiLi9jb25zdGFudHMvY29sb3JzLmpzXCI7XG5pbXBvcnQgeyBMb2FkU3BlYyB9IGZyb20gXCIuL2xvYWRlcnMvSVZvbHVtZUxvYWRlci5qc1wiO1xuaW1wb3J0IHsgTUFYX0FUTEFTX0VER0UsIHBpY2tMZXZlbFRvTG9hZFVuc2NhbGVkIH0gZnJvbSBcIi4vbG9hZGVycy9Wb2x1bWVMb2FkZXJVdGlscy5qc1wiO1xuZXhwb3J0IGNvbnN0IGdldERlZmF1bHRJbWFnZUluZm8gPSAoKSA9PiAoe1xuICBuYW1lOiBcIlwiLFxuICBvcmlnaW5hbFNpemU6IG5ldyBWZWN0b3IzKDEsIDEsIDEpLFxuICBhdGxhc1RpbGVEaW1zOiBuZXcgVmVjdG9yMigxLCAxKSxcbiAgdm9sdW1lU2l6ZTogbmV3IFZlY3RvcjMoMSwgMSwgMSksXG4gIHN1YnJlZ2lvblNpemU6IG5ldyBWZWN0b3IzKDEsIDEsIDEpLFxuICBzdWJyZWdpb25PZmZzZXQ6IG5ldyBWZWN0b3IzKDAsIDAsIDApLFxuICBwaHlzaWNhbFBpeGVsU2l6ZTogbmV3IFZlY3RvcjMoMSwgMSwgMSksXG4gIHNwYXRpYWxVbml0OiBcIlwiLFxuICBudW1DaGFubmVsczogMCxcbiAgY2hhbm5lbE5hbWVzOiBbXSxcbiAgY2hhbm5lbENvbG9yczogW10sXG4gIHRpbWVzOiAxLFxuICB0aW1lU2NhbGU6IDEsXG4gIHRpbWVVbml0OiBcIlwiLFxuICBudW1NdWx0aXNjYWxlTGV2ZWxzOiAxLFxuICBtdWx0aXNjYWxlTGV2ZWw6IDAsXG4gIHRyYW5zZm9ybToge1xuICAgIHRyYW5zbGF0aW9uOiBuZXcgVmVjdG9yMygwLCAwLCAwKSxcbiAgICByb3RhdGlvbjogbmV3IFZlY3RvcjMoMCwgMCwgMClcbiAgfVxufSk7XG4vKipcclxuICogUHJvdmlkZSBkaW1lbnNpb25zIG9mIHRoZSB2b2x1bWUgZGF0YSwgaW5jbHVkaW5nIGRpbWVuc2lvbnMgZm9yIHRleHR1cmUgYXRsYXMgZGF0YSBpbiB3aGljaCB0aGUgdm9sdW1lIHogc2xpY2VzXHJcbiAqIGFyZSB0aWxlZCBhY3Jvc3MgYSBzaW5nbGUgbGFyZ2UgMmQgaW1hZ2UgcGxhbmUuXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEltYWdlSW5mb1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBCYXNlIG5hbWUgb2YgaW1hZ2VcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt2ZXJzaW9uXSBTY2hlbWEgdmVyc2lvbiBwcmVmZXJhYmx5IGluIHNlbXZlciBmb3JtYXQuXHJcbiAqIEBwcm9wZXJ0eSB7VmVjdG9yMn0gb3JpZ2luYWxTaXplIFhZIHNpemUgb2YgdGhlICpvcmlnaW5hbCogKG5vdCBkb3duc2FtcGxlZCkgdm9sdW1lLCBpbiBwaXhlbHNcclxuICogQHByb3BlcnR5IHtWZWN0b3IyfSBhdGxhc0RpbXMgTnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgb2Ygei1zbGljZSB0aWxlcyAobm90IHBpeGVscykgaW4gdGhlIHRleHR1cmUgYXRsYXNcclxuICogQHByb3BlcnR5IHtWZWN0b3IzfSB2b2x1bWVTaXplIFNpemUgb2YgdGhlIHZvbHVtZSwgaW4gcGl4ZWxzXHJcbiAqIEBwcm9wZXJ0eSB7VmVjdG9yM30gcmVnaW9uU2l6ZSBTaXplIG9mIHRoZSBjdXJyZW50bHkgbG9hZGVkIHN1YnJlZ2lvbiwgaW4gcGl4ZWxzXHJcbiAqIEBwcm9wZXJ0eSB7VmVjdG9yM30gcmVnaW9uT2Zmc2V0IE9mZnNldCBvZiB0aGUgbG9hZGVkIHN1YnJlZ2lvbiBpbnRvIHRoZSB0b3RhbCB2b2x1bWUsIGluIHBpeGVsc1xyXG4gKiBAcHJvcGVydHkge1ZlY3RvcjN9IHBpeGVsU2l6ZSBTaXplIG9mIGEgc2luZ2xlICpvcmlnaW5hbCogKG5vdCBkb3duc2FtcGxlZCkgcGl4ZWwsIGluIHNwYXRpYWwgdW5pdHNcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNwYXRpYWxVbml0IFN5bWJvbCBvZiBwaHlzaWNhbCBzcGF0aWFsIHVuaXQgdXNlZCBieSBgcGl4ZWxTaXplYFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbnVtQ2hhbm5lbHMgTnVtYmVyIG9mIGNoYW5uZWxzXHJcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz59IGNoYW5uZWxOYW1lcyBOYW1lcyBvZiBlYWNoIG9mIHRoZSBjaGFubmVscyB0byBiZSByZW5kZXJlZCwgaW4gb3JkZXIuIFVuaXF1ZSBpZGVudGlmaWVyIGV4cGVjdGVkXHJcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gW2NoYW5uZWxDb2xvcnNdIENvbG9ycyBvZiBlYWNoIG9mIHRoZSBjaGFubmVscyB0byBiZSByZW5kZXJlZCwgYXMgYW4gb3JkZXJlZCBsaXN0IG9mIFtyLCBnLCBiXSBhcnJheXNcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVzIE51bWJlciBvZiB0aW1lcyAoZGVmYXVsdCA9IDEpXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lU2NhbGUgU2l6ZSBvZiBlYWNoIHRpbWUgc3RlcCBpbiBgdGltZVVuaXRgIHVuaXRzXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lVW5pdCBVbml0IHN5bWJvbCBmb3IgYHRpbWVTY2FsZWAgKGUuZy4gbWluKVxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gdHJhbnNmb3JtIHRyYW5zbGF0aW9uIGFuZCByb3RhdGlvbiBhcyBhcnJheXMgb2YgMyBudW1iZXJzLiBUcmFuc2xhdGlvbiBpcyBpbiB2b3hlbHMgKHRvIGJlIG11bHRpcGxpZWQgYnkgcGl4ZWxfc2l6ZSB2YWx1ZXMpLiBSb3RhdGlvbiBpcyBFdWxlciBhbmdsZXMgaW4gcmFkaWFucywgYXBwbGVkIGluIFhZWiBvcmRlci5cclxuICogQHByb3BlcnR5IHtPYmplY3R9IHVzZXJEYXRhIEFyYml0cmFyeSBtZXRhZGF0YSBub3QgY292ZXJlZCBieSBhYm92ZSBwcm9wZXJ0aWVzXHJcbiAqIEBleGFtcGxlIGNvbnN0IGltZ2RhdGEgPSB7XHJcbiAgXCJuYW1lXCI6IFwiQUlDUy0xMF81XzVcIixcclxuICBcInZlcnNpb25cIjogXCIwLjAuMFwiLFxyXG4gIG9yaWdpbmFsU2l6ZTogbmV3IFZlY3RvcjIoMzA2LCA0OTQpLFxyXG4gIGF0bGFzRGltczogbmV3IFZlY3RvcjIoMTAsIDcpLFxyXG4gIHZvbHVtZVNpemU6IG5ldyBWZWN0b3IzKDIwNCwgMjkyLCA2NSksXHJcbiAgcmVnaW9uU2l6ZTogbmV3IFZlY3RvcjMoMjA0LCAyOTIsIDY1KSxcclxuICByZWdpb25PZmZzZXQ6IG5ldyBWZWN0b3IzKDAsIDAsIDApLFxyXG4gIHBpeGVsU2l6ZTogbmV3IFZlY3RvcjMoMC4wNjUsIDAuMDY1LCAwLjI5KSxcclxuICBzcGF0aWFsVW5pdDogXCLOvG1cIixcclxuICBcIm51bUNoYW5uZWxzXCI6IDksXHJcbiAgXCJjaGFubmVsTmFtZXNcIjogW1wiRFJBUTVcIiwgXCJFR0ZQXCIsIFwiSG9lY2hzdCAzMzI1OFwiLCBcIlRMIEJyaWdodGZpZWxkXCIsIFwiU0VHX1NUUlVDVFwiLCBcIlNFR19NZW1iXCIsIFwiU0VHX0ROQVwiLCBcIkNPTl9NZW1iXCIsIFwiQ09OX0ROQVwiXSxcclxuICBcInRpbWVzXCI6IDUsXHJcbiAgXCJ0aW1lU2NhbGVcIjogMSxcclxuICBcInRpbWVVbml0XCI6IFwiaHJcIixcclxuICBcInRyYW5zZm9ybVwiOiB7XHJcbiAgICBcInRyYW5zbGF0aW9uXCI6IG5ldyBWZWN0b3IzKDUsIDUsIDEpLFxyXG4gICAgXCJyb3RhdGlvblwiOiBuZXcgVmVjdG9yMygwLCAzLjE0MTU5LCAxLjU3KSxcclxuICB9LFxyXG4gIH07XHJcbiAqL1xuXG4vKipcclxuICogQSByZW5kZXJhYmxlIG11bHRpY2hhbm5lbCB2b2x1bWUgaW1hZ2Ugd2l0aCA4LWJpdHMgcGVyIGNoYW5uZWwgaW50ZW5zaXR5IHZhbHVlcy5cclxuICogQGNsYXNzXHJcbiAqIEBwYXJhbSB7SW1hZ2VJbmZvfSBpbWFnZUluZm9cclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWb2x1bWUge1xuICAvLyBgTG9hZFNwZWNgIHJlcHJlc2VudGluZyB0aGUgbWluaW11bSBkYXRhIHJlcXVpcmVkIHRvIGRpc3BsYXkgd2hhdCdzIGluIHRoZSB2aWV3ZXIgKHN1YnJlZ2lvbiwgY2hhbm5lbHMsIGV0Yy4pLlxuICAvLyBVc2VkIHRvIGludGVsbGlnZW50bHkgaXNzdWUgbG9hZCByZXF1ZXN0cyB3aGVuZXZlciByZXF1aXJlZCBieSBhIHN0YXRlIGNoYW5nZS4gTW9kaWZ5IHdpdGggYHVwZGF0ZVJlcXVpcmVkRGF0YWAuXG5cbiAgY29uc3RydWN0b3IoaW1hZ2VJbmZvID0gZ2V0RGVmYXVsdEltYWdlSW5mbygpLCBsb2FkU3BlYyA9IG5ldyBMb2FkU3BlYygpLCBsb2FkZXIpIHtcbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW1hZ2VJbmZvID0gaW1hZ2VJbmZvO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuaW1hZ2VJbmZvLm5hbWU7XG4gICAgdGhpcy5sb2FkU3BlYyA9IHtcbiAgICAgIC8vIEZpbGwgaW4gZGVmYXVsdHMgZm9yIG9wdGlvbmFsIHByb3BlcnRpZXNcbiAgICAgIG11bHRpc2NhbGVMZXZlbDogMCxcbiAgICAgIHNjYWxlTGV2ZWxCaWFzOiAwLFxuICAgICAgbWF4QXRsYXNFZGdlOiBNQVhfQVRMQVNfRURHRSxcbiAgICAgIGNoYW5uZWxzOiBBcnJheS5mcm9tKHtcbiAgICAgICAgbGVuZ3RoOiB0aGlzLmltYWdlSW5mby5udW1DaGFubmVsc1xuICAgICAgfSwgKF92YWwsIGlkeCkgPT4gaWR4KSxcbiAgICAgIC4uLmxvYWRTcGVjXG4gICAgfTtcbiAgICB0aGlzLmxvYWRTcGVjUmVxdWlyZWQgPSB7XG4gICAgICAuLi50aGlzLmxvYWRTcGVjLFxuICAgICAgY2hhbm5lbHM6IHRoaXMubG9hZFNwZWMuY2hhbm5lbHMuc2xpY2UoKSxcbiAgICAgIHN1YnJlZ2lvbjogdGhpcy5sb2FkU3BlYy5zdWJyZWdpb24uY2xvbmUoKVxuICAgIH07XG4gICAgdGhpcy5sb2FkZXIgPSBsb2FkZXI7XG4gICAgLy8gaW1hZ2VNZXRhZGF0YSB0byBiZSBmaWxsZWQgaW4gYnkgVm9sdW1lIExvYWRlcnNcbiAgICB0aGlzLmltYWdlTWV0YWRhdGEgPSB7fTtcbiAgICB0aGlzLm5vcm1SZWdpb25TaXplID0gbmV3IFZlY3RvcjMoMSwgMSwgMSk7XG4gICAgdGhpcy5ub3JtUmVnaW9uT2Zmc2V0ID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5waHlzaWNhbFNpemUgPSBuZXcgVmVjdG9yMygxLCAxLCAxKTtcbiAgICB0aGlzLnBoeXNpY2FsU2NhbGUgPSAxO1xuICAgIHRoaXMubm9ybVBoeXNpY2FsU2l6ZSA9IG5ldyBWZWN0b3IzKDEsIDEsIDEpO1xuICAgIHRoaXMucGh5c2ljYWxQaXhlbFNpemUgPSB0aGlzLmltYWdlSW5mby5waHlzaWNhbFBpeGVsU2l6ZTtcbiAgICB0aGlzLnRpY2tNYXJrUGh5c2ljYWxMZW5ndGggPSAxO1xuICAgIHRoaXMuc2V0Vm94ZWxTaXplKHRoaXMucGh5c2ljYWxQaXhlbFNpemUpO1xuICAgIHRoaXMubnVtQ2hhbm5lbHMgPSB0aGlzLmltYWdlSW5mby5udW1DaGFubmVscztcbiAgICB0aGlzLmNoYW5uZWxOYW1lcyA9IHRoaXMuaW1hZ2VJbmZvLmNoYW5uZWxOYW1lcy5zbGljZSgpO1xuICAgIHRoaXMuY2hhbm5lbENvbG9yc0RlZmF1bHQgPSB0aGlzLmltYWdlSW5mby5jaGFubmVsQ29sb3JzID8gdGhpcy5pbWFnZUluZm8uY2hhbm5lbENvbG9ycy5zbGljZSgpIDogdGhpcy5jaGFubmVsTmFtZXMubWFwKChuYW1lLCBpbmRleCkgPT4gZ2V0Q29sb3JCeUNoYW5uZWxJbmRleChpbmRleCkpO1xuICAgIC8vIGZpbGwgaW4gZ2Fwc1xuICAgIGlmICh0aGlzLmNoYW5uZWxDb2xvcnNEZWZhdWx0Lmxlbmd0aCA8IHRoaXMuaW1hZ2VJbmZvLm51bUNoYW5uZWxzKSB7XG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGFubmVsQ29sb3JzRGVmYXVsdC5sZW5ndGggLSAxOyBpIDwgdGhpcy5pbWFnZUluZm8ubnVtQ2hhbm5lbHM7ICsraSkge1xuICAgICAgICB0aGlzLmNoYW5uZWxDb2xvcnNEZWZhdWx0W2ldID0gZ2V0Q29sb3JCeUNoYW5uZWxJbmRleChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jaGFubmVscyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbWFnZUluZm8ubnVtQ2hhbm5lbHM7ICsraSkge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IG5ldyBDaGFubmVsKHRoaXMuY2hhbm5lbE5hbWVzW2ldKTtcbiAgICAgIHRoaXMuY2hhbm5lbHMucHVzaChjaGFubmVsKTtcbiAgICAgIC8vIFRPRE8gcGFzcyBpbiBjaGFubmVsIGNvbnN0cnVjdG9yLi4uXG4gICAgICBjaGFubmVsLmRpbXMgPSB0aGlzLmltYWdlSW5mby5zdWJyZWdpb25TaXplLnRvQXJyYXkoKTtcbiAgICB9XG4gICAgdGhpcy5waHlzaWNhbFVuaXRTeW1ib2wgPSB0aGlzLmltYWdlSW5mby5zcGF0aWFsVW5pdDtcbiAgICB0aGlzLnZvbHVtZURhdGFPYnNlcnZlcnMgPSBbXTtcbiAgfVxuICBzZXRVbmxvYWRlZCgpIHtcbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaChjaGFubmVsID0+IHtcbiAgICAgIGNoYW5uZWwubG9hZGVkID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbiAgaXNMb2FkZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGVkO1xuICB9XG4gIHVwZGF0ZURpbWVuc2lvbnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm9sdW1lU2l6ZSxcbiAgICAgIHN1YnJlZ2lvblNpemUsXG4gICAgICBzdWJyZWdpb25PZmZzZXRcbiAgICB9ID0gdGhpcy5pbWFnZUluZm87XG4gICAgdGhpcy5zZXRWb3hlbFNpemUodGhpcy5waHlzaWNhbFBpeGVsU2l6ZSk7XG4gICAgdGhpcy5ub3JtUmVnaW9uU2l6ZSA9IHN1YnJlZ2lvblNpemUuY2xvbmUoKS5kaXZpZGUodm9sdW1lU2l6ZSk7XG4gICAgdGhpcy5ub3JtUmVnaW9uT2Zmc2V0ID0gc3VicmVnaW9uT2Zmc2V0LmNsb25lKCkuZGl2aWRlKHZvbHVtZVNpemUpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgYHRydWVgIGlmZiBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBsb2FkU3BlY2AgYW5kIGBsb2FkU3BlY1JlcXVpcmVkYCBpbmRpY2F0ZSBuZXcgZGF0YSAqbXVzdCogYmUgbG9hZGVkLiAqL1xuICBtdXN0TG9hZE5ld0RhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZFNwZWMudGltZSAhPT0gdGhpcy5sb2FkU3BlY1JlcXVpcmVkLnRpbWUgfHxcbiAgICAvLyB0aW1lIHBvaW50IGNoYW5nZWRcbiAgICAhdGhpcy5sb2FkU3BlYy5zdWJyZWdpb24uY29udGFpbnNCb3godGhpcy5sb2FkU3BlY1JlcXVpcmVkLnN1YnJlZ2lvbikgfHxcbiAgICAvLyBuZXcgc3VicmVnaW9uIG5vdCBjb250YWluZWQgaW4gb2xkXG4gICAgdGhpcy5sb2FkU3BlY1JlcXVpcmVkLmNoYW5uZWxzLnNvbWUoY2hhbm5lbCA9PiAhdGhpcy5sb2FkU3BlYy5jaGFubmVscy5pbmNsdWRlcyhjaGFubmVsKSkgLy8gbmV3IGNoYW5uZWwocylcbiAgICA7XG4gIH1cblxuICAvKipcclxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZmYgZGlmZmVyZW5jZXMgYmV0d2VlbiBgbG9hZFNwZWNgIGFuZCBgbG9hZFNwZWNSZXF1aXJlZGAgaW5kaWNhdGUgYSBuZXcgbG9hZCAqbWF5KiBnZXQgYVxyXG4gICAqIGRpZmZlcmVudCBzY2FsZSBsZXZlbCB0aGFuIGlzIGN1cnJlbnRseSBsb2FkZWQuXHJcbiAgICpcclxuICAgKiBUaGlzIGNoZWNrcyBmb3IgY2hhbmdlcyBpbiBwcm9wZXJ0aWVzIHRoYXQgKmNhbiosIGJ1dCBkbyBub3QgKmFsd2F5cyosIGNoYW5nZSB0aGUgc2NhbGUgbGV2ZWwgdGhlIGxvYWRlciBwaWNrcy5cclxuICAgKiBGb3IgZXhhbXBsZSwgYSBzbWFsbGVyIGBzdWJyZWdpb25gICptYXkqIG1lYW4gYSBoaWdoZXIgc2NhbGUgbGV2ZWwgd2lsbCBmaXQgd2l0aGluIG1lbW9yeSBjb25zdHJhaW50cywgb3IgaXQgbWF5XHJcbiAgICogbm90LiBBIGhpZ2hlciBgc2NhbGVMZXZlbEJpYXNgICptYXkqIG51ZGdlIHRoZSB2b2x1bWUgaW50byBhIGhpZ2hlciBzY2FsZSBsZXZlbCwgb3Igd2UgbWF5IGFscmVhZHkgYmUgYXQgdGhlIG1heFxyXG4gICAqIGltcG9zZWQgYnkgYG11bHRpc2NhbGVMZXZlbGAuXHJcbiAgICovXG4gIG1heUxvYWROZXdTY2FsZUxldmVsKCkge1xuICAgIHJldHVybiAhdGhpcy5sb2FkU3BlYy5zdWJyZWdpb24uZXF1YWxzKHRoaXMubG9hZFNwZWNSZXF1aXJlZC5zdWJyZWdpb24pIHx8IHRoaXMubG9hZFNwZWNSZXF1aXJlZC5tYXhBdGxhc0VkZ2UgIT09IHRoaXMubG9hZFNwZWMubWF4QXRsYXNFZGdlIHx8IHRoaXMubG9hZFNwZWNSZXF1aXJlZC5tdWx0aXNjYWxlTGV2ZWwgIT09IHRoaXMubG9hZFNwZWMubXVsdGlzY2FsZUxldmVsIHx8IHRoaXMubG9hZFNwZWNSZXF1aXJlZC5zY2FsZUxldmVsQmlhcyAhPT0gdGhpcy5sb2FkU3BlYy5zY2FsZUxldmVsQmlhcztcbiAgfVxuXG4gIC8qKiBDYWxsIG9uIGFueSBzdGF0ZSB1cGRhdGUgdGhhdCBtYXkgcmVxdWlyZSBuZXcgZGF0YSB0byBiZSBsb2FkZWQgKHN1YnJlZ2lvbiwgZW5hYmxlZCBjaGFubmVscywgdGltZSwgZXRjLikgKi9cbiAgYXN5bmMgdXBkYXRlUmVxdWlyZWREYXRhKHJlcXVpcmVkLCBvbkNoYW5uZWxMb2FkZWQpIHtcbiAgICB0aGlzLmxvYWRTcGVjUmVxdWlyZWQgPSB7XG4gICAgICAuLi50aGlzLmxvYWRTcGVjUmVxdWlyZWQsXG4gICAgICAuLi5yZXF1aXJlZFxuICAgIH07XG4gICAgbGV0IHNob3VsZFJlbG9hZCA9IHRoaXMubXVzdExvYWROZXdEYXRhKCk7XG5cbiAgICAvLyBJZiB3ZSdyZSBub3QgcmVsb2FkaW5nIGR1ZSB0byByZXF1aXJlZCBkYXRhIGNoYW5nZXMsIGNoZWNrIGlmIHdlIHNob3VsZCBsb2FkIGEgbmV3IHNjYWxlIGxldmVsXG4gICAgaWYgKCFzaG91bGRSZWxvYWQgJiYgdGhpcy5tYXlMb2FkTmV3U2NhbGVMZXZlbCgpKSB7XG4gICAgICAvLyBMb2FkZXJzIHNob3VsZCBjYWNoZSBsb2FkZWQgZGltZW5zaW9ucyBzbyB0aGF0IHRoaXMgY2FsbCBibG9ja3Mgbm8gbW9yZSB0aGFuIG9uY2UgcGVyIHZhbGlkIGBMb2FkU3BlY2AuXG4gICAgICBjb25zdCBkaW1zID0gYXdhaXQgdGhpcy5sb2FkU2NhbGVMZXZlbERpbXMoKTtcbiAgICAgIGlmIChkaW1zKSB7XG4gICAgICAgIGNvbnN0IGRpbXNaWVggPSBkaW1zLm1hcCgoe1xuICAgICAgICAgIHNoYXBlXG4gICAgICAgIH0pID0+IFtzaGFwZVsyXSwgc2hhcGVbM10sIHNoYXBlWzRdXSk7XG4gICAgICAgIC8vIERldGVybWluZSB3aGljaCBzY2FsZSBsZXZlbCAqd291bGQqIGJlIGxvYWRlZCwgYW5kIHNlZSBpZiBpdCdzIGRpZmZlcmVudCB0aGFuIHdoYXQgd2UgaGF2ZVxuICAgICAgICBjb25zdCBsZXZlbFRvTG9hZCA9IHBpY2tMZXZlbFRvTG9hZFVuc2NhbGVkKHRoaXMubG9hZFNwZWNSZXF1aXJlZCwgZGltc1pZWCk7XG4gICAgICAgIHNob3VsZFJlbG9hZCA9IHRoaXMuaW1hZ2VJbmZvLm11bHRpc2NhbGVMZXZlbCAhPT0gbGV2ZWxUb0xvYWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRSZWxvYWQpIHtcbiAgICAgIHRoaXMubG9hZE5ld0RhdGEob25DaGFubmVsTG9hZGVkKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgbG9hZFNjYWxlTGV2ZWxEaW1zKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2FkZXI/LmxvYWREaW1zKHRoaXMubG9hZFNwZWNSZXF1aXJlZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy52b2x1bWVEYXRhT2JzZXJ2ZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4gb2JzZXJ2ZXIub25Wb2x1bWVMb2FkRXJyb3IodGhpcywgZSkpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcclxuICAgKiBMb2FkcyBuZXcgZGF0YSBhcyBzcGVjaWZpZWQgaW4gYHRoaXMubG9hZFNwZWNSZXF1aXJlZGAuIENsb25lcyBgbG9hZFNwZWNSZXF1aXJlZGAgaW50byBgbG9hZFNwZWNgIHRvIGluZGljYXRlXHJcbiAgICogdGhhdCB0aGUgZGF0YSB0aGF0ICptdXN0KiBiZSBsb2FkZWQgaXMgbm93IHRoZSBkYXRhIHRoYXQgKmhhcyogYmVlbiBsb2FkZWQuXHJcbiAgICovXG4gIGFzeW5jIGxvYWROZXdEYXRhKG9uQ2hhbm5lbExvYWRlZCkge1xuICAgIHRoaXMuc2V0VW5sb2FkZWQoKTtcbiAgICB0aGlzLmxvYWRTcGVjID0ge1xuICAgICAgLi4udGhpcy5sb2FkU3BlY1JlcXVpcmVkLFxuICAgICAgc3VicmVnaW9uOiB0aGlzLmxvYWRTcGVjUmVxdWlyZWQuc3VicmVnaW9uLmNsb25lKClcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmxvYWRlcj8ubG9hZFZvbHVtZURhdGEodGhpcywgdW5kZWZpbmVkLCBvbkNoYW5uZWxMb2FkZWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMudm9sdW1lRGF0YU9ic2VydmVycy5mb3JFYWNoKG9ic2VydmVyID0+IG9ic2VydmVyLm9uVm9sdW1lTG9hZEVycm9yKHRoaXMsIGUpKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgLy8gd2UgY2FsY3VsYXRlIHRoZSBwaHlzaWNhbCBzaXplIG9mIHRoZSB2b2x1bWUgKHZveGVscypwaXhlbF9zaXplKVxuICAvLyBhbmQgdGhlbiBub3JtYWxpemUgdG8gdGhlIG1heCBwaHlzaWNhbCBkaW1lbnNpb25cbiAgc2V0Vm94ZWxTaXplKHNpemUpIHtcbiAgICAvLyBvbmx5IHNldCB0aGUgZGF0YSBpZiBpdCBpcyA+IDAuICB6ZXJvIGlzIG5vdCBhbiBhbGxvd2VkIHZhbHVlLlxuICAgIHNpemUueCA9IHNpemUueCA+IDAgPyBzaXplLnggOiAxLjA7XG4gICAgc2l6ZS55ID0gc2l6ZS55ID4gMCA/IHNpemUueSA6IDEuMDtcbiAgICBzaXplLnogPSBzaXplLnogPiAwID8gc2l6ZS56IDogMS4wO1xuICAgIHRoaXMucGh5c2ljYWxQaXhlbFNpemUgPSBzaXplO1xuICAgIHRoaXMucGh5c2ljYWxTaXplID0gdGhpcy5pbWFnZUluZm8ub3JpZ2luYWxTaXplLmNsb25lKCkubXVsdGlwbHkodGhpcy5waHlzaWNhbFBpeGVsU2l6ZSk7XG4gICAgLy8gVm9sdW1lIGlzIHNjYWxlZCBzdWNoIHRoYXQgaXRzIGxhcmdlc3QgcGh5c2ljYWwgZGltZW5zaW9uIGlzIDEgd29ybGQgdW5pdCAtIHNhdmUgdGhhdCBkaW1lbnNpb24gZm9yIGNvbnZlcnNpb25zXG4gICAgdGhpcy5waHlzaWNhbFNjYWxlID0gTWF0aC5tYXgodGhpcy5waHlzaWNhbFNpemUueCwgdGhpcy5waHlzaWNhbFNpemUueSwgdGhpcy5waHlzaWNhbFNpemUueik7XG4gICAgLy8gQ29tcHV0ZSB0aGUgdm9sdW1lJ3MgbWF4IGV4dGVudCAtIHNjYWxlZCB0byBtYXggZGltZW5zaW9uLlxuICAgIHRoaXMubm9ybVBoeXNpY2FsU2l6ZSA9IHRoaXMucGh5c2ljYWxTaXplLmNsb25lKCkuZGl2aWRlU2NhbGFyKHRoaXMucGh5c2ljYWxTY2FsZSk7XG4gICAgLy8gV2hpbGUgd2UncmUgaGVyZSwgcGljayBhIHBvd2VyIG9mIDEwIHRoYXQgZGl2aWRlcyBpbnRvIG91ciBtYXggZGltZW5zaW9uIGEgcmVhc29uYWJsZSBudW1iZXIgb2YgdGltZXNcbiAgICAvLyBhbmQgc2F2ZSBpdCB0byBiZSB0aGUgbGVuZ3RoIG9mIHRpY2sgbWFya3MgaW4gM2QuXG4gICAgdGhpcy50aWNrTWFya1BoeXNpY2FsTGVuZ3RoID0gMTAgKiogTWF0aC5mbG9vcihNYXRoLmxvZzEwKHRoaXMucGh5c2ljYWxTY2FsZSAvIDIpKTtcbiAgfVxuICBzZXRVbml0U3ltYm9sKHN5bWJvbCkge1xuICAgIHRoaXMucGh5c2ljYWxVbml0U3ltYm9sID0gc3ltYm9sO1xuICB9XG5cbiAgLyoqIENvbXB1dGVzIHRoZSBjZW50ZXIgb2YgdGhlIHZvbHVtZSBzdWJzZXQgKi9cbiAgZ2V0Q29udGVudENlbnRlcigpIHtcbiAgICAvLyBjZW50ZXIgcG9pbnQ6IChub3JtUmVnaW9uU2l6ZSAvIDIgKyBub3JtUmVnaW9uT2Zmc2V0IC0gMC41KSAqIG5vcm1QaHlzaWNhbFNpemU7XG4gICAgcmV0dXJuIHRoaXMubm9ybVJlZ2lvblNpemUuY2xvbmUoKS5kaXZpZGVTY2FsYXIoMikuYWRkKHRoaXMubm9ybVJlZ2lvbk9mZnNldCkuc3ViU2NhbGFyKDAuNSkubXVsdGlwbHkodGhpcy5ub3JtUGh5c2ljYWxTaXplKTtcbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIC8vIG5vIG9wXG4gIH1cbiAgZ2V0Q2hhbm5lbChjaGFubmVsSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsc1tjaGFubmVsSW5kZXhdO1xuICB9XG4gIG9uQ2hhbm5lbExvYWRlZChiYXRjaCkge1xuICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBhbGwgY2hhbm5lbHMgYXJlIG5vdyBsb2FkZWQsIGFuZCBmaXJlIGFuIGV2ZW50KD8pXG4gICAgaWYgKHRoaXMubG9hZFNwZWMuY2hhbm5lbHMuZXZlcnkoY2hhbm5lbEluZGV4ID0+IHRoaXMuY2hhbm5lbHNbY2hhbm5lbEluZGV4XS5sb2FkZWQpKSB7XG4gICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgfVxuICAgIGJhdGNoLmZvckVhY2goY2hhbm5lbEluZGV4ID0+IHRoaXMuY2hhbm5lbExvYWRDYWxsYmFjaz8uKHRoaXMsIGNoYW5uZWxJbmRleCkpO1xuICAgIHRoaXMudm9sdW1lRGF0YU9ic2VydmVycy5mb3JFYWNoKG9ic2VydmVyID0+IG9ic2VydmVyLm9uVm9sdW1lRGF0YSh0aGlzLCBiYXRjaCkpO1xuICB9XG5cbiAgLyoqXHJcbiAgICogQXNzaWduIHZvbHVtZSBkYXRhIHZpYSBhIDJkIGFycmF5IGNvbnRhaW5pbmcgdGhlIHogc2xpY2VzIGFzIHRpbGVzIGFjcm9zcyBpdC4gIEFzc3VtZXMgdGhhdCB0aGUgaW5jb21pbmcgZGF0YSBpcyBjb25zaXN0ZW50IHdpdGggdGhlIGltYWdlJ3MgcHJlLWV4aXN0aW5nIGltYWdlSW5mbyB0aWxlIG1ldGFkYXRhLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFubmVsSW5kZXhcclxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGF0bGFzZGF0YVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhdGxhc3dpZHRoXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGF0bGFzaGVpZ2h0XHJcbiAgICovXG4gIHNldENoYW5uZWxEYXRhRnJvbUF0bGFzKGNoYW5uZWxJbmRleCwgYXRsYXNkYXRhLCBhdGxhc3dpZHRoLCBhdGxhc2hlaWdodCkge1xuICAgIHRoaXMuY2hhbm5lbHNbY2hhbm5lbEluZGV4XS5zZXRCaXRzKGF0bGFzZGF0YSwgYXRsYXN3aWR0aCwgYXRsYXNoZWlnaHQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgelxuICAgIH0gPSB0aGlzLmltYWdlSW5mby5zdWJyZWdpb25TaXplO1xuICAgIHRoaXMuY2hhbm5lbHNbY2hhbm5lbEluZGV4XS51bnBhY2tWb2x1bWVGcm9tQXRsYXMoeCwgeSwgeik7XG4gICAgdGhpcy5vbkNoYW5uZWxMb2FkZWQoW2NoYW5uZWxJbmRleF0pO1xuICB9XG5cbiAgLy8gQVNTVU1FUyB0aGF0IHRoaXMuY2hhbm5lbERhdGEub3B0aW9ucyBpcyBhbHJlYWR5IHNldCBhbmQgaW5jb21pbmcgZGF0YSBpcyBjb25zaXN0ZW50IHdpdGggaXRcbiAgLyoqXHJcbiAgICogQXNzaWduIHZvbHVtZSBkYXRhIGFzIGEgM2QgYXJyYXkgb3JkZXJlZCB4LHksei4gVGhlIHh5IHNpemUgbXVzdCBiZSBlcXVhbCB0byB0aWxld2lkdGgqdGlsZWhlaWdodCBmcm9tIHRoZSBpbWFnZUluZm8gdXNlZCB0byBjb25zdHJ1Y3QgdGhpcyBWb2x1bWUuICBBc3N1bWVzIHRoYXQgdGhlIGluY29taW5nIGRhdGEgaXMgY29uc2lzdGVudCB3aXRoIHRoZSBpbWFnZSdzIHByZS1leGlzdGluZyBpbWFnZUluZm8gdGlsZSBtZXRhZGF0YS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbEluZGV4XHJcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB2b2x1bWVEYXRhXHJcbiAgICovXG4gIHNldENoYW5uZWxEYXRhRnJvbVZvbHVtZShjaGFubmVsSW5kZXgsIHZvbHVtZURhdGEsIHJhbmdlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3VicmVnaW9uU2l6ZSxcbiAgICAgIGF0bGFzVGlsZURpbXNcbiAgICB9ID0gdGhpcy5pbWFnZUluZm87XG4gICAgdGhpcy5jaGFubmVsc1tjaGFubmVsSW5kZXhdLnNldEZyb21Wb2x1bWVEYXRhKHZvbHVtZURhdGEsIHN1YnJlZ2lvblNpemUueCwgc3VicmVnaW9uU2l6ZS55LCBzdWJyZWdpb25TaXplLnosIGF0bGFzVGlsZURpbXMueCAqIHN1YnJlZ2lvblNpemUueCwgYXRsYXNUaWxlRGltcy55ICogc3VicmVnaW9uU2l6ZS55LCByYW5nZVswXSwgcmFuZ2VbMV0pO1xuICAgIHRoaXMub25DaGFubmVsTG9hZGVkKFtjaGFubmVsSW5kZXhdKTtcbiAgfVxuXG4gIC8vIFRPRE86IGRlY2lkZSBpZiB0aGlzIHNob3VsZCB1cGRhdGUgaW1hZ2VJbmZvIG9yIG5vdC4gRm9yIG5vdywgbGVhdmUgaW1hZ2VJbmZvIGFsb25lIGFzIHRoZSBcIm9yaWdpbmFsXCIgZGF0YVxuICAvKipcclxuICAgKiBBZGQgYSBuZXcgY2hhbm5lbCByZWFkeSB0byByZWNlaXZlIGRhdGEgZnJvbSBvbmUgb2YgdGhlIHNldENoYW5uZWxEYXRhRnJvbSogY2FsbHMuXHJcbiAgICogTmFtZSBhbmQgY29sb3Igd2lsbCBiZSBkZWZhdWx0ZWQgaWYgbm90IHByb3ZpZGVkLiBGb3Igbm93LCBsZWF2ZSBpbWFnZUluZm8gYWxvbmUgYXMgdGhlIFwib3JpZ2luYWxcIiBkYXRhXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBjb2xvciBbcixnLGJdXHJcbiAgICovXG4gIGFwcGVuZEVtcHR5Q2hhbm5lbChuYW1lLCBjb2xvcikge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuaW1hZ2VJbmZvLm51bUNoYW5uZWxzO1xuICAgIGNvbnN0IGNobmFtZSA9IG5hbWUgfHwgXCJjaGFubmVsX1wiICsgaWR4O1xuICAgIGNvbnN0IGNoY29sb3IgPSBjb2xvciB8fCBnZXRDb2xvckJ5Q2hhbm5lbEluZGV4KGlkeCk7XG4gICAgdGhpcy5udW1DaGFubmVscyArPSAxO1xuICAgIHRoaXMuY2hhbm5lbE5hbWVzLnB1c2goY2huYW1lKTtcbiAgICB0aGlzLmNoYW5uZWxDb2xvcnNEZWZhdWx0LnB1c2goY2hjb2xvcik7XG4gICAgdGhpcy5jaGFubmVscy5wdXNoKG5ldyBDaGFubmVsKGNobmFtZSkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52b2x1bWVEYXRhT2JzZXJ2ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICB0aGlzLnZvbHVtZURhdGFPYnNlcnZlcnNbaV0ub25Wb2x1bWVDaGFubmVsQWRkZWQodGhpcywgaWR4KTtcbiAgICB9XG4gICAgcmV0dXJuIGlkeDtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEdldCBhIHZhbHVlIGZyb20gdGhlIHZvbHVtZSBkYXRhXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW50ZW5zaXR5IHZhbHVlIGZyb20gdGhlIGdpdmVuIGNoYW5uZWwgYXQgdGhlIGdpdmVuIHh5eiBsb2NhdGlvblxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjIFRoZSBjaGFubmVsIGluZGV4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6XHJcbiAgICovXG4gIGdldEludGVuc2l0eShjLCB4LCB5LCB6KSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbY10uZ2V0SW50ZW5zaXR5KHgsIHksIHopO1xuICB9XG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSAyNTYtYmluIGhpc3RvZ3JhbSBmb3IgdGhlIGdpdmVuIGNoYW5uZWxcclxuICAgKiBAcmV0dXJuIHtIaXN0b2dyYW19IHRoZSBoaXN0b2dyYW1cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYyBUaGUgY2hhbm5lbCBpbmRleFxyXG4gICAqL1xuICBnZXRIaXN0b2dyYW0oYykge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWxzW2NdLmdldEhpc3RvZ3JhbSgpO1xuICB9XG5cbiAgLyoqXHJcbiAgICogU2V0IHRoZSBsdXQgZm9yIHRoZSBnaXZlbiBjaGFubmVsXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGMgVGhlIGNoYW5uZWwgaW5kZXhcclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBsdXQgVGhlIGx1dCBhcyBhIDI1NiBlbGVtZW50IGFycmF5XHJcbiAgICovXG4gIHNldEx1dChjLCBsdXQpIHtcbiAgICB0aGlzLmNoYW5uZWxzW2NdLnNldEx1dChsdXQpO1xuICB9XG5cbiAgLyoqXHJcbiAgICogU2V0IHRoZSBjb2xvciBwYWxldHRlIGZvciB0aGUgZ2l2ZW4gY2hhbm5lbFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjIFRoZSBjaGFubmVsIGluZGV4XHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcGFsZXR0ZSBUaGUgY29sb3JzIGFzIGEgMjU2IGVsZW1lbnQgYXJyYXkgKiBSR0JBXHJcbiAgICovXG4gIHNldENvbG9yUGFsZXR0ZShjLCBwYWxldHRlKSB7XG4gICAgdGhpcy5jaGFubmVsc1tjXS5zZXRDb2xvclBhbGV0dGUocGFsZXR0ZSk7XG4gIH1cblxuICAvKipcclxuICAgKiBTZXQgdGhlIGNvbG9yIHBhbGV0dGUgYWxwaGEgbXVsdGlwbGllciBmb3IgdGhlIGdpdmVuIGNoYW5uZWwuXHJcbiAgICogVGhpcyB3aWxsIGJsZW5kIGJldHdlZW4gdGhlIG9yZGluYXJ5IGNvbG9yIGx1dCBhbmQgdGhpcyBjb2xvclBhbGV0dGUgbHV0LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjIFRoZSBjaGFubmVsIGluZGV4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFscGhhIFRoZSBhbHBoYSB2YWx1ZSBhcyBhIG51bWJlciBmcm9tIDAgdG8gMVxyXG4gICAqL1xuICBzZXRDb2xvclBhbGV0dGVBbHBoYShjLCBhbHBoYSkge1xuICAgIHRoaXMuY2hhbm5lbHNbY10uc2V0Q29sb3JQYWxldHRlQWxwaGEoYWxwaGEpO1xuICB9XG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBpbnRyaW5zaWMgcm90YXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgdm9sdW1lIChyYWRpYW5zKVxyXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSB0aGUgeHl6IEV1bGVyIGFuZ2xlcyAocmFkaWFucylcclxuICAgKi9cbiAgZ2V0Um90YXRpb24oKSB7XG4gICAgLy8gZGVmYXVsdCBheGlzIG9yZGVyIGlzIFhZWlxuICAgIHJldHVybiB0aGlzLmltYWdlSW5mby50cmFuc2Zvcm0ucm90YXRpb24udG9BcnJheSgpO1xuICB9XG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBpbnRyaW5zaWMgdHJhbnNsYXRpb24gKHBpdm90IGNlbnRlciBkZWx0YSkgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdm9sdW1lLCBpbiBub3JtYWxpemVkIHZvbHVtZSB1bml0c1xyXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSB0aGUgeHl6IHRyYW5zbGF0aW9uIGluIG5vcm1hbGl6ZWQgdm9sdW1lIHVuaXRzXHJcbiAgICovXG4gIGdldFRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnZveGVsc1RvV29ybGRTcGFjZSh0aGlzLmltYWdlSW5mby50cmFuc2Zvcm0udHJhbnNsYXRpb24udG9BcnJheSgpKTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIHRyYW5zbGF0aW9uIGluIG5vcm1hbGl6ZWQgdm9sdW1lIHVuaXRzLCBnaXZlbiBhIHRyYW5zbGF0aW9uIGluIGltYWdlIHZveGVsc1xyXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSB0aGUgeHl6IHRyYW5zbGF0aW9uIGluIG5vcm1hbGl6ZWQgdm9sdW1lIHVuaXRzXHJcbiAgICovXG4gIHZveGVsc1RvV29ybGRTcGFjZSh4eXopIHtcbiAgICAvLyBBU1NVTUU6IHRyYW5zbGF0aW9uIGlzIGluIG9yaWdpbmFsIGltYWdlIHZveGVscy5cbiAgICAvLyBhY2NvdW50IGZvciBwaXhlbF9zaXplIGFuZCBub3JtYWxpemVkIHNjYWxpbmcgaW4gdGhlIHRocmVlanMgdm9sdW1lIHJlcHJlc2VudGF0aW9uIHdlJ3JlIHVzaW5nXG4gICAgY29uc3QgbSA9IDEuMCAvIE1hdGgubWF4KHRoaXMucGh5c2ljYWxTaXplLngsIE1hdGgubWF4KHRoaXMucGh5c2ljYWxTaXplLnksIHRoaXMucGh5c2ljYWxTaXplLnopKTtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoeHl6KS5tdWx0aXBseSh0aGlzLnBoeXNpY2FsUGl4ZWxTaXplKS5tdWx0aXBseVNjYWxhcihtKS50b0FycmF5KCk7XG4gIH1cbiAgYWRkVm9sdW1lRGF0YU9ic2VydmVyKG8pIHtcbiAgICB0aGlzLnZvbHVtZURhdGFPYnNlcnZlcnMucHVzaChvKTtcbiAgfVxuICByZW1vdmVWb2x1bWVEYXRhT2JzZXJ2ZXIobykge1xuICAgIGlmIChvKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy52b2x1bWVEYXRhT2JzZXJ2ZXJzLmluZGV4T2Yobyk7XG4gICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy52b2x1bWVEYXRhT2JzZXJ2ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVtb3ZlQWxsVm9sdW1lRGF0YU9ic2VydmVycygpIHtcbiAgICB0aGlzLnZvbHVtZURhdGFPYnNlcnZlcnMgPSBbXTtcbiAgfVxufSJdLCJuYW1lcyI6WyJWZWN0b3IyIiwiVmVjdG9yMyIsIkNoYW5uZWwiLCJnZXRDb2xvckJ5Q2hhbm5lbEluZGV4IiwiTG9hZFNwZWMiLCJNQVhfQVRMQVNfRURHRSIsInBpY2tMZXZlbFRvTG9hZFVuc2NhbGVkIiwiZ2V0RGVmYXVsdEltYWdlSW5mbyIsIm5hbWUiLCJvcmlnaW5hbFNpemUiLCJhdGxhc1RpbGVEaW1zIiwidm9sdW1lU2l6ZSIsInN1YnJlZ2lvblNpemUiLCJzdWJyZWdpb25PZmZzZXQiLCJwaHlzaWNhbFBpeGVsU2l6ZSIsInNwYXRpYWxVbml0IiwibnVtQ2hhbm5lbHMiLCJjaGFubmVsTmFtZXMiLCJjaGFubmVsQ29sb3JzIiwidGltZXMiLCJ0aW1lU2NhbGUiLCJ0aW1lVW5pdCIsIm51bU11bHRpc2NhbGVMZXZlbHMiLCJtdWx0aXNjYWxlTGV2ZWwiLCJ0cmFuc2Zvcm0iLCJ0cmFuc2xhdGlvbiIsInJvdGF0aW9uIiwiVm9sdW1lIiwiY29uc3RydWN0b3IiLCJpbWFnZUluZm8iLCJsb2FkU3BlYyIsImxvYWRlciIsImxvYWRlZCIsInNjYWxlTGV2ZWxCaWFzIiwibWF4QXRsYXNFZGdlIiwiY2hhbm5lbHMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfdmFsIiwiaWR4IiwibG9hZFNwZWNSZXF1aXJlZCIsInNsaWNlIiwic3VicmVnaW9uIiwiY2xvbmUiLCJpbWFnZU1ldGFkYXRhIiwibm9ybVJlZ2lvblNpemUiLCJub3JtUmVnaW9uT2Zmc2V0IiwicGh5c2ljYWxTaXplIiwicGh5c2ljYWxTY2FsZSIsIm5vcm1QaHlzaWNhbFNpemUiLCJ0aWNrTWFya1BoeXNpY2FsTGVuZ3RoIiwic2V0Vm94ZWxTaXplIiwiY2hhbm5lbENvbG9yc0RlZmF1bHQiLCJtYXAiLCJpbmRleCIsImkiLCJjaGFubmVsIiwicHVzaCIsImRpbXMiLCJ0b0FycmF5IiwicGh5c2ljYWxVbml0U3ltYm9sIiwidm9sdW1lRGF0YU9ic2VydmVycyIsInNldFVubG9hZGVkIiwiZm9yRWFjaCIsImlzTG9hZGVkIiwidXBkYXRlRGltZW5zaW9ucyIsImRpdmlkZSIsIm11c3RMb2FkTmV3RGF0YSIsInRpbWUiLCJjb250YWluc0JveCIsInNvbWUiLCJpbmNsdWRlcyIsIm1heUxvYWROZXdTY2FsZUxldmVsIiwiZXF1YWxzIiwidXBkYXRlUmVxdWlyZWREYXRhIiwicmVxdWlyZWQiLCJvbkNoYW5uZWxMb2FkZWQiLCJzaG91bGRSZWxvYWQiLCJsb2FkU2NhbGVMZXZlbERpbXMiLCJkaW1zWllYIiwic2hhcGUiLCJsZXZlbFRvTG9hZCIsImxvYWROZXdEYXRhIiwibG9hZERpbXMiLCJlIiwib2JzZXJ2ZXIiLCJvblZvbHVtZUxvYWRFcnJvciIsInVuZGVmaW5lZCIsImxvYWRWb2x1bWVEYXRhIiwic2l6ZSIsIngiLCJ5IiwieiIsIm11bHRpcGx5IiwiTWF0aCIsIm1heCIsImRpdmlkZVNjYWxhciIsImZsb29yIiwibG9nMTAiLCJzZXRVbml0U3ltYm9sIiwic3ltYm9sIiwiZ2V0Q29udGVudENlbnRlciIsImFkZCIsInN1YlNjYWxhciIsImNsZWFudXAiLCJnZXRDaGFubmVsIiwiY2hhbm5lbEluZGV4IiwiYmF0Y2giLCJldmVyeSIsImNoYW5uZWxMb2FkQ2FsbGJhY2siLCJvblZvbHVtZURhdGEiLCJzZXRDaGFubmVsRGF0YUZyb21BdGxhcyIsImF0bGFzZGF0YSIsImF0bGFzd2lkdGgiLCJhdGxhc2hlaWdodCIsInNldEJpdHMiLCJ1bnBhY2tWb2x1bWVGcm9tQXRsYXMiLCJzZXRDaGFubmVsRGF0YUZyb21Wb2x1bWUiLCJ2b2x1bWVEYXRhIiwicmFuZ2UiLCJzZXRGcm9tVm9sdW1lRGF0YSIsImFwcGVuZEVtcHR5Q2hhbm5lbCIsImNvbG9yIiwiY2huYW1lIiwiY2hjb2xvciIsIm9uVm9sdW1lQ2hhbm5lbEFkZGVkIiwiZ2V0SW50ZW5zaXR5IiwiYyIsImdldEhpc3RvZ3JhbSIsInNldEx1dCIsImx1dCIsInNldENvbG9yUGFsZXR0ZSIsInBhbGV0dGUiLCJzZXRDb2xvclBhbGV0dGVBbHBoYSIsImFscGhhIiwiZ2V0Um90YXRpb24iLCJnZXRUcmFuc2xhdGlvbiIsInZveGVsc1RvV29ybGRTcGFjZSIsInh5eiIsIm0iLCJmcm9tQXJyYXkiLCJtdWx0aXBseVNjYWxhciIsImFkZFZvbHVtZURhdGFPYnNlcnZlciIsIm8iLCJyZW1vdmVWb2x1bWVEYXRhT2JzZXJ2ZXIiLCJpbmRleE9mIiwic3BsaWNlIiwicmVtb3ZlQWxsVm9sdW1lRGF0YU9ic2VydmVycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../volume-viewer/es/Volume.js\n");

/***/ }),

/***/ "../volume-viewer/es/VolumeCache.js":
/*!******************************************!*\
  !*** ../volume-viewer/es/VolumeCache.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ VolumeCache)\n/* harmony export */ });\n/** Default: 250MB. Should be large enough to be useful but safe for most any computer that can run the app */\nconst CACHE_MAX_SIZE_DEFAULT = 250_000_000;\nclass VolumeCache {\n  // Ends of a linked list of entries, to track LRU and evict efficiently\n\n  // TODO implement some way to manage used vs unused (prefetched) entries so\n  // that prefetched entries which are never used don't get highest priority!\n\n  constructor(maxSize = CACHE_MAX_SIZE_DEFAULT) {\n    this.entries = new Map();\n    this.maxSize = maxSize;\n    this.currentSize = 0;\n    this.first = null;\n    this.last = null;\n  }\n\n  // Hide these behind getters so they're definitely never set from the outside\n  /** The size of all data arrays currently stored in this cache, in bytes. */\n  get size() {\n    return this.currentSize;\n  }\n\n  /** The number of entries currently stored in this cache. */\n  get numberOfEntries() {\n    return this.entries.size;\n  }\n\n  /**\r\n   * Removes an entry from a store but NOT the LRU list.\r\n   * Only call from a method with the word \"evict\" in it!\r\n   */\n  removeEntryFromStore(entry) {\n    this.entries.delete(entry.key);\n    this.currentSize -= entry.data.byteLength;\n  }\n\n  /**\r\n   * Removes an entry from the LRU list but NOT its store.\r\n   * Entry must be replaced in list or removed from store, or it will never be evicted!\r\n   */\n  removeEntryFromList(entry) {\n    const {\n      prev,\n      next\n    } = entry;\n    if (prev) {\n      prev.next = next;\n    } else {\n      this.first = next;\n    }\n    if (next) {\n      next.prev = prev;\n    } else {\n      this.last = prev;\n    }\n  }\n\n  /** Adds an entry which is *not currently in the list* to the front of the list. */\n  addEntryAsFirst(entry) {\n    if (this.first) {\n      this.first.prev = entry;\n    } else {\n      this.last = entry;\n    }\n    entry.next = this.first;\n    entry.prev = null;\n    this.first = entry;\n  }\n\n  /** Moves an entry which is *currently in the list* to the front of the list. */\n  moveEntryToFirst(entry) {\n    if (entry === this.first) return;\n    this.removeEntryFromList(entry);\n    this.addEntryAsFirst(entry);\n  }\n\n  /** Evicts the least recently used entry from the cache. */\n  evictLast() {\n    if (!this.last) {\n      console.error(\"VolumeCache: attempt to evict last entry from cache when no last entry is set\");\n      return;\n    }\n    this.removeEntryFromStore(this.last);\n    if (this.last.prev) {\n      this.last.prev.next = null;\n    }\n    this.last = this.last.prev;\n  }\n\n  /** Evicts a specific entry from the cache. */\n  evict(entry) {\n    this.removeEntryFromStore(entry);\n    this.removeEntryFromList(entry);\n  }\n\n  /**\r\n   * Adds a new entry to the cache.\r\n   * @returns {boolean} a boolean indicating whether the insertion succeeded.\r\n   */\n  insert(key, data) {\n    if (data.byteLength > this.maxSize) {\n      console.error(\"VolumeCache: attempt to insert a single entry larger than the cache\");\n      return false;\n    }\n\n    // Check if entry is already in cache\n    // This will move the entry to the front of the LRU list, if present\n    const getResult = this.getEntry(key);\n    if (getResult !== undefined) {\n      getResult.data = data;\n      return true;\n    }\n\n    // Add new entry to cache\n    const newEntry = {\n      data,\n      prev: null,\n      next: null,\n      key\n    };\n    this.addEntryAsFirst(newEntry);\n    this.entries.set(key, newEntry);\n    this.currentSize += data.byteLength;\n\n    // Evict until size is within limit\n    while (this.currentSize > this.maxSize) {\n      this.evictLast();\n    }\n    return true;\n  }\n\n  /** Internal implementation of `get`. Returns all entry metadata, not just the raw data. */\n  getEntry(key) {\n    const result = this.entries.get(key);\n    if (result) {\n      this.moveEntryToFirst(result);\n    }\n    return result;\n  }\n\n  /** Attempts to get a single entry from the cache. */\n  get(key) {\n    return this.getEntry(key)?.data;\n  }\n\n  /** Clears all cache entries whose keys begin with the specified prefix. */\n  clearWithPrefix(prefix) {\n    for (const [key, entry] of this.entries.entries()) {\n      if (key.startsWith(prefix)) {\n        this.evict(entry);\n      }\n    }\n  }\n\n  /** Clears all data from the cache. */\n  clear() {\n    while (this.last) {\n      this.evictLast();\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU0sRUFBRTtNQUNWLElBQUksQ0FBQ1gsZ0JBQWdCLENBQUNXLE1BQU0sQ0FBQztJQUMvQjtJQUNBLE9BQU9BLE1BQU07RUFDZjs7RUFFQTtFQUNBQyxHQUFHQSxDQUFDbkIsR0FBRyxFQUFFO0lBQ1AsT0FBTyxJQUFJLENBQUNjLFFBQVEsQ0FBQ2QsR0FBRyxDQUFDLEVBQUVDLElBQUk7RUFDakM7O0VBRUE7RUFDQW1CLGVBQWVBLENBQUNDLE1BQU0sRUFBRTtJQUN0QixLQUFLLE1BQU0sQ0FBQ3JCLEdBQUcsRUFBRUYsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDUixPQUFPLENBQUNBLE9BQU8sQ0FBQyxDQUFDLEVBQUU7TUFDakQsSUFBSVUsR0FBRyxDQUFDc0IsVUFBVSxDQUFDRCxNQUFNLENBQUMsRUFBRTtRQUMxQixJQUFJLENBQUNWLEtBQUssQ0FBQ2IsS0FBSyxDQUFDO01BQ25CO0lBQ0Y7RUFDRjs7RUFFQTtFQUNBeUIsS0FBS0EsQ0FBQSxFQUFHO0lBQ04sT0FBTyxJQUFJLENBQUM3QixJQUFJLEVBQUU7TUFDaEIsSUFBSSxDQUFDYyxTQUFTLENBQUMsQ0FBQztJQUNsQjtFQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4uL3ZvbHVtZS12aWV3ZXIvZXMvVm9sdW1lQ2FjaGUuanM/NGFlMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogRGVmYXVsdDogMjUwTUIuIFNob3VsZCBiZSBsYXJnZSBlbm91Z2ggdG8gYmUgdXNlZnVsIGJ1dCBzYWZlIGZvciBtb3N0IGFueSBjb21wdXRlciB0aGF0IGNhbiBydW4gdGhlIGFwcCAqL1xuY29uc3QgQ0FDSEVfTUFYX1NJWkVfREVGQVVMVCA9IDI1MF8wMDBfMDAwO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVm9sdW1lQ2FjaGUge1xuICAvLyBFbmRzIG9mIGEgbGlua2VkIGxpc3Qgb2YgZW50cmllcywgdG8gdHJhY2sgTFJVIGFuZCBldmljdCBlZmZpY2llbnRseVxuXG4gIC8vIFRPRE8gaW1wbGVtZW50IHNvbWUgd2F5IHRvIG1hbmFnZSB1c2VkIHZzIHVudXNlZCAocHJlZmV0Y2hlZCkgZW50cmllcyBzb1xuICAvLyB0aGF0IHByZWZldGNoZWQgZW50cmllcyB3aGljaCBhcmUgbmV2ZXIgdXNlZCBkb24ndCBnZXQgaGlnaGVzdCBwcmlvcml0eSFcblxuICBjb25zdHJ1Y3RvcihtYXhTaXplID0gQ0FDSEVfTUFYX1NJWkVfREVGQVVMVCkge1xuICAgIHRoaXMuZW50cmllcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLm1heFNpemUgPSBtYXhTaXplO1xuICAgIHRoaXMuY3VycmVudFNpemUgPSAwO1xuICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgIHRoaXMubGFzdCA9IG51bGw7XG4gIH1cblxuICAvLyBIaWRlIHRoZXNlIGJlaGluZCBnZXR0ZXJzIHNvIHRoZXkncmUgZGVmaW5pdGVseSBuZXZlciBzZXQgZnJvbSB0aGUgb3V0c2lkZVxuICAvKiogVGhlIHNpemUgb2YgYWxsIGRhdGEgYXJyYXlzIGN1cnJlbnRseSBzdG9yZWQgaW4gdGhpcyBjYWNoZSwgaW4gYnl0ZXMuICovXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTaXplO1xuICB9XG5cbiAgLyoqIFRoZSBudW1iZXIgb2YgZW50cmllcyBjdXJyZW50bHkgc3RvcmVkIGluIHRoaXMgY2FjaGUuICovXG4gIGdldCBudW1iZXJPZkVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcy5zaXplO1xuICB9XG5cbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhbiBlbnRyeSBmcm9tIGEgc3RvcmUgYnV0IE5PVCB0aGUgTFJVIGxpc3QuXHJcbiAgICogT25seSBjYWxsIGZyb20gYSBtZXRob2Qgd2l0aCB0aGUgd29yZCBcImV2aWN0XCIgaW4gaXQhXHJcbiAgICovXG4gIHJlbW92ZUVudHJ5RnJvbVN0b3JlKGVudHJ5KSB7XG4gICAgdGhpcy5lbnRyaWVzLmRlbGV0ZShlbnRyeS5rZXkpO1xuICAgIHRoaXMuY3VycmVudFNpemUgLT0gZW50cnkuZGF0YS5ieXRlTGVuZ3RoO1xuICB9XG5cbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhbiBlbnRyeSBmcm9tIHRoZSBMUlUgbGlzdCBidXQgTk9UIGl0cyBzdG9yZS5cclxuICAgKiBFbnRyeSBtdXN0IGJlIHJlcGxhY2VkIGluIGxpc3Qgb3IgcmVtb3ZlZCBmcm9tIHN0b3JlLCBvciBpdCB3aWxsIG5ldmVyIGJlIGV2aWN0ZWQhXHJcbiAgICovXG4gIHJlbW92ZUVudHJ5RnJvbUxpc3QoZW50cnkpIHtcbiAgICBjb25zdCB7XG4gICAgICBwcmV2LFxuICAgICAgbmV4dFxuICAgIH0gPSBlbnRyeTtcbiAgICBpZiAocHJldikge1xuICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maXJzdCA9IG5leHQ7XG4gICAgfVxuICAgIGlmIChuZXh0KSB7XG4gICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxhc3QgPSBwcmV2O1xuICAgIH1cbiAgfVxuXG4gIC8qKiBBZGRzIGFuIGVudHJ5IHdoaWNoIGlzICpub3QgY3VycmVudGx5IGluIHRoZSBsaXN0KiB0byB0aGUgZnJvbnQgb2YgdGhlIGxpc3QuICovXG4gIGFkZEVudHJ5QXNGaXJzdChlbnRyeSkge1xuICAgIGlmICh0aGlzLmZpcnN0KSB7XG4gICAgICB0aGlzLmZpcnN0LnByZXYgPSBlbnRyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXN0ID0gZW50cnk7XG4gICAgfVxuICAgIGVudHJ5Lm5leHQgPSB0aGlzLmZpcnN0O1xuICAgIGVudHJ5LnByZXYgPSBudWxsO1xuICAgIHRoaXMuZmlyc3QgPSBlbnRyeTtcbiAgfVxuXG4gIC8qKiBNb3ZlcyBhbiBlbnRyeSB3aGljaCBpcyAqY3VycmVudGx5IGluIHRoZSBsaXN0KiB0byB0aGUgZnJvbnQgb2YgdGhlIGxpc3QuICovXG4gIG1vdmVFbnRyeVRvRmlyc3QoZW50cnkpIHtcbiAgICBpZiAoZW50cnkgPT09IHRoaXMuZmlyc3QpIHJldHVybjtcbiAgICB0aGlzLnJlbW92ZUVudHJ5RnJvbUxpc3QoZW50cnkpO1xuICAgIHRoaXMuYWRkRW50cnlBc0ZpcnN0KGVudHJ5KTtcbiAgfVxuXG4gIC8qKiBFdmljdHMgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgZW50cnkgZnJvbSB0aGUgY2FjaGUuICovXG4gIGV2aWN0TGFzdCgpIHtcbiAgICBpZiAoIXRoaXMubGFzdCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIlZvbHVtZUNhY2hlOiBhdHRlbXB0IHRvIGV2aWN0IGxhc3QgZW50cnkgZnJvbSBjYWNoZSB3aGVuIG5vIGxhc3QgZW50cnkgaXMgc2V0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUVudHJ5RnJvbVN0b3JlKHRoaXMubGFzdCk7XG4gICAgaWYgKHRoaXMubGFzdC5wcmV2KSB7XG4gICAgICB0aGlzLmxhc3QucHJldi5uZXh0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5sYXN0ID0gdGhpcy5sYXN0LnByZXY7XG4gIH1cblxuICAvKiogRXZpY3RzIGEgc3BlY2lmaWMgZW50cnkgZnJvbSB0aGUgY2FjaGUuICovXG4gIGV2aWN0KGVudHJ5KSB7XG4gICAgdGhpcy5yZW1vdmVFbnRyeUZyb21TdG9yZShlbnRyeSk7XG4gICAgdGhpcy5yZW1vdmVFbnRyeUZyb21MaXN0KGVudHJ5KTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBuZXcgZW50cnkgdG8gdGhlIGNhY2hlLlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBpbnNlcnRpb24gc3VjY2VlZGVkLlxyXG4gICAqL1xuICBpbnNlcnQoa2V5LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuYnl0ZUxlbmd0aCA+IHRoaXMubWF4U2l6ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIlZvbHVtZUNhY2hlOiBhdHRlbXB0IHRvIGluc2VydCBhIHNpbmdsZSBlbnRyeSBsYXJnZXIgdGhhbiB0aGUgY2FjaGVcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgZW50cnkgaXMgYWxyZWFkeSBpbiBjYWNoZVxuICAgIC8vIFRoaXMgd2lsbCBtb3ZlIHRoZSBlbnRyeSB0byB0aGUgZnJvbnQgb2YgdGhlIExSVSBsaXN0LCBpZiBwcmVzZW50XG4gICAgY29uc3QgZ2V0UmVzdWx0ID0gdGhpcy5nZXRFbnRyeShrZXkpO1xuICAgIGlmIChnZXRSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZ2V0UmVzdWx0LmRhdGEgPSBkYXRhO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQWRkIG5ldyBlbnRyeSB0byBjYWNoZVxuICAgIGNvbnN0IG5ld0VudHJ5ID0ge1xuICAgICAgZGF0YSxcbiAgICAgIHByZXY6IG51bGwsXG4gICAgICBuZXh0OiBudWxsLFxuICAgICAga2V5XG4gICAgfTtcbiAgICB0aGlzLmFkZEVudHJ5QXNGaXJzdChuZXdFbnRyeSk7XG4gICAgdGhpcy5lbnRyaWVzLnNldChrZXksIG5ld0VudHJ5KTtcbiAgICB0aGlzLmN1cnJlbnRTaXplICs9IGRhdGEuYnl0ZUxlbmd0aDtcblxuICAgIC8vIEV2aWN0IHVudGlsIHNpemUgaXMgd2l0aGluIGxpbWl0XG4gICAgd2hpbGUgKHRoaXMuY3VycmVudFNpemUgPiB0aGlzLm1heFNpemUpIHtcbiAgICAgIHRoaXMuZXZpY3RMYXN0KCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGBnZXRgLiBSZXR1cm5zIGFsbCBlbnRyeSBtZXRhZGF0YSwgbm90IGp1c3QgdGhlIHJhdyBkYXRhLiAqL1xuICBnZXRFbnRyeShrZXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmVudHJpZXMuZ2V0KGtleSk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgdGhpcy5tb3ZlRW50cnlUb0ZpcnN0KHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKiogQXR0ZW1wdHMgdG8gZ2V0IGEgc2luZ2xlIGVudHJ5IGZyb20gdGhlIGNhY2hlLiAqL1xuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW50cnkoa2V5KT8uZGF0YTtcbiAgfVxuXG4gIC8qKiBDbGVhcnMgYWxsIGNhY2hlIGVudHJpZXMgd2hvc2Uga2V5cyBiZWdpbiB3aXRoIHRoZSBzcGVjaWZpZWQgcHJlZml4LiAqL1xuICBjbGVhcldpdGhQcmVmaXgocHJlZml4KSB7XG4gICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgdGhpcy5lbnRyaWVzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGtleS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgdGhpcy5ldmljdChlbnRyeSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIENsZWFycyBhbGwgZGF0YSBmcm9tIHRoZSBjYWNoZS4gKi9cbiAgY2xlYXIoKSB7XG4gICAgd2hpbGUgKHRoaXMubGFzdCkge1xuICAgICAgdGhpcy5ldmljdExhc3QoKTtcbiAgICB9XG4gIH1cbn0iXSwibmFtZXMiOlsiQ0FDSEVfTUFYX1NJWkVfREVGQVVMVCIsIlZvbHVtZUNhY2hlIiwiY29uc3RydWN0b3IiLCJtYXhTaXplIiwiZW50cmllcyIsIk1hcCIsImN1cnJlbnRTaXplIiwiZmlyc3QiLCJsYXN0Iiwic2l6ZSIsIm51bWJlck9mRW50cmllcyIsInJlbW92ZUVudHJ5RnJvbVN0b3JlIiwiZW50cnkiLCJkZWxldGUiLCJrZXkiLCJkYXRhIiwiYnl0ZUxlbmd0aCIsInJlbW92ZUVudHJ5RnJvbUxpc3QiLCJwcmV2IiwibmV4dCIsImFkZEVudHJ5QXNGaXJzdCIsIm1vdmVFbnRyeVRvRmlyc3QiLCJldmljdExhc3QiLCJjb25zb2xlIiwiZXJyb3IiLCJldmljdCIsImluc2VydCIsImdldFJlc3VsdCIsImdldEVudHJ5IiwidW5kZWZpbmVkIiwibmV3RW50cnkiLCJzZXQiLCJyZXN1bHQiLCJnZXQiLCJjbGVhcldpdGhQcmVmaXgiLCJwcmVmaXgiLCJzdGFydHNXaXRoIiwiY2xlYXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../volume-viewer/es/VolumeCache.js\n");

/***/ }),

/***/ "../volume-viewer/es/constants/colors.js":
/*!***********************************************!*\
  !*** ../volume-viewer/es/constants/colors.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultColors: () => (/* binding */ defaultColors),\n/* harmony export */   getColorByChannelIndex: () => (/* binding */ getColorByChannelIndex)\n/* harmony export */ });\nconst defaultColors = [[255, 0, 255], [255, 255, 255], [0, 255, 255]];\n// 0 <= (h, s, v) <= 1\n// returns 0 <= (r, g, b) <= 255 rounded to nearest integer\n// you can also pass in just one arg as an object of {h, s, v} props.\nfunction HSVtoRGB(h, s, v) {\n  let r, g, b;\n  let hh = 0;\n  if (arguments.length === 1) {\n    const hsv = h;\n    s = hsv.s, v = hsv.v, hh = hsv.h;\n  } else {\n    hh = h;\n  }\n  const i = Math.floor(hh * 6);\n  const f = hh * 6 - i;\n  const p = v * (1 - s);\n  const q = v * (1 - f * s);\n  const t = v * (1 - (1 - f) * s);\n  switch (i % 6) {\n    case 0:\n      r = v, g = t, b = p;\n      break;\n    case 1:\n      r = q, g = v, b = p;\n      break;\n    case 2:\n      r = p, g = v, b = t;\n      break;\n    case 3:\n      r = p, g = q, b = v;\n      break;\n    case 4:\n      r = t, g = p, b = v;\n      break;\n    case 5:\n      r = v, g = p, b = q;\n      break;\n  }\n  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n}\n\n// 1993 Park-Miller LCG\nfunction LCG(s) {\n  return function () {\n    s = Math.imul(48271, s) | 0 % 2147483647;\n    return (s & 2147483647) / 2147483648;\n  };\n}\n// Use it like so:\nconst myrand = LCG(123);\n\n// if index exceeds defaultColors start choosing random ones\n// returns [r,g,b] 0-255 range\nconst getColorByChannelIndex = index => {\n  if (!defaultColors[index]) {\n    defaultColors[index] = HSVtoRGB(myrand(), myrand() * 0.5 + 0.5, myrand() * 0.5 + 0.5);\n  }\n  return defaultColors[index];\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy9jb25zdGFudHMvY29sb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU8sTUFBTUEsYUFBYSxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsU0FBU0MsUUFBUUEsQ0FBQ0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRTtFQUN6QixJQUFJQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztFQUNYLElBQUlDLEVBQUUsR0FBRyxDQUFDO0VBQ1YsSUFBSUMsU0FBUyxDQUFDQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0lBQzFCLE1BQU1DLEdBQUcsR0FBR1QsQ0FBQztJQUNiQyxDQUFDLEdBQUdRLEdBQUcsQ0FBQ1IsQ0FBQyxFQUFFQyxDQUFDLEdBQUdPLEdBQUcsQ0FBQ1AsQ0FBQyxFQUFFSSxFQUFFLEdBQUdHLEdBQUcsQ0FBQ1QsQ0FBQztFQUNsQyxDQUFDLE1BQU07SUFDTE0sRUFBRSxHQUFHTixDQUFDO0VBQ1I7RUFDQSxNQUFNVSxDQUFDLEdBQUdDLElBQUksQ0FBQ0MsS0FBSyxDQUFDTixFQUFFLEdBQUcsQ0FBQyxDQUFDO0VBQzVCLE1BQU1PLENBQUMsR0FBR1AsRUFBRSxHQUFHLENBQUMsR0FBR0ksQ0FBQztFQUNwQixNQUFNSSxDQUFDLEdBQUdaLENBQUMsSUFBSSxDQUFDLEdBQUdELENBQUMsQ0FBQztFQUNyQixNQUFNYyxDQUFDLEdBQUdiLENBQUMsSUFBSSxDQUFDLEdBQUdXLENBQUMsR0FBR1osQ0FBQyxDQUFDO0VBQ3pCLE1BQU1lLENBQUMsR0FBR2QsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBR1csQ0FBQyxJQUFJWixDQUFDLENBQUM7RUFDL0IsUUFBUVMsQ0FBQyxHQUFHLENBQUM7SUFDWCxLQUFLLENBQUM7TUFDSlAsQ0FBQyxHQUFHRCxDQUFDLEVBQUVFLENBQUMsR0FBR1ksQ0FBQyxFQUFFWCxDQUFDLEdBQUdTLENBQUM7TUFDbkI7SUFDRixLQUFLLENBQUM7TUFDSlgsQ0FBQyxHQUFHWSxDQUFDLEVBQUVYLENBQUMsR0FBR0YsQ0FBQyxFQUFFRyxDQUFDLEdBQUdTLENBQUM7TUFDbkI7SUFDRixLQUFLLENBQUM7TUFDSlgsQ0FBQyxHQUFHVyxDQUFDLEVBQUVWLENBQUMsR0FBR0YsQ0FBQyxFQUFFRyxDQUFDLEdBQUdXLENBQUM7TUFDbkI7SUFDRixLQUFLLENBQUM7TUFDSmIsQ0FBQyxHQUFHVyxDQUFDLEVBQUVWLENBQUMsR0FBR1csQ0FBQyxFQUFFVixDQUFDLEdBQUdILENBQUM7TUFDbkI7SUFDRixLQUFLLENBQUM7TUFDSkMsQ0FBQyxHQUFHYSxDQUFDLEVBQUVaLENBQUMsR0FBR1UsQ0FBQyxFQUFFVCxDQUFDLEdBQUdILENBQUM7TUFDbkI7SUFDRixLQUFLLENBQUM7TUFDSkMsQ0FBQyxHQUFHRCxDQUFDLEVBQUVFLENBQUMsR0FBR1UsQ0FBQyxFQUFFVCxDQUFDLEdBQUdVLENBQUM7TUFDbkI7RUFDSjtFQUNBLE9BQU8sQ0FBQ0osSUFBSSxDQUFDTSxLQUFLLENBQUNkLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRVEsSUFBSSxDQUFDTSxLQUFLLENBQUNiLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRU8sSUFBSSxDQUFDTSxLQUFLLENBQUNaLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztBQUN4RTs7QUFFQTtBQUNBLFNBQVNhLEdBQUdBLENBQUNqQixDQUFDLEVBQUU7RUFDZCxPQUFPLFlBQVk7SUFDakJBLENBQUMsR0FBR1UsSUFBSSxDQUFDUSxJQUFJLENBQUMsS0FBSyxFQUFFbEIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFVBQVU7SUFDeEMsT0FBTyxDQUFDQSxDQUFDLEdBQUcsVUFBVSxJQUFJLFVBQVU7RUFDdEMsQ0FBQztBQUNIO0FBQ0E7QUFDQSxNQUFNbUIsTUFBTSxHQUFHRixHQUFHLENBQUMsR0FBRyxDQUFDOztBQUV2QjtBQUNBO0FBQ08sTUFBTUcsc0JBQXNCLEdBQUdDLEtBQUssSUFBSTtFQUM3QyxJQUFJLENBQUN4QixhQUFhLENBQUN3QixLQUFLLENBQUMsRUFBRTtJQUN6QnhCLGFBQWEsQ0FBQ3dCLEtBQUssQ0FBQyxHQUFHdkIsUUFBUSxDQUFDcUIsTUFBTSxDQUFDLENBQUMsRUFBRUEsTUFBTSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFQSxNQUFNLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7RUFDdkY7RUFDQSxPQUFPdEIsYUFBYSxDQUFDd0IsS0FBSyxDQUFDO0FBQzdCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4uL3ZvbHVtZS12aWV3ZXIvZXMvY29uc3RhbnRzL2NvbG9ycy5qcz9iZWNjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBkZWZhdWx0Q29sb3JzID0gW1syNTUsIDAsIDI1NV0sIFsyNTUsIDI1NSwgMjU1XSwgWzAsIDI1NSwgMjU1XV07XG4vLyAwIDw9IChoLCBzLCB2KSA8PSAxXG4vLyByZXR1cm5zIDAgPD0gKHIsIGcsIGIpIDw9IDI1NSByb3VuZGVkIHRvIG5lYXJlc3QgaW50ZWdlclxuLy8geW91IGNhbiBhbHNvIHBhc3MgaW4ganVzdCBvbmUgYXJnIGFzIGFuIG9iamVjdCBvZiB7aCwgcywgdn0gcHJvcHMuXG5mdW5jdGlvbiBIU1Z0b1JHQihoLCBzLCB2KSB7XG4gIGxldCByLCBnLCBiO1xuICBsZXQgaGggPSAwO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGhzdiA9IGg7XG4gICAgcyA9IGhzdi5zLCB2ID0gaHN2LnYsIGhoID0gaHN2Lmg7XG4gIH0gZWxzZSB7XG4gICAgaGggPSBoO1xuICB9XG4gIGNvbnN0IGkgPSBNYXRoLmZsb29yKGhoICogNik7XG4gIGNvbnN0IGYgPSBoaCAqIDYgLSBpO1xuICBjb25zdCBwID0gdiAqICgxIC0gcyk7XG4gIGNvbnN0IHEgPSB2ICogKDEgLSBmICogcyk7XG4gIGNvbnN0IHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG4gIHN3aXRjaCAoaSAlIDYpIHtcbiAgICBjYXNlIDA6XG4gICAgICByID0gdiwgZyA9IHQsIGIgPSBwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgciA9IHEsIGcgPSB2LCBiID0gcDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIHIgPSBwLCBnID0gdiwgYiA9IHQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICByID0gcCwgZyA9IHEsIGIgPSB2O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgciA9IHQsIGcgPSBwLCBiID0gdjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNTpcbiAgICAgIHIgPSB2LCBnID0gcCwgYiA9IHE7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gW01hdGgucm91bmQociAqIDI1NSksIE1hdGgucm91bmQoZyAqIDI1NSksIE1hdGgucm91bmQoYiAqIDI1NSldO1xufVxuXG4vLyAxOTkzIFBhcmstTWlsbGVyIExDR1xuZnVuY3Rpb24gTENHKHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBzID0gTWF0aC5pbXVsKDQ4MjcxLCBzKSB8IDAgJSAyMTQ3NDgzNjQ3O1xuICAgIHJldHVybiAocyAmIDIxNDc0ODM2NDcpIC8gMjE0NzQ4MzY0ODtcbiAgfTtcbn1cbi8vIFVzZSBpdCBsaWtlIHNvOlxuY29uc3QgbXlyYW5kID0gTENHKDEyMyk7XG5cbi8vIGlmIGluZGV4IGV4Y2VlZHMgZGVmYXVsdENvbG9ycyBzdGFydCBjaG9vc2luZyByYW5kb20gb25lc1xuLy8gcmV0dXJucyBbcixnLGJdIDAtMjU1IHJhbmdlXG5leHBvcnQgY29uc3QgZ2V0Q29sb3JCeUNoYW5uZWxJbmRleCA9IGluZGV4ID0+IHtcbiAgaWYgKCFkZWZhdWx0Q29sb3JzW2luZGV4XSkge1xuICAgIGRlZmF1bHRDb2xvcnNbaW5kZXhdID0gSFNWdG9SR0IobXlyYW5kKCksIG15cmFuZCgpICogMC41ICsgMC41LCBteXJhbmQoKSAqIDAuNSArIDAuNSk7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRDb2xvcnNbaW5kZXhdO1xufTsiXSwibmFtZXMiOlsiZGVmYXVsdENvbG9ycyIsIkhTVnRvUkdCIiwiaCIsInMiLCJ2IiwiciIsImciLCJiIiwiaGgiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJoc3YiLCJpIiwiTWF0aCIsImZsb29yIiwiZiIsInAiLCJxIiwidCIsInJvdW5kIiwiTENHIiwiaW11bCIsIm15cmFuZCIsImdldENvbG9yQnlDaGFubmVsSW5kZXgiLCJpbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../volume-viewer/es/constants/colors.js\n");

/***/ }),

/***/ "../volume-viewer/es/loaders/IVolumeLoader.js":
/*!****************************************************!*\
  !*** ../volume-viewer/es/loaders/IVolumeLoader.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LoadSpec: () => (/* binding */ LoadSpec),\n/* harmony export */   ThreadableVolumeLoader: () => (/* binding */ ThreadableVolumeLoader),\n/* harmony export */   VolumeDims: () => (/* binding */ VolumeDims),\n/* harmony export */   loadSpecToString: () => (/* binding */ loadSpecToString)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"../volume-viewer/node_modules/three/build/three.module.js\");\n/* harmony import */ var _Volume_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Volume.js */ \"../volume-viewer/es/Volume.js\");\n/* harmony import */ var _VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VolumeLoaderUtils.js */ \"../volume-viewer/es/loaders/VolumeLoaderUtils.js\");\n\n\n\nclass LoadSpec {\n  time = 0;\n  /** The max size of a volume atlas that may be produced by a load. Used to pick the appropriate multiscale level. */\n\n  /** An optional bias added to the scale level index after the optimal level is picked based on `maxAtlasEdge`. */\n\n  /**\r\n   * The max scale level to load. Even when this is specified, the loader may pick a *lower* scale level based on\r\n   * limits imposed by `scaleLevelBias` and `maxAtlasEdge` (or their defaults if unspecified).\r\n   */\n\n  /** Subregion of volume to load. If not specified, the entire volume is loaded. Specify as floats between 0-1. */\n  subregion = new three__WEBPACK_IMPORTED_MODULE_2__.Box3(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(1, 1, 1));\n}\nfunction loadSpecToString(spec) {\n  const {\n    min,\n    max\n  } = spec.subregion;\n  return `${spec.multiscaleLevel}:${spec.time}:x(${min.x},${max.x}):y(${min.y},${max.y}):z(${min.z},${max.z})`;\n}\nclass VolumeDims {\n  // shape: [t, c, z, y, x]\n  shape = [0, 0, 0, 0, 0];\n  // spacing: [t, c, z, y, x]; generally expect 1 for non-spatial dimensions\n  spacing = [1, 1, 1, 1, 1];\n  spaceUnit = \"m\";\n  timeUnit = \"s\";\n  // TODO make this an enum?\n  dataType = \"uint8\";\n}\n\n/**\r\n * @callback PerChannelCallback\r\n * @param {string} imageurl\r\n * @param {Volume} volume\r\n * @param {number} channelindex\r\n */\n\n/**\r\n * @callback RawChannelDataCallback - allow lists of channel indices and data arrays to be passed to the callback\r\n * @param {number[]} channelIndex - The indices of the channels that were loaded\r\n * @param {Uint8Array[]} data - The raw data for each channel (renormalized to 0-255 range)\r\n * @param {[number, number][]} ranges - The min and max values for each channel in their original range\r\n * @param {[number, number]} atlasDims - The dimensions of the atlas, if the data is in an atlas format\r\n */\n\n/**\r\n * Loads volume data from a source specified by a `LoadSpec`.\r\n *\r\n * Loaders may keep state for reuse between volume creation and volume loading, and should be kept alive until volume\r\n * loading is complete. (See `createVolume`)\r\n */\n\n/** Abstract class which allows loaders to accept and return types that are easier to transfer to/from a worker. */\nclass ThreadableVolumeLoader {\n  /** Unchanged from `IVolumeLoader`. See that interface for details. */\n\n  /**\r\n   * Creates an `ImageInfo` object from a `LoadSpec`, which may be passed to the `Volume` constructor to create an\r\n   * empty volume that can accept data loaded with the given `LoadSpec`.\r\n   *\r\n   * Also returns a new `LoadSpec` that may have been modified from the input `LoadSpec` to reflect the constraints or\r\n   * abilities of the loader. This new `LoadSpec` should be used when constructing the `Volume`, _not_ the original.\r\n   */\n\n  /**\r\n   * Begins loading per-channel data for the volume specified by `imageInfo` and `loadSpec`.\r\n   *\r\n   * This function accepts two required callbacks. The first, `onUpdateVolumeMetadata`, should be called at most once\r\n   * to modify the `Volume`'s `imageInfo` and/or `loadSpec` properties based on changes made by this load. Actual\r\n   * loaded channel data is passed to `onData` as it is loaded.\r\n   *\r\n   * Depending on the loader, the array passed to `onData` may be in simple 3d dimension order or reflect a 2d atlas.\r\n   * If the latter, the dimensions of the atlas are passed as the third argument to `onData`.\r\n   *\r\n   * The returned promise should resolve when all data has been loaded, or reject if any error occurs while loading.\r\n   */\n\n  setPrefetchPriority(_directions) {\n    // no-op by default\n  }\n  syncMultichannelLoading(_sync) {\n    // default behavior is async, to update channels as they arrive, depending on each\n    // loader's implementation details.\n  }\n  async createVolume(loadSpec, onChannelLoaded) {\n    const {\n      imageInfo,\n      loadSpec: adjustedLoadSpec\n    } = await this.createImageInfo(loadSpec);\n    const vol = new _Volume_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](imageInfo, adjustedLoadSpec, this);\n    vol.channelLoadCallback = onChannelLoaded;\n    vol.imageMetadata = (0,_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.buildDefaultMetadata)(imageInfo);\n    return vol;\n  }\n  async loadVolumeData(volume, loadSpecOverride, onChannelLoaded) {\n    const onUpdateMetadata = (imageInfo, loadSpec) => {\n      if (imageInfo) {\n        volume.imageInfo = imageInfo;\n        volume.updateDimensions();\n      }\n      volume.loadSpec = {\n        ...loadSpec,\n        ...spec\n      };\n    };\n    const onChannelData = (channelIndices, dataArrays, ranges, atlasDims) => {\n      for (let i = 0; i < channelIndices.length; i++) {\n        const channelIndex = channelIndices[i];\n        const data = dataArrays[i];\n        const range = ranges[i];\n        if (atlasDims) {\n          volume.setChannelDataFromAtlas(channelIndex, data, atlasDims[0], atlasDims[1]);\n        } else {\n          volume.setChannelDataFromVolume(channelIndex, data, range);\n        }\n        onChannelLoaded?.(volume, channelIndex);\n      }\n    };\n    const spec = {\n      ...loadSpecOverride,\n      ...volume.loadSpec\n    };\n    return this.loadRawChannelData(volume.imageInfo, spec, onUpdateMetadata, onChannelData);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL0lWb2x1bWVMb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFzQztBQUNKO0FBQzRCO0FBQ3ZELE1BQU1JLFFBQVEsQ0FBQztFQUNwQkMsSUFBSSxHQUFHLENBQUM7RUFDUjs7RUFFQTs7RUFFQTtBQUNGO0FBQ0E7QUFDQTs7RUFFRTtFQUNBQyxTQUFTLEdBQUcsSUFBSU4sdUNBQUksQ0FBQyxJQUFJQywwQ0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSUEsMENBQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2xFO0FBQ08sU0FBU00sZ0JBQWdCQSxDQUFDQyxJQUFJLEVBQUU7RUFDckMsTUFBTTtJQUNKQyxHQUFHO0lBQ0hDO0VBQ0YsQ0FBQyxHQUFHRixJQUFJLENBQUNGLFNBQVM7RUFDbEIsT0FBUSxHQUFFRSxJQUFJLENBQUNHLGVBQWdCLElBQUdILElBQUksQ0FBQ0gsSUFBSyxNQUFLSSxHQUFHLENBQUNHLENBQUUsSUFBR0YsR0FBRyxDQUFDRSxDQUFFLE9BQU1ILEdBQUcsQ0FBQ0ksQ0FBRSxJQUFHSCxHQUFHLENBQUNHLENBQUUsT0FBTUosR0FBRyxDQUFDSyxDQUFFLElBQUdKLEdBQUcsQ0FBQ0ksQ0FBRSxHQUFFO0FBQzlHO0FBQ08sTUFBTUMsVUFBVSxDQUFDO0VBQ3RCO0VBQ0FDLEtBQUssR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDdkI7RUFDQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztFQUN6QkMsU0FBUyxHQUFHLElBQUk7RUFDaEJDLFFBQVEsR0FBRyxHQUFHO0VBQ2Q7RUFDQUMsUUFBUSxHQUFHLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPLE1BQU1DLHNCQUFzQixDQUFDO0VBQ2xDOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztFQUVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7RUFFRUMsbUJBQW1CQSxDQUFDQyxXQUFXLEVBQUU7SUFDL0I7RUFBQTtFQUVGQyx1QkFBdUJBLENBQUNDLEtBQUssRUFBRTtJQUM3QjtJQUNBO0VBQUE7RUFFRixNQUFNQyxZQUFZQSxDQUFDQyxRQUFRLEVBQUVDLGVBQWUsRUFBRTtJQUM1QyxNQUFNO01BQ0pDLFNBQVM7TUFDVEYsUUFBUSxFQUFFRztJQUNaLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQ0MsZUFBZSxDQUFDSixRQUFRLENBQUM7SUFDeEMsTUFBTUssR0FBRyxHQUFHLElBQUk5QixrREFBTSxDQUFDMkIsU0FBUyxFQUFFQyxnQkFBZ0IsRUFBRSxJQUFJLENBQUM7SUFDekRFLEdBQUcsQ0FBQ0MsbUJBQW1CLEdBQUdMLGVBQWU7SUFDekNJLEdBQUcsQ0FBQ0UsYUFBYSxHQUFHL0IsMkVBQW9CLENBQUMwQixTQUFTLENBQUM7SUFDbkQsT0FBT0csR0FBRztFQUNaO0VBQ0EsTUFBTUcsY0FBY0EsQ0FBQ0MsTUFBTSxFQUFFQyxnQkFBZ0IsRUFBRVQsZUFBZSxFQUFFO0lBQzlELE1BQU1VLGdCQUFnQixHQUFHQSxDQUFDVCxTQUFTLEVBQUVGLFFBQVEsS0FBSztNQUNoRCxJQUFJRSxTQUFTLEVBQUU7UUFDYk8sTUFBTSxDQUFDUCxTQUFTLEdBQUdBLFNBQVM7UUFDNUJPLE1BQU0sQ0FBQ0csZ0JBQWdCLENBQUMsQ0FBQztNQUMzQjtNQUNBSCxNQUFNLENBQUNULFFBQVEsR0FBRztRQUNoQixHQUFHQSxRQUFRO1FBQ1gsR0FBR25CO01BQ0wsQ0FBQztJQUNILENBQUM7SUFDRCxNQUFNZ0MsYUFBYSxHQUFHQSxDQUFDQyxjQUFjLEVBQUVDLFVBQVUsRUFBRUMsTUFBTSxFQUFFQyxTQUFTLEtBQUs7TUFDdkUsS0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdKLGNBQWMsQ0FBQ0ssTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtRQUM5QyxNQUFNRSxZQUFZLEdBQUdOLGNBQWMsQ0FBQ0ksQ0FBQyxDQUFDO1FBQ3RDLE1BQU1HLElBQUksR0FBR04sVUFBVSxDQUFDRyxDQUFDLENBQUM7UUFDMUIsTUFBTUksS0FBSyxHQUFHTixNQUFNLENBQUNFLENBQUMsQ0FBQztRQUN2QixJQUFJRCxTQUFTLEVBQUU7VUFDYlIsTUFBTSxDQUFDYyx1QkFBdUIsQ0FBQ0gsWUFBWSxFQUFFQyxJQUFJLEVBQUVKLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRUEsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2hGLENBQUMsTUFBTTtVQUNMUixNQUFNLENBQUNlLHdCQUF3QixDQUFDSixZQUFZLEVBQUVDLElBQUksRUFBRUMsS0FBSyxDQUFDO1FBQzVEO1FBQ0FyQixlQUFlLEdBQUdRLE1BQU0sRUFBRVcsWUFBWSxDQUFDO01BQ3pDO0lBQ0YsQ0FBQztJQUNELE1BQU12QyxJQUFJLEdBQUc7TUFDWCxHQUFHNkIsZ0JBQWdCO01BQ25CLEdBQUdELE1BQU0sQ0FBQ1Q7SUFDWixDQUFDO0lBQ0QsT0FBTyxJQUFJLENBQUN5QixrQkFBa0IsQ0FBQ2hCLE1BQU0sQ0FBQ1AsU0FBUyxFQUFFckIsSUFBSSxFQUFFOEIsZ0JBQWdCLEVBQUVFLGFBQWEsQ0FBQztFQUN6RjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uLi92b2x1bWUtdmlld2VyL2VzL2xvYWRlcnMvSVZvbHVtZUxvYWRlci5qcz82YmE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJveDMsIFZlY3RvcjMgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCBWb2x1bWUgZnJvbSBcIi4uL1ZvbHVtZS5qc1wiO1xuaW1wb3J0IHsgYnVpbGREZWZhdWx0TWV0YWRhdGEgfSBmcm9tIFwiLi9Wb2x1bWVMb2FkZXJVdGlscy5qc1wiO1xuZXhwb3J0IGNsYXNzIExvYWRTcGVjIHtcbiAgdGltZSA9IDA7XG4gIC8qKiBUaGUgbWF4IHNpemUgb2YgYSB2b2x1bWUgYXRsYXMgdGhhdCBtYXkgYmUgcHJvZHVjZWQgYnkgYSBsb2FkLiBVc2VkIHRvIHBpY2sgdGhlIGFwcHJvcHJpYXRlIG11bHRpc2NhbGUgbGV2ZWwuICovXG5cbiAgLyoqIEFuIG9wdGlvbmFsIGJpYXMgYWRkZWQgdG8gdGhlIHNjYWxlIGxldmVsIGluZGV4IGFmdGVyIHRoZSBvcHRpbWFsIGxldmVsIGlzIHBpY2tlZCBiYXNlZCBvbiBgbWF4QXRsYXNFZGdlYC4gKi9cblxuICAvKipcclxuICAgKiBUaGUgbWF4IHNjYWxlIGxldmVsIHRvIGxvYWQuIEV2ZW4gd2hlbiB0aGlzIGlzIHNwZWNpZmllZCwgdGhlIGxvYWRlciBtYXkgcGljayBhICpsb3dlciogc2NhbGUgbGV2ZWwgYmFzZWQgb25cclxuICAgKiBsaW1pdHMgaW1wb3NlZCBieSBgc2NhbGVMZXZlbEJpYXNgIGFuZCBgbWF4QXRsYXNFZGdlYCAob3IgdGhlaXIgZGVmYXVsdHMgaWYgdW5zcGVjaWZpZWQpLlxyXG4gICAqL1xuXG4gIC8qKiBTdWJyZWdpb24gb2Ygdm9sdW1lIHRvIGxvYWQuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBlbnRpcmUgdm9sdW1lIGlzIGxvYWRlZC4gU3BlY2lmeSBhcyBmbG9hdHMgYmV0d2VlbiAwLTEuICovXG4gIHN1YnJlZ2lvbiA9IG5ldyBCb3gzKG5ldyBWZWN0b3IzKDAsIDAsIDApLCBuZXcgVmVjdG9yMygxLCAxLCAxKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbG9hZFNwZWNUb1N0cmluZyhzcGVjKSB7XG4gIGNvbnN0IHtcbiAgICBtaW4sXG4gICAgbWF4XG4gIH0gPSBzcGVjLnN1YnJlZ2lvbjtcbiAgcmV0dXJuIGAke3NwZWMubXVsdGlzY2FsZUxldmVsfToke3NwZWMudGltZX06eCgke21pbi54fSwke21heC54fSk6eSgke21pbi55fSwke21heC55fSk6eigke21pbi56fSwke21heC56fSlgO1xufVxuZXhwb3J0IGNsYXNzIFZvbHVtZURpbXMge1xuICAvLyBzaGFwZTogW3QsIGMsIHosIHksIHhdXG4gIHNoYXBlID0gWzAsIDAsIDAsIDAsIDBdO1xuICAvLyBzcGFjaW5nOiBbdCwgYywgeiwgeSwgeF07IGdlbmVyYWxseSBleHBlY3QgMSBmb3Igbm9uLXNwYXRpYWwgZGltZW5zaW9uc1xuICBzcGFjaW5nID0gWzEsIDEsIDEsIDEsIDFdO1xuICBzcGFjZVVuaXQgPSBcIs68bVwiO1xuICB0aW1lVW5pdCA9IFwic1wiO1xuICAvLyBUT0RPIG1ha2UgdGhpcyBhbiBlbnVtP1xuICBkYXRhVHlwZSA9IFwidWludDhcIjtcbn1cblxuLyoqXHJcbiAqIEBjYWxsYmFjayBQZXJDaGFubmVsQ2FsbGJhY2tcclxuICogQHBhcmFtIHtzdHJpbmd9IGltYWdldXJsXHJcbiAqIEBwYXJhbSB7Vm9sdW1lfSB2b2x1bWVcclxuICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWxpbmRleFxyXG4gKi9cblxuLyoqXHJcbiAqIEBjYWxsYmFjayBSYXdDaGFubmVsRGF0YUNhbGxiYWNrIC0gYWxsb3cgbGlzdHMgb2YgY2hhbm5lbCBpbmRpY2VzIGFuZCBkYXRhIGFycmF5cyB0byBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrXHJcbiAqIEBwYXJhbSB7bnVtYmVyW119IGNoYW5uZWxJbmRleCAtIFRoZSBpbmRpY2VzIG9mIHRoZSBjaGFubmVscyB0aGF0IHdlcmUgbG9hZGVkXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheVtdfSBkYXRhIC0gVGhlIHJhdyBkYXRhIGZvciBlYWNoIGNoYW5uZWwgKHJlbm9ybWFsaXplZCB0byAwLTI1NSByYW5nZSlcclxuICogQHBhcmFtIHtbbnVtYmVyLCBudW1iZXJdW119IHJhbmdlcyAtIFRoZSBtaW4gYW5kIG1heCB2YWx1ZXMgZm9yIGVhY2ggY2hhbm5lbCBpbiB0aGVpciBvcmlnaW5hbCByYW5nZVxyXG4gKiBAcGFyYW0ge1tudW1iZXIsIG51bWJlcl19IGF0bGFzRGltcyAtIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBhdGxhcywgaWYgdGhlIGRhdGEgaXMgaW4gYW4gYXRsYXMgZm9ybWF0XHJcbiAqL1xuXG4vKipcclxuICogTG9hZHMgdm9sdW1lIGRhdGEgZnJvbSBhIHNvdXJjZSBzcGVjaWZpZWQgYnkgYSBgTG9hZFNwZWNgLlxyXG4gKlxyXG4gKiBMb2FkZXJzIG1heSBrZWVwIHN0YXRlIGZvciByZXVzZSBiZXR3ZWVuIHZvbHVtZSBjcmVhdGlvbiBhbmQgdm9sdW1lIGxvYWRpbmcsIGFuZCBzaG91bGQgYmUga2VwdCBhbGl2ZSB1bnRpbCB2b2x1bWVcclxuICogbG9hZGluZyBpcyBjb21wbGV0ZS4gKFNlZSBgY3JlYXRlVm9sdW1lYClcclxuICovXG5cbi8qKiBBYnN0cmFjdCBjbGFzcyB3aGljaCBhbGxvd3MgbG9hZGVycyB0byBhY2NlcHQgYW5kIHJldHVybiB0eXBlcyB0aGF0IGFyZSBlYXNpZXIgdG8gdHJhbnNmZXIgdG8vZnJvbSBhIHdvcmtlci4gKi9cbmV4cG9ydCBjbGFzcyBUaHJlYWRhYmxlVm9sdW1lTG9hZGVyIHtcbiAgLyoqIFVuY2hhbmdlZCBmcm9tIGBJVm9sdW1lTG9hZGVyYC4gU2VlIHRoYXQgaW50ZXJmYWNlIGZvciBkZXRhaWxzLiAqL1xuXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gYEltYWdlSW5mb2Agb2JqZWN0IGZyb20gYSBgTG9hZFNwZWNgLCB3aGljaCBtYXkgYmUgcGFzc2VkIHRvIHRoZSBgVm9sdW1lYCBjb25zdHJ1Y3RvciB0byBjcmVhdGUgYW5cclxuICAgKiBlbXB0eSB2b2x1bWUgdGhhdCBjYW4gYWNjZXB0IGRhdGEgbG9hZGVkIHdpdGggdGhlIGdpdmVuIGBMb2FkU3BlY2AuXHJcbiAgICpcclxuICAgKiBBbHNvIHJldHVybnMgYSBuZXcgYExvYWRTcGVjYCB0aGF0IG1heSBoYXZlIGJlZW4gbW9kaWZpZWQgZnJvbSB0aGUgaW5wdXQgYExvYWRTcGVjYCB0byByZWZsZWN0IHRoZSBjb25zdHJhaW50cyBvclxyXG4gICAqIGFiaWxpdGllcyBvZiB0aGUgbG9hZGVyLiBUaGlzIG5ldyBgTG9hZFNwZWNgIHNob3VsZCBiZSB1c2VkIHdoZW4gY29uc3RydWN0aW5nIHRoZSBgVm9sdW1lYCwgX25vdF8gdGhlIG9yaWdpbmFsLlxyXG4gICAqL1xuXG4gIC8qKlxyXG4gICAqIEJlZ2lucyBsb2FkaW5nIHBlci1jaGFubmVsIGRhdGEgZm9yIHRoZSB2b2x1bWUgc3BlY2lmaWVkIGJ5IGBpbWFnZUluZm9gIGFuZCBgbG9hZFNwZWNgLlxyXG4gICAqXHJcbiAgICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIHR3byByZXF1aXJlZCBjYWxsYmFja3MuIFRoZSBmaXJzdCwgYG9uVXBkYXRlVm9sdW1lTWV0YWRhdGFgLCBzaG91bGQgYmUgY2FsbGVkIGF0IG1vc3Qgb25jZVxyXG4gICAqIHRvIG1vZGlmeSB0aGUgYFZvbHVtZWAncyBgaW1hZ2VJbmZvYCBhbmQvb3IgYGxvYWRTcGVjYCBwcm9wZXJ0aWVzIGJhc2VkIG9uIGNoYW5nZXMgbWFkZSBieSB0aGlzIGxvYWQuIEFjdHVhbFxyXG4gICAqIGxvYWRlZCBjaGFubmVsIGRhdGEgaXMgcGFzc2VkIHRvIGBvbkRhdGFgIGFzIGl0IGlzIGxvYWRlZC5cclxuICAgKlxyXG4gICAqIERlcGVuZGluZyBvbiB0aGUgbG9hZGVyLCB0aGUgYXJyYXkgcGFzc2VkIHRvIGBvbkRhdGFgIG1heSBiZSBpbiBzaW1wbGUgM2QgZGltZW5zaW9uIG9yZGVyIG9yIHJlZmxlY3QgYSAyZCBhdGxhcy5cclxuICAgKiBJZiB0aGUgbGF0dGVyLCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgYXRsYXMgYXJlIHBhc3NlZCBhcyB0aGUgdGhpcmQgYXJndW1lbnQgdG8gYG9uRGF0YWAuXHJcbiAgICpcclxuICAgKiBUaGUgcmV0dXJuZWQgcHJvbWlzZSBzaG91bGQgcmVzb2x2ZSB3aGVuIGFsbCBkYXRhIGhhcyBiZWVuIGxvYWRlZCwgb3IgcmVqZWN0IGlmIGFueSBlcnJvciBvY2N1cnMgd2hpbGUgbG9hZGluZy5cclxuICAgKi9cblxuICBzZXRQcmVmZXRjaFByaW9yaXR5KF9kaXJlY3Rpb25zKSB7XG4gICAgLy8gbm8tb3AgYnkgZGVmYXVsdFxuICB9XG4gIHN5bmNNdWx0aWNoYW5uZWxMb2FkaW5nKF9zeW5jKSB7XG4gICAgLy8gZGVmYXVsdCBiZWhhdmlvciBpcyBhc3luYywgdG8gdXBkYXRlIGNoYW5uZWxzIGFzIHRoZXkgYXJyaXZlLCBkZXBlbmRpbmcgb24gZWFjaFxuICAgIC8vIGxvYWRlcidzIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gIH1cbiAgYXN5bmMgY3JlYXRlVm9sdW1lKGxvYWRTcGVjLCBvbkNoYW5uZWxMb2FkZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbWFnZUluZm8sXG4gICAgICBsb2FkU3BlYzogYWRqdXN0ZWRMb2FkU3BlY1xuICAgIH0gPSBhd2FpdCB0aGlzLmNyZWF0ZUltYWdlSW5mbyhsb2FkU3BlYyk7XG4gICAgY29uc3Qgdm9sID0gbmV3IFZvbHVtZShpbWFnZUluZm8sIGFkanVzdGVkTG9hZFNwZWMsIHRoaXMpO1xuICAgIHZvbC5jaGFubmVsTG9hZENhbGxiYWNrID0gb25DaGFubmVsTG9hZGVkO1xuICAgIHZvbC5pbWFnZU1ldGFkYXRhID0gYnVpbGREZWZhdWx0TWV0YWRhdGEoaW1hZ2VJbmZvKTtcbiAgICByZXR1cm4gdm9sO1xuICB9XG4gIGFzeW5jIGxvYWRWb2x1bWVEYXRhKHZvbHVtZSwgbG9hZFNwZWNPdmVycmlkZSwgb25DaGFubmVsTG9hZGVkKSB7XG4gICAgY29uc3Qgb25VcGRhdGVNZXRhZGF0YSA9IChpbWFnZUluZm8sIGxvYWRTcGVjKSA9PiB7XG4gICAgICBpZiAoaW1hZ2VJbmZvKSB7XG4gICAgICAgIHZvbHVtZS5pbWFnZUluZm8gPSBpbWFnZUluZm87XG4gICAgICAgIHZvbHVtZS51cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICB9XG4gICAgICB2b2x1bWUubG9hZFNwZWMgPSB7XG4gICAgICAgIC4uLmxvYWRTcGVjLFxuICAgICAgICAuLi5zcGVjXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3Qgb25DaGFubmVsRGF0YSA9IChjaGFubmVsSW5kaWNlcywgZGF0YUFycmF5cywgcmFuZ2VzLCBhdGxhc0RpbXMpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbm5lbEluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbEluZGV4ID0gY2hhbm5lbEluZGljZXNbaV07XG4gICAgICAgIGNvbnN0IGRhdGEgPSBkYXRhQXJyYXlzW2ldO1xuICAgICAgICBjb25zdCByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgaWYgKGF0bGFzRGltcykge1xuICAgICAgICAgIHZvbHVtZS5zZXRDaGFubmVsRGF0YUZyb21BdGxhcyhjaGFubmVsSW5kZXgsIGRhdGEsIGF0bGFzRGltc1swXSwgYXRsYXNEaW1zWzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2b2x1bWUuc2V0Q2hhbm5lbERhdGFGcm9tVm9sdW1lKGNoYW5uZWxJbmRleCwgZGF0YSwgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIG9uQ2hhbm5lbExvYWRlZD8uKHZvbHVtZSwgY2hhbm5lbEluZGV4KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNwZWMgPSB7XG4gICAgICAuLi5sb2FkU3BlY092ZXJyaWRlLFxuICAgICAgLi4udm9sdW1lLmxvYWRTcGVjXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5sb2FkUmF3Q2hhbm5lbERhdGEodm9sdW1lLmltYWdlSW5mbywgc3BlYywgb25VcGRhdGVNZXRhZGF0YSwgb25DaGFubmVsRGF0YSk7XG4gIH1cbn0iXSwibmFtZXMiOlsiQm94MyIsIlZlY3RvcjMiLCJWb2x1bWUiLCJidWlsZERlZmF1bHRNZXRhZGF0YSIsIkxvYWRTcGVjIiwidGltZSIsInN1YnJlZ2lvbiIsImxvYWRTcGVjVG9TdHJpbmciLCJzcGVjIiwibWluIiwibWF4IiwibXVsdGlzY2FsZUxldmVsIiwieCIsInkiLCJ6IiwiVm9sdW1lRGltcyIsInNoYXBlIiwic3BhY2luZyIsInNwYWNlVW5pdCIsInRpbWVVbml0IiwiZGF0YVR5cGUiLCJUaHJlYWRhYmxlVm9sdW1lTG9hZGVyIiwic2V0UHJlZmV0Y2hQcmlvcml0eSIsIl9kaXJlY3Rpb25zIiwic3luY011bHRpY2hhbm5lbExvYWRpbmciLCJfc3luYyIsImNyZWF0ZVZvbHVtZSIsImxvYWRTcGVjIiwib25DaGFubmVsTG9hZGVkIiwiaW1hZ2VJbmZvIiwiYWRqdXN0ZWRMb2FkU3BlYyIsImNyZWF0ZUltYWdlSW5mbyIsInZvbCIsImNoYW5uZWxMb2FkQ2FsbGJhY2siLCJpbWFnZU1ldGFkYXRhIiwibG9hZFZvbHVtZURhdGEiLCJ2b2x1bWUiLCJsb2FkU3BlY092ZXJyaWRlIiwib25VcGRhdGVNZXRhZGF0YSIsInVwZGF0ZURpbWVuc2lvbnMiLCJvbkNoYW5uZWxEYXRhIiwiY2hhbm5lbEluZGljZXMiLCJkYXRhQXJyYXlzIiwicmFuZ2VzIiwiYXRsYXNEaW1zIiwiaSIsImxlbmd0aCIsImNoYW5uZWxJbmRleCIsImRhdGEiLCJyYW5nZSIsInNldENoYW5uZWxEYXRhRnJvbUF0bGFzIiwic2V0Q2hhbm5lbERhdGFGcm9tVm9sdW1lIiwibG9hZFJhd0NoYW5uZWxEYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../volume-viewer/es/loaders/IVolumeLoader.js\n");

/***/ }),

/***/ "../volume-viewer/es/loaders/JsonImageInfoLoader.js":
/*!**********************************************************!*\
  !*** ../volume-viewer/es/loaders/JsonImageInfoLoader.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonImageInfoLoader: () => (/* binding */ JsonImageInfoLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"../volume-viewer/node_modules/three/build/three.module.js\");\n/* harmony import */ var _IVolumeLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IVolumeLoader.js */ \"../volume-viewer/es/loaders/IVolumeLoader.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types.js */ \"../volume-viewer/es/types.js\");\n\n\n\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/* eslint-enable @typescript-eslint/naming-convention */\n\nconst convertImageInfo = json => ({\n  name: json.name,\n  originalSize: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(json.width, json.height, json.tiles),\n  atlasTileDims: new three__WEBPACK_IMPORTED_MODULE_2__.Vector2(json.cols, json.rows),\n  volumeSize: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(json.tile_width, json.tile_height, json.tiles),\n  subregionSize: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(json.tile_width, json.tile_height, json.tiles),\n  subregionOffset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0),\n  physicalPixelSize: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(json.pixel_size_x, json.pixel_size_y, json.pixel_size_z),\n  spatialUnit: json.pixel_size_unit || \"m\",\n  numChannels: json.channels,\n  channelNames: json.channel_names,\n  channelColors: json.channel_colors,\n  times: json.times || 1,\n  timeScale: json.time_scale || 1,\n  timeUnit: json.time_unit || \"s\",\n  numMultiscaleLevels: 1,\n  multiscaleLevel: 0,\n  transform: {\n    translation: json.transform?.translation ? new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().fromArray(json.transform.translation) : new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0),\n    rotation: json.transform?.rotation ? new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().fromArray(json.transform.rotation) : new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0)\n  },\n  userData: json.userData\n});\nclass JsonImageInfoLoader extends _IVolumeLoader_js__WEBPACK_IMPORTED_MODULE_0__.ThreadableVolumeLoader {\n  constructor(urls, cache) {\n    super();\n    if (Array.isArray(urls)) {\n      this.urls = urls;\n    } else {\n      this.urls = [urls];\n    }\n    this.jsonInfo = new Array(this.urls.length);\n    this.cache = cache;\n  }\n  async getJsonImageInfo(time) {\n    const cachedInfo = this.jsonInfo[time];\n    if (cachedInfo) {\n      return cachedInfo;\n    }\n    const response = await fetch(this.urls[time]);\n    const imageInfo = await response.json();\n    imageInfo.pixel_size_unit = imageInfo.pixel_size_unit || \"m\";\n    imageInfo.times = imageInfo.times || this.urls.length;\n    this.jsonInfo[time] = imageInfo;\n    return imageInfo;\n  }\n  async loadDims(loadSpec) {\n    const jsonInfo = await this.getJsonImageInfo(loadSpec.time);\n    const d = new _IVolumeLoader_js__WEBPACK_IMPORTED_MODULE_0__.VolumeDims();\n    d.shape = [jsonInfo.times || 1, jsonInfo.channels, jsonInfo.tiles, jsonInfo.tile_height, jsonInfo.tile_width];\n    d.spacing = [1, 1, jsonInfo.pixel_size_z, jsonInfo.pixel_size_y, jsonInfo.pixel_size_x];\n    d.spaceUnit = jsonInfo.pixel_size_unit || \"m\";\n    d.dataType = \"uint8\";\n    return [d];\n  }\n  async createImageInfo(loadSpec) {\n    const jsonInfo = await this.getJsonImageInfo(loadSpec.time);\n    return {\n      imageInfo: convertImageInfo(jsonInfo),\n      loadSpec\n    };\n  }\n  async loadRawChannelData(imageInfo, loadSpec, onUpdateMetadata, onData) {\n    // if you need to adjust image paths prior to download,\n    // now is the time to do it.\n    // Try to figure out the urlPrefix from the LoadSpec.\n    // For this format we assume the image data is in the same directory as the json file.\n    const jsonInfo = await this.getJsonImageInfo(loadSpec.time);\n    let images = jsonInfo?.images;\n    if (!images) {\n      return;\n    }\n    const requestedChannels = loadSpec.channels;\n    if (requestedChannels) {\n      // If only some channels are requested, load only images which contain at least one requested channel\n      images = images.filter(({\n        channels\n      }) => channels.some(ch => ch in requestedChannels));\n    }\n\n    // This regex removes everything after the last slash, so the url had better be simple.\n    const urlPrefix = this.urls[loadSpec.time].replace(/[^/]*$/, \"\");\n    images = images.map(element => ({\n      ...element,\n      name: urlPrefix + element.name\n    }));\n\n    // Update `image`'s `loadSpec` before loading\n    const adjustedLoadSpec = {\n      ...loadSpec,\n      // `subregion` and `multiscaleLevel` are unused by this loader\n      subregion: new three__WEBPACK_IMPORTED_MODULE_2__.Box3(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(1, 1, 1)),\n      multiscaleLevel: 0,\n      // include all channels in any loaded images\n      channels: images.flatMap(({\n        channels\n      }) => channels)\n    };\n    onUpdateMetadata(undefined, adjustedLoadSpec);\n    const w = imageInfo.atlasTileDims.x * imageInfo.volumeSize.x;\n    const h = imageInfo.atlasTileDims.y * imageInfo.volumeSize.y;\n    const wrappedOnData = (ch, data, ranges) => onData(ch, data, ranges, [w, h]);\n    await JsonImageInfoLoader.loadVolumeAtlasData(images, wrappedOnData, this.cache);\n  }\n\n  /**\r\n   * load per-channel volume data from a batch of image files containing the volume slices tiled across the images\r\n   * @param {Array.<{name:string, channels:Array.<number>}>} imageArray\r\n   * @param {RawChannelDataCallback} onData Per-channel callback. Called when each channel's atlased volume data is loaded\r\n   * @param {VolumeCache} cache\r\n   * @example loadVolumeAtlasData([{\r\n   *     \"name\": \"AICS-10_5_5.ome.tif_atlas_0.png\",\r\n   *     \"channels\": [0, 1, 2]\r\n   * }, {\r\n   *     \"name\": \"AICS-10_5_5.ome.tif_atlas_1.png\",\r\n   *     \"channels\": [3, 4, 5]\r\n   * }, {\r\n   *     \"name\": \"AICS-10_5_5.ome.tif_atlas_2.png\",\r\n   *     \"channels\": [6, 7, 8]\r\n   * }], mycallback);\r\n   */\n  static async loadVolumeAtlasData(imageArray, onData, cache) {\n    const imagePromises = imageArray.map(async image => {\n      // Because the data is fetched such that one fetch returns a whole batch,\n      // if any in batch is cached then they all should be. So if any in batch is NOT cached,\n      // then we will have to do a batch request. This logic works both ways because it's all or nothing.\n      let cacheHit = true;\n      for (let j = 0; j < Math.min(image.channels.length, 4); ++j) {\n        const chindex = image.channels[j];\n        const cacheResult = cache?.get(`${image.name}/${chindex}`);\n        if (cacheResult) {\n          // all data coming from this loader is natively 8-bit\n          onData([chindex], [new Uint8Array(cacheResult)], [_types_js__WEBPACK_IMPORTED_MODULE_1__.DATARANGE_UINT8]);\n        } else {\n          cacheHit = false;\n          // we can stop checking because we know we are going to have to fetch the whole batch\n          break;\n        }\n      }\n\n      // if all channels were in cache then we can move on to the next\n      // image (batch) without requesting\n      if (cacheHit) {\n        return;\n      }\n      const response = await fetch(image.name, {\n        mode: \"cors\"\n      });\n      const blob = await response.blob();\n      const bitmap = await createImageBitmap(blob);\n      const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n      const ctx = canvas.getContext(\"2d\");\n      if (!ctx) {\n        console.log(\"Error creating canvas 2d context for \" + image.name);\n        return;\n      }\n      ctx.globalCompositeOperation = \"copy\";\n      ctx.globalAlpha = 1.0;\n      ctx.drawImage(bitmap, 0, 0);\n      const iData = ctx.getImageData(0, 0, bitmap.width, bitmap.height);\n      const channelsBits = [];\n      const length = bitmap.width * bitmap.height;\n\n      // allocate channels in batch\n      for (let ch = 0; ch < Math.min(image.channels.length, 4); ++ch) {\n        channelsBits.push(new Uint8Array(length));\n      }\n\n      // extract the data\n      for (let j = 0; j < Math.min(image.channels.length, 4); ++j) {\n        for (let px = 0; px < length; px++) {\n          channelsBits[j][px] = iData.data[px * 4 + j];\n        }\n      }\n\n      // done with `iData` and `canvas` now.\n\n      for (let ch = 0; ch < Math.min(image.channels.length, 4); ++ch) {\n        const chindex = image.channels[ch];\n        cache?.insert(`${image.name}/${chindex}`, channelsBits[ch]);\n        // NOTE: the atlas dimensions passed in here are currently unused by `JSONImageInfoLoader`\n        // all data coming from this loader is natively 8-bit\n        onData([chindex], [channelsBits[ch]], [_types_js__WEBPACK_IMPORTED_MODULE_1__.DATARANGE_UINT8], [bitmap.width, bitmap.height]);\n      }\n    });\n    await Promise.all(imagePromises);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL0pzb25JbWFnZUluZm9Mb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQztBQUN5QjtBQUMxQjs7QUFFOUM7O0FBRUE7O0FBRUEsTUFBTU0sZ0JBQWdCLEdBQUdDLElBQUksS0FBSztFQUNoQ0MsSUFBSSxFQUFFRCxJQUFJLENBQUNDLElBQUk7RUFDZkMsWUFBWSxFQUFFLElBQUlQLDBDQUFPLENBQUNLLElBQUksQ0FBQ0csS0FBSyxFQUFFSCxJQUFJLENBQUNJLE1BQU0sRUFBRUosSUFBSSxDQUFDSyxLQUFLLENBQUM7RUFDOURDLGFBQWEsRUFBRSxJQUFJWiwwQ0FBTyxDQUFDTSxJQUFJLENBQUNPLElBQUksRUFBRVAsSUFBSSxDQUFDUSxJQUFJLENBQUM7RUFDaERDLFVBQVUsRUFBRSxJQUFJZCwwQ0FBTyxDQUFDSyxJQUFJLENBQUNVLFVBQVUsRUFBRVYsSUFBSSxDQUFDVyxXQUFXLEVBQUVYLElBQUksQ0FBQ0ssS0FBSyxDQUFDO0VBQ3RFTyxhQUFhLEVBQUUsSUFBSWpCLDBDQUFPLENBQUNLLElBQUksQ0FBQ1UsVUFBVSxFQUFFVixJQUFJLENBQUNXLFdBQVcsRUFBRVgsSUFBSSxDQUFDSyxLQUFLLENBQUM7RUFDekVRLGVBQWUsRUFBRSxJQUFJbEIsMENBQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztFQUNyQ21CLGlCQUFpQixFQUFFLElBQUluQiwwQ0FBTyxDQUFDSyxJQUFJLENBQUNlLFlBQVksRUFBRWYsSUFBSSxDQUFDZ0IsWUFBWSxFQUFFaEIsSUFBSSxDQUFDaUIsWUFBWSxDQUFDO0VBQ3ZGQyxXQUFXLEVBQUVsQixJQUFJLENBQUNtQixlQUFlLElBQUksSUFBSTtFQUN6Q0MsV0FBVyxFQUFFcEIsSUFBSSxDQUFDcUIsUUFBUTtFQUMxQkMsWUFBWSxFQUFFdEIsSUFBSSxDQUFDdUIsYUFBYTtFQUNoQ0MsYUFBYSxFQUFFeEIsSUFBSSxDQUFDeUIsY0FBYztFQUNs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LTNkLXZpZXdlci8uLi92b2x1bWUtdmlld2VyL2VzL2xvYWRlcnMvSnNvbkltYWdlSW5mb0xvYWRlci5qcz8wN2RkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJveDMsIFZlY3RvcjIsIFZlY3RvcjMgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IFRocmVhZGFibGVWb2x1bWVMb2FkZXIsIFZvbHVtZURpbXMgfSBmcm9tIFwiLi9JVm9sdW1lTG9hZGVyLmpzXCI7XG5pbXBvcnQgeyBEQVRBUkFOR0VfVUlOVDggfSBmcm9tIFwiLi4vdHlwZXMuanNcIjtcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG5cbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG5cbmNvbnN0IGNvbnZlcnRJbWFnZUluZm8gPSBqc29uID0+ICh7XG4gIG5hbWU6IGpzb24ubmFtZSxcbiAgb3JpZ2luYWxTaXplOiBuZXcgVmVjdG9yMyhqc29uLndpZHRoLCBqc29uLmhlaWdodCwganNvbi50aWxlcyksXG4gIGF0bGFzVGlsZURpbXM6IG5ldyBWZWN0b3IyKGpzb24uY29scywganNvbi5yb3dzKSxcbiAgdm9sdW1lU2l6ZTogbmV3IFZlY3RvcjMoanNvbi50aWxlX3dpZHRoLCBqc29uLnRpbGVfaGVpZ2h0LCBqc29uLnRpbGVzKSxcbiAgc3VicmVnaW9uU2l6ZTogbmV3IFZlY3RvcjMoanNvbi50aWxlX3dpZHRoLCBqc29uLnRpbGVfaGVpZ2h0LCBqc29uLnRpbGVzKSxcbiAgc3VicmVnaW9uT2Zmc2V0OiBuZXcgVmVjdG9yMygwLCAwLCAwKSxcbiAgcGh5c2ljYWxQaXhlbFNpemU6IG5ldyBWZWN0b3IzKGpzb24ucGl4ZWxfc2l6ZV94LCBqc29uLnBpeGVsX3NpemVfeSwganNvbi5waXhlbF9zaXplX3opLFxuICBzcGF0aWFsVW5pdDoganNvbi5waXhlbF9zaXplX3VuaXQgfHwgXCLOvG1cIixcbiAgbnVtQ2hhbm5lbHM6IGpzb24uY2hhbm5lbHMsXG4gIGNoYW5uZWxOYW1lczoganNvbi5jaGFubmVsX25hbWVzLFxuICBjaGFubmVsQ29sb3JzOiBqc29uLmNoYW5uZWxfY29sb3JzLFxuICB0aW1lczoganNvbi50aW1lcyB8fCAxLFxuICB0aW1lU2NhbGU6IGpzb24udGltZV9zY2FsZSB8fCAxLFxuICB0aW1lVW5pdDoganNvbi50aW1lX3VuaXQgfHwgXCJzXCIsXG4gIG51bU11bHRpc2NhbGVMZXZlbHM6IDEsXG4gIG11bHRpc2NhbGVMZXZlbDogMCxcbiAgdHJhbnNmb3JtOiB7XG4gICAgdHJhbnNsYXRpb246IGpzb24udHJhbnNmb3JtPy50cmFuc2xhdGlvbiA/IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KGpzb24udHJhbnNmb3JtLnRyYW5zbGF0aW9uKSA6IG5ldyBWZWN0b3IzKDAsIDAsIDApLFxuICAgIHJvdGF0aW9uOiBqc29uLnRyYW5zZm9ybT8ucm90YXRpb24gPyBuZXcgVmVjdG9yMygpLmZyb21BcnJheShqc29uLnRyYW5zZm9ybS5yb3RhdGlvbikgOiBuZXcgVmVjdG9yMygwLCAwLCAwKVxuICB9LFxuICB1c2VyRGF0YToganNvbi51c2VyRGF0YVxufSk7XG5jbGFzcyBKc29uSW1hZ2VJbmZvTG9hZGVyIGV4dGVuZHMgVGhyZWFkYWJsZVZvbHVtZUxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKHVybHMsIGNhY2hlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh1cmxzKSkge1xuICAgICAgdGhpcy51cmxzID0gdXJscztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmxzID0gW3VybHNdO1xuICAgIH1cbiAgICB0aGlzLmpzb25JbmZvID0gbmV3IEFycmF5KHRoaXMudXJscy5sZW5ndGgpO1xuICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgfVxuICBhc3luYyBnZXRKc29uSW1hZ2VJbmZvKHRpbWUpIHtcbiAgICBjb25zdCBjYWNoZWRJbmZvID0gdGhpcy5qc29uSW5mb1t0aW1lXTtcbiAgICBpZiAoY2FjaGVkSW5mbykge1xuICAgICAgcmV0dXJuIGNhY2hlZEluZm87XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy51cmxzW3RpbWVdKTtcbiAgICBjb25zdCBpbWFnZUluZm8gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgaW1hZ2VJbmZvLnBpeGVsX3NpemVfdW5pdCA9IGltYWdlSW5mby5waXhlbF9zaXplX3VuaXQgfHwgXCLOvG1cIjtcbiAgICBpbWFnZUluZm8udGltZXMgPSBpbWFnZUluZm8udGltZXMgfHwgdGhpcy51cmxzLmxlbmd0aDtcbiAgICB0aGlzLmpzb25JbmZvW3RpbWVdID0gaW1hZ2VJbmZvO1xuICAgIHJldHVybiBpbWFnZUluZm87XG4gIH1cbiAgYXN5bmMgbG9hZERpbXMobG9hZFNwZWMpIHtcbiAgICBjb25zdCBqc29uSW5mbyA9IGF3YWl0IHRoaXMuZ2V0SnNvbkltYWdlSW5mbyhsb2FkU3BlYy50aW1lKTtcbiAgICBjb25zdCBkID0gbmV3IFZvbHVtZURpbXMoKTtcbiAgICBkLnNoYXBlID0gW2pzb25JbmZvLnRpbWVzIHx8IDEsIGpzb25JbmZvLmNoYW5uZWxzLCBqc29uSW5mby50aWxlcywganNvbkluZm8udGlsZV9oZWlnaHQsIGpzb25JbmZvLnRpbGVfd2lkdGhdO1xuICAgIGQuc3BhY2luZyA9IFsxLCAxLCBqc29uSW5mby5waXhlbF9zaXplX3osIGpzb25JbmZvLnBpeGVsX3NpemVfeSwganNvbkluZm8ucGl4ZWxfc2l6ZV94XTtcbiAgICBkLnNwYWNlVW5pdCA9IGpzb25JbmZvLnBpeGVsX3NpemVfdW5pdCB8fCBcIs68bVwiO1xuICAgIGQuZGF0YVR5cGUgPSBcInVpbnQ4XCI7XG4gICAgcmV0dXJuIFtkXTtcbiAgfVxuICBhc3luYyBjcmVhdGVJbWFnZUluZm8obG9hZFNwZWMpIHtcbiAgICBjb25zdCBqc29uSW5mbyA9IGF3YWl0IHRoaXMuZ2V0SnNvbkltYWdlSW5mbyhsb2FkU3BlYy50aW1lKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW1hZ2VJbmZvOiBjb252ZXJ0SW1hZ2VJbmZvKGpzb25JbmZvKSxcbiAgICAgIGxvYWRTcGVjXG4gICAgfTtcbiAgfVxuICBhc3luYyBsb2FkUmF3Q2hhbm5lbERhdGEoaW1hZ2VJbmZvLCBsb2FkU3BlYywgb25VcGRhdGVNZXRhZGF0YSwgb25EYXRhKSB7XG4gICAgLy8gaWYgeW91IG5lZWQgdG8gYWRqdXN0IGltYWdlIHBhdGhzIHByaW9yIHRvIGRvd25sb2FkLFxuICAgIC8vIG5vdyBpcyB0aGUgdGltZSB0byBkbyBpdC5cbiAgICAvLyBUcnkgdG8gZmlndXJlIG91dCB0aGUgdXJsUHJlZml4IGZyb20gdGhlIExvYWRTcGVjLlxuICAgIC8vIEZvciB0aGlzIGZvcm1hdCB3ZSBhc3N1bWUgdGhlIGltYWdlIGRhdGEgaXMgaW4gdGhlIHNhbWUgZGlyZWN0b3J5IGFzIHRoZSBqc29uIGZpbGUuXG4gICAgY29uc3QganNvbkluZm8gPSBhd2FpdCB0aGlzLmdldEpzb25JbWFnZUluZm8obG9hZFNwZWMudGltZSk7XG4gICAgbGV0IGltYWdlcyA9IGpzb25JbmZvPy5pbWFnZXM7XG4gICAgaWYgKCFpbWFnZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdGVkQ2hhbm5lbHMgPSBsb2FkU3BlYy5jaGFubmVscztcbiAgICBpZiAocmVxdWVzdGVkQ2hhbm5lbHMpIHtcbiAgICAgIC8vIElmIG9ubHkgc29tZSBjaGFubmVscyBhcmUgcmVxdWVzdGVkLCBsb2FkIG9ubHkgaW1hZ2VzIHdoaWNoIGNvbnRhaW4gYXQgbGVhc3Qgb25lIHJlcXVlc3RlZCBjaGFubmVsXG4gICAgICBpbWFnZXMgPSBpbWFnZXMuZmlsdGVyKCh7XG4gICAgICAgIGNoYW5uZWxzXG4gICAgICB9KSA9PiBjaGFubmVscy5zb21lKGNoID0+IGNoIGluIHJlcXVlc3RlZENoYW5uZWxzKSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyByZWdleCByZW1vdmVzIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGxhc3Qgc2xhc2gsIHNvIHRoZSB1cmwgaGFkIGJldHRlciBiZSBzaW1wbGUuXG4gICAgY29uc3QgdXJsUHJlZml4ID0gdGhpcy51cmxzW2xvYWRTcGVjLnRpbWVdLnJlcGxhY2UoL1teL10qJC8sIFwiXCIpO1xuICAgIGltYWdlcyA9IGltYWdlcy5tYXAoZWxlbWVudCA9PiAoe1xuICAgICAgLi4uZWxlbWVudCxcbiAgICAgIG5hbWU6IHVybFByZWZpeCArIGVsZW1lbnQubmFtZVxuICAgIH0pKTtcblxuICAgIC8vIFVwZGF0ZSBgaW1hZ2VgJ3MgYGxvYWRTcGVjYCBiZWZvcmUgbG9hZGluZ1xuICAgIGNvbnN0IGFkanVzdGVkTG9hZFNwZWMgPSB7XG4gICAgICAuLi5sb2FkU3BlYyxcbiAgICAgIC8vIGBzdWJyZWdpb25gIGFuZCBgbXVsdGlzY2FsZUxldmVsYCBhcmUgdW51c2VkIGJ5IHRoaXMgbG9hZGVyXG4gICAgICBzdWJyZWdpb246IG5ldyBCb3gzKG5ldyBWZWN0b3IzKDAsIDAsIDApLCBuZXcgVmVjdG9yMygxLCAxLCAxKSksXG4gICAgICBtdWx0aXNjYWxlTGV2ZWw6IDAsXG4gICAgICAvLyBpbmNsdWRlIGFsbCBjaGFubmVscyBpbiBhbnkgbG9hZGVkIGltYWdlc1xuICAgICAgY2hhbm5lbHM6IGltYWdlcy5mbGF0TWFwKCh7XG4gICAgICAgIGNoYW5uZWxzXG4gICAgICB9KSA9PiBjaGFubmVscylcbiAgICB9O1xuICAgIG9uVXBkYXRlTWV0YWRhdGEodW5kZWZpbmVkLCBhZGp1c3RlZExvYWRTcGVjKTtcbiAgICBjb25zdCB3ID0gaW1hZ2VJbmZvLmF0bGFzVGlsZURpbXMueCAqIGltYWdlSW5mby52b2x1bWVTaXplLng7XG4gICAgY29uc3QgaCA9IGltYWdlSW5mby5hdGxhc1RpbGVEaW1zLnkgKiBpbWFnZUluZm8udm9sdW1lU2l6ZS55O1xuICAgIGNvbnN0IHdyYXBwZWRPbkRhdGEgPSAoY2gsIGRhdGEsIHJhbmdlcykgPT4gb25EYXRhKGNoLCBkYXRhLCByYW5nZXMsIFt3LCBoXSk7XG4gICAgYXdhaXQgSnNvbkltYWdlSW5mb0xvYWRlci5sb2FkVm9sdW1lQXRsYXNEYXRhKGltYWdlcywgd3JhcHBlZE9uRGF0YSwgdGhpcy5jYWNoZSk7XG4gIH1cblxuICAvKipcclxuICAgKiBsb2FkIHBlci1jaGFubmVsIHZvbHVtZSBkYXRhIGZyb20gYSBiYXRjaCBvZiBpbWFnZSBmaWxlcyBjb250YWluaW5nIHRoZSB2b2x1bWUgc2xpY2VzIHRpbGVkIGFjcm9zcyB0aGUgaW1hZ2VzXHJcbiAgICogQHBhcmFtIHtBcnJheS48e25hbWU6c3RyaW5nLCBjaGFubmVsczpBcnJheS48bnVtYmVyPn0+fSBpbWFnZUFycmF5XHJcbiAgICogQHBhcmFtIHtSYXdDaGFubmVsRGF0YUNhbGxiYWNrfSBvbkRhdGEgUGVyLWNoYW5uZWwgY2FsbGJhY2suIENhbGxlZCB3aGVuIGVhY2ggY2hhbm5lbCdzIGF0bGFzZWQgdm9sdW1lIGRhdGEgaXMgbG9hZGVkXHJcbiAgICogQHBhcmFtIHtWb2x1bWVDYWNoZX0gY2FjaGVcclxuICAgKiBAZXhhbXBsZSBsb2FkVm9sdW1lQXRsYXNEYXRhKFt7XHJcbiAgICogICAgIFwibmFtZVwiOiBcIkFJQ1MtMTBfNV81Lm9tZS50aWZfYXRsYXNfMC5wbmdcIixcclxuICAgKiAgICAgXCJjaGFubmVsc1wiOiBbMCwgMSwgMl1cclxuICAgKiB9LCB7XHJcbiAgICogICAgIFwibmFtZVwiOiBcIkFJQ1MtMTBfNV81Lm9tZS50aWZfYXRsYXNfMS5wbmdcIixcclxuICAgKiAgICAgXCJjaGFubmVsc1wiOiBbMywgNCwgNV1cclxuICAgKiB9LCB7XHJcbiAgICogICAgIFwibmFtZVwiOiBcIkFJQ1MtMTBfNV81Lm9tZS50aWZfYXRsYXNfMi5wbmdcIixcclxuICAgKiAgICAgXCJjaGFubmVsc1wiOiBbNiwgNywgOF1cclxuICAgKiB9XSwgbXljYWxsYmFjayk7XHJcbiAgICovXG4gIHN0YXRpYyBhc3luYyBsb2FkVm9sdW1lQXRsYXNEYXRhKGltYWdlQXJyYXksIG9uRGF0YSwgY2FjaGUpIHtcbiAgICBjb25zdCBpbWFnZVByb21pc2VzID0gaW1hZ2VBcnJheS5tYXAoYXN5bmMgaW1hZ2UgPT4ge1xuICAgICAgLy8gQmVjYXVzZSB0aGUgZGF0YSBpcyBmZXRjaGVkIHN1Y2ggdGhhdCBvbmUgZmV0Y2ggcmV0dXJucyBhIHdob2xlIGJhdGNoLFxuICAgICAgLy8gaWYgYW55IGluIGJhdGNoIGlzIGNhY2hlZCB0aGVuIHRoZXkgYWxsIHNob3VsZCBiZS4gU28gaWYgYW55IGluIGJhdGNoIGlzIE5PVCBjYWNoZWQsXG4gICAgICAvLyB0aGVuIHdlIHdpbGwgaGF2ZSB0byBkbyBhIGJhdGNoIHJlcXVlc3QuIFRoaXMgbG9naWMgd29ya3MgYm90aCB3YXlzIGJlY2F1c2UgaXQncyBhbGwgb3Igbm90aGluZy5cbiAgICAgIGxldCBjYWNoZUhpdCA9IHRydWU7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE1hdGgubWluKGltYWdlLmNoYW5uZWxzLmxlbmd0aCwgNCk7ICsraikge1xuICAgICAgICBjb25zdCBjaGluZGV4ID0gaW1hZ2UuY2hhbm5lbHNbal07XG4gICAgICAgIGNvbnN0IGNhY2hlUmVzdWx0ID0gY2FjaGU/LmdldChgJHtpbWFnZS5uYW1lfS8ke2NoaW5kZXh9YCk7XG4gICAgICAgIGlmIChjYWNoZVJlc3VsdCkge1xuICAgICAgICAgIC8vIGFsbCBkYXRhIGNvbWluZyBmcm9tIHRoaXMgbG9hZGVyIGlzIG5hdGl2ZWx5IDgtYml0XG4gICAgICAgICAgb25EYXRhKFtjaGluZGV4XSwgW25ldyBVaW50OEFycmF5KGNhY2hlUmVzdWx0KV0sIFtEQVRBUkFOR0VfVUlOVDhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZUhpdCA9IGZhbHNlO1xuICAgICAgICAgIC8vIHdlIGNhbiBzdG9wIGNoZWNraW5nIGJlY2F1c2Ugd2Uga25vdyB3ZSBhcmUgZ29pbmcgdG8gaGF2ZSB0byBmZXRjaCB0aGUgd2hvbGUgYmF0Y2hcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiBhbGwgY2hhbm5lbHMgd2VyZSBpbiBjYWNoZSB0aGVuIHdlIGNhbiBtb3ZlIG9uIHRvIHRoZSBuZXh0XG4gICAgICAvLyBpbWFnZSAoYmF0Y2gpIHdpdGhvdXQgcmVxdWVzdGluZ1xuICAgICAgaWYgKGNhY2hlSGl0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goaW1hZ2UubmFtZSwge1xuICAgICAgICBtb2RlOiBcImNvcnNcIlxuICAgICAgfSk7XG4gICAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgY29uc3QgYml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYik7XG4gICAgICBjb25zdCBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBjcmVhdGluZyBjYW52YXMgMmQgY29udGV4dCBmb3IgXCIgKyBpbWFnZS5uYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiY29weVwiO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMS4wO1xuICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApO1xuICAgICAgY29uc3QgaURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCk7XG4gICAgICBjb25zdCBjaGFubmVsc0JpdHMgPSBbXTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGJpdG1hcC53aWR0aCAqIGJpdG1hcC5oZWlnaHQ7XG5cbiAgICAgIC8vIGFsbG9jYXRlIGNoYW5uZWxzIGluIGJhdGNoXG4gICAgICBmb3IgKGxldCBjaCA9IDA7IGNoIDwgTWF0aC5taW4oaW1hZ2UuY2hhbm5lbHMubGVuZ3RoLCA0KTsgKytjaCkge1xuICAgICAgICBjaGFubmVsc0JpdHMucHVzaChuZXcgVWludDhBcnJheShsZW5ndGgpKTtcbiAgICAgIH1cblxuICAgICAgLy8gZXh0cmFjdCB0aGUgZGF0YVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBNYXRoLm1pbihpbWFnZS5jaGFubmVscy5sZW5ndGgsIDQpOyArK2opIHtcbiAgICAgICAgZm9yIChsZXQgcHggPSAwOyBweCA8IGxlbmd0aDsgcHgrKykge1xuICAgICAgICAgIGNoYW5uZWxzQml0c1tqXVtweF0gPSBpRGF0YS5kYXRhW3B4ICogNCArIGpdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGRvbmUgd2l0aCBgaURhdGFgIGFuZCBgY2FudmFzYCBub3cuXG5cbiAgICAgIGZvciAobGV0IGNoID0gMDsgY2ggPCBNYXRoLm1pbihpbWFnZS5jaGFubmVscy5sZW5ndGgsIDQpOyArK2NoKSB7XG4gICAgICAgIGNvbnN0IGNoaW5kZXggPSBpbWFnZS5jaGFubmVsc1tjaF07XG4gICAgICAgIGNhY2hlPy5pbnNlcnQoYCR7aW1hZ2UubmFtZX0vJHtjaGluZGV4fWAsIGNoYW5uZWxzQml0c1tjaF0pO1xuICAgICAgICAvLyBOT1RFOiB0aGUgYXRsYXMgZGltZW5zaW9ucyBwYXNzZWQgaW4gaGVyZSBhcmUgY3VycmVudGx5IHVudXNlZCBieSBgSlNPTkltYWdlSW5mb0xvYWRlcmBcbiAgICAgICAgLy8gYWxsIGRhdGEgY29taW5nIGZyb20gdGhpcyBsb2FkZXIgaXMgbmF0aXZlbHkgOC1iaXRcbiAgICAgICAgb25EYXRhKFtjaGluZGV4XSwgW2NoYW5uZWxzQml0c1tjaF1dLCBbREFUQVJBTkdFX1VJTlQ4XSwgW2JpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodF0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKGltYWdlUHJvbWlzZXMpO1xuICB9XG59XG5leHBvcnQgeyBKc29uSW1hZ2VJbmZvTG9hZGVyIH07Il0sIm5hbWVzIjpbIkJveDMiLCJWZWN0b3IyIiwiVmVjdG9yMyIsIlRocmVhZGFibGVWb2x1bWVMb2FkZXIiLCJWb2x1bWVEaW1zIiwiREFUQVJBTkdFX1VJTlQ4IiwiY29udmVydEltYWdlSW5mbyIsImpzb24iLCJuYW1lIiwib3JpZ2luYWxTaXplIiwid2lkdGgiLCJoZWlnaHQiLCJ0aWxlcyIsImF0bGFzVGlsZURpbXMiLCJjb2xzIiwicm93cyIsInZvbHVtZVNpemUiLCJ0aWxlX3dpZHRoIiwidGlsZV9oZWlnaHQiLCJzdWJyZWdpb25TaXplIiwic3VicmVnaW9uT2Zmc2V0IiwicGh5c2ljYWxQaXhlbFNpemUiLCJwaXhlbF9zaXplX3giLCJwaXhlbF9zaXplX3kiLCJwaXhlbF9zaXplX3oiLCJzcGF0aWFsVW5pdCIsInBpeGVsX3NpemVfdW5pdCIsIm51bUNoYW5uZWxzIiwiY2hhbm5lbHMiLCJjaGFubmVsTmFtZXMiLCJjaGFubmVsX25hbWVzIiwiY2hhbm5lbENvbG9ycyIsImNoYW5uZWxfY29sb3JzIiwidGltZXMiLCJ0aW1lU2NhbGUiLCJ0aW1lX3NjYWxlIiwidGltZVVuaXQiLCJ0aW1lX3VuaXQiLCJudW1NdWx0aXNjYWxlTGV2ZWxzIiwibXVsdGlzY2FsZUxldmVsIiwidHJhbnNmb3JtIiwidHJhbnNsYXRpb24iLCJmcm9tQXJyYXkiLCJyb3RhdGlvbiIsInVzZXJEYXRhIiwiSnNvbkltYWdlSW5mb0xvYWRlciIsImNvbnN0cnVjdG9yIiwidXJscyIsImNhY2hlIiwiQXJyYXkiLCJpc0FycmF5IiwianNvbkluZm8iLCJsZW5ndGgiLCJnZXRKc29uSW1hZ2VJbmZvIiwidGltZSIsImNhY2hlZEluZm8iLCJyZXNwb25zZSIsImZldGNoIiwiaW1hZ2VJbmZvIiwibG9hZERpbXMiLCJsb2FkU3BlYyIsImQiLCJzaGFwZSIsInNwYWNpbmciLCJzcGFjZVVuaXQiLCJkYXRhVHlwZSIsImNyZWF0ZUltYWdlSW5mbyIsImxvYWRSYXdDaGFubmVsRGF0YSIsIm9uVXBkYXRlTWV0YWRhdGEiLCJvbkRhdGEiLCJpbWFnZXMiLCJyZXF1ZXN0ZWRDaGFubmVscyIsImZpbHRlciIsInNvbWUiLCJjaCIsInVybFByZWZpeCIsInJlcGxhY2UiLCJtYXAiLCJlbGVtZW50IiwiYWRqdXN0ZWRMb2FkU3BlYyIsInN1YnJlZ2lvbiIsImZsYXRNYXAiLCJ1bmRlZmluZWQiLCJ3IiwieCIsImgiLCJ5Iiwid3JhcHBlZE9uRGF0YSIsImRhdGEiLCJyYW5nZXMiLCJsb2FkVm9sdW1lQXRsYXNEYXRhIiwiaW1hZ2VBcnJheSIsImltYWdlUHJvbWlzZXMiLCJpbWFnZSIsImNhY2hlSGl0IiwiaiIsIk1hdGgiLCJtaW4iLCJjaGluZGV4IiwiY2FjaGVSZXN1bHQiLCJnZXQiLCJVaW50OEFycmF5IiwibW9kZSIsImJsb2IiLCJiaXRtYXAiLCJjcmVhdGVJbWFnZUJpdG1hcCIsImNhbnZhcyIsIk9mZnNjcmVlbkNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJjb25zb2xlIiwibG9nIiwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIiwiZ2xvYmFsQWxwaGEiLCJkcmF3SW1hZ2UiLCJpRGF0YSIsImdldEltYWdlRGF0YSIsImNoYW5uZWxzQml0cyIsInB1c2giLCJweCIsImluc2VydCIsIlByb21pc2UiLCJhbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../volume-viewer/es/loaders/JsonImageInfoLoader.js\n");

/***/ }),

/***/ "../volume-viewer/es/loaders/OmeZarrLoader.js":
/*!****************************************************!*\
  !*** ../volume-viewer/es/loaders/OmeZarrLoader.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OMEZarrLoader: () => (/* binding */ OMEZarrLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! three */ \"../volume-viewer/node_modules/three/build/three.module.js\");\n/* harmony import */ var _zarrita_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @zarrita/core */ \"../volume-viewer/node_modules/@zarrita/core/dist/src/hierarchy.js\");\n/* harmony import */ var _zarrita_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @zarrita/core */ \"../volume-viewer/node_modules/@zarrita/core/dist/src/open.js\");\n/* harmony import */ var _zarrita_indexing__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @zarrita/indexing */ \"../volume-viewer/node_modules/@zarrita/indexing/dist/src/util.js\");\n/* harmony import */ var _zarrita_indexing__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @zarrita/indexing */ \"../volume-viewer/node_modules/@zarrita/indexing/dist/src/ops.js\");\n/* harmony import */ var zarrita__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! zarrita */ \"../volume-viewer/node_modules/@zarrita/storage/dist/src/fetch.js\");\n/* harmony import */ var _utils_SubscribableRequestQueue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/SubscribableRequestQueue.js */ \"../volume-viewer/es/utils/SubscribableRequestQueue.js\");\n/* harmony import */ var _IVolumeLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IVolumeLoader.js */ \"../volume-viewer/es/loaders/IVolumeLoader.js\");\n/* harmony import */ var _VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VolumeLoaderUtils.js */ \"../volume-viewer/es/loaders/VolumeLoaderUtils.js\");\n/* harmony import */ var _zarr_utils_ChunkPrefetchIterator_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./zarr_utils/ChunkPrefetchIterator.js */ \"../volume-viewer/es/loaders/zarr_utils/ChunkPrefetchIterator.js\");\n/* harmony import */ var _zarr_utils_WrappedStore_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zarr_utils/WrappedStore.js */ \"../volume-viewer/es/loaders/zarr_utils/WrappedStore.js\");\n/* harmony import */ var _zarr_utils_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zarr_utils/utils.js */ \"../volume-viewer/es/loaders/zarr_utils/utils.js\");\n/* harmony import */ var _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./VolumeLoadError.js */ \"../volume-viewer/es/loaders/VolumeLoadError.js\");\n/* harmony import */ var _zarr_utils_validation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./zarr_utils/validation.js */ \"../volume-viewer/es/loaders/zarr_utils/validation.js\");\n\n\n\n// Importing `FetchStore` from its home subpackage (@zarrita/storage) causes errors.\n// Getting it from the top-level package means we don't get its type. This is also a bug, but it's more acceptable.\n\n\n\n\n\n\n\n\n\nconst CHUNK_REQUEST_CANCEL_REASON = \"chunk request cancelled\";\n\n// returns the converted data and the original min and max values (which have been remapped to 0 and 255)\nfunction convertChannel(channelData) {\n  // get min and max\n  let min = channelData[0];\n  let max = channelData[0];\n  for (let i = 0; i < channelData.length; i++) {\n    const val = channelData[i];\n    if (val < min) {\n      min = val;\n    }\n    if (val > max) {\n      max = val;\n    }\n  }\n  if (channelData instanceof Uint8Array) {\n    return [channelData, min, max];\n  }\n\n  // normalize and convert to u8\n  const u8 = new Uint8Array(channelData.length);\n  const range = max - min;\n  for (let i = 0; i < channelData.length; i++) {\n    u8[i] = (channelData[i] - min) / range * 255;\n  }\n  return [u8, min, max];\n}\nconst DEFAULT_FETCH_OPTIONS = {\n  maxPrefetchDistance: [5, 5, 5, 5],\n  maxPrefetchChunks: 30\n};\nclass OMEZarrLoader extends _IVolumeLoader_js__WEBPACK_IMPORTED_MODULE_1__.ThreadableVolumeLoader {\n  /** The ID of the subscriber responsible for \"actual loads\" (non-prefetch requests) */\n\n  /** The ID of the subscriber responsible for prefetches, so that requests can be cancelled and reissued */\n\n  // TODO: this property should definitely be owned by `Volume` if this loader is ever used by multiple volumes.\n  //   This may cause errors or incorrect results otherwise!\n\n  syncChannels = false;\n  constructor(\n  /**\r\n   * Array of records, each containing the objects and metadata we need to load from one source of multiscale zarr\r\n   * data. See documentation on `ZarrSource` for more.\r\n   */\n  sources, /** Handle to a `SubscribableRequestQueue` for smart concurrency management and request cancelling/reissuing. */\n  requestQueue, /** Options to configure (pre)fetching behavior. */\n  fetchOptions = DEFAULT_FETCH_OPTIONS, /** Direction(s) to prioritize when prefetching. Stored separate from `fetchOptions` since it may be mutated. */\n  priorityDirections = []) {\n    super();\n    this.sources = sources;\n    this.requestQueue = requestQueue;\n    this.fetchOptions = fetchOptions;\n    this.priorityDirections = priorityDirections;\n  }\n\n  /**\r\n   * Creates a new `OMEZarrLoader`.\r\n   *\r\n   * @param urls The URL(s) of the OME-Zarr data to load. If `urls` is an array, the loader will attempt to find scale\r\n   *  levels with exactly the same size in every source. If matching level(s) are available, the loader will produce a\r\n   *  volume containing all channels from every provided zarr in the order they appear in `urls`. If no matching sets\r\n   *  of scale levels are available, creation fails.\r\n   * @param scenes The scene(s) to load from each URL. If `urls` is an array, `scenes` may either be an array of values\r\n   *  corresponding to each URL, or a single value to apply to all URLs. Default 0.\r\n   * @param cache A cache to use for storing fetched data. If not provided, a new cache will be created.\r\n   * @param queue A queue to use for managing requests. If not provided, a new queue will be created.\r\n   * @param fetchOptions Options to configure (pre)fetching behavior.\r\n   */\n  static async createLoader(urls, scenes = 0, cache, queue, fetchOptions) {\n    // Setup queue and store, get basic metadata\n    if (!queue) {\n      queue = new _utils_SubscribableRequestQueue_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](fetchOptions?.concurrencyLimit, fetchOptions?.prefetchConcurrencyLimit);\n    }\n    const urlsArr = Array.isArray(urls) ? urls : [urls];\n    const scenesArr = Array.isArray(scenes) ? scenes : [scenes];\n\n    // Create one `ZarrSource` per URL\n    const sourceProms = urlsArr.map(async (url, i) => {\n      const store = new _zarr_utils_WrappedStore_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](new zarrita__WEBPACK_IMPORTED_MODULE_8__[\"default\"](url), cache, queue);\n      const root = _zarrita_core__WEBPACK_IMPORTED_MODULE_9__.root(store);\n      const group = await _zarrita_core__WEBPACK_IMPORTED_MODULE_10__.open(root, {\n        kind: \"group\"\n      }).catch((0,_VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_6__.wrapVolumeLoadError)(`Failed to open OME-Zarr data at ${url}`, _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_6__.VolumeLoadErrorType.NOT_FOUND));\n\n      // Pick scene (multiscale)\n      let scene = scenesArr[Math.min(i, scenesArr.length - 1)];\n      if (scene > group.attrs.multiscales?.length) {\n        console.warn(`WARNING: OMEZarrLoader: scene ${scene} is invalid. Using scene 0.`);\n        scene = 0;\n      }\n      (0,_zarr_utils_validation_js__WEBPACK_IMPORTED_MODULE_7__.validateOMEZarrMetadata)(group.attrs, scene, urlsArr.length > 1 ? `Zarr source ${i}` : \"Zarr\");\n      const {\n        multiscales,\n        omero\n      } = group.attrs;\n      const multiscaleMetadata = multiscales[scene];\n\n      // Open all scale levels of multiscale\n      const lvlProms = multiscaleMetadata.datasets.map(({\n        path\n      }) => _zarrita_core__WEBPACK_IMPORTED_MODULE_10__.open(root.resolve(path), {\n        kind: \"array\"\n      }).catch((0,_VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_6__.wrapVolumeLoadError)(`Failed to open scale level ${path} of OME-Zarr data at ${url}`, _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_6__.VolumeLoadErrorType.NOT_FOUND)));\n      const scaleLevels = await Promise.all(lvlProms);\n      const axesTCZYX = (0,_zarr_utils_utils_js__WEBPACK_IMPORTED_MODULE_5__.remapAxesToTCZYX)(multiscaleMetadata.axes);\n      return {\n        scaleLevels,\n        multiscaleMetadata,\n        omeroMetadata: omero,\n        axesTCZYX,\n        channelOffset: 0\n      };\n    });\n    const sources = await Promise.all(sourceProms);\n\n    // Set `channelOffset`s so we can match channel indices to sources\n    let channelCount = 0;\n    for (const s of sources) {\n      s.channelOffset = channelCount;\n      channelCount += s.omeroMetadata?.channels.length ?? s.scaleLevels[0].shape[s.axesTCZYX[1]];\n    }\n    // Ensure the sizes of all sources' scale levels are matched up. See this function's docs for more.\n    (0,_zarr_utils_utils_js__WEBPACK_IMPORTED_MODULE_5__.matchSourceScaleLevels)(sources);\n    // TODO: if `matchSourceScaleLevels` returned successfully, every one of these sources' `multiscaleMetadata` is the\n    // same in every field we care about, so we only ever use the first source's `multiscaleMetadata` after this point.\n    // Should we only store one `OMEMultiscale` record total, rather than one per source?\n    const priorityDirs = fetchOptions?.priorityDirections ? fetchOptions.priorityDirections.slice() : undefined;\n    return new OMEZarrLoader(sources, queue, fetchOptions, priorityDirs);\n  }\n  getUnitSymbols() {\n    const source = this.sources[0];\n    // Assume all spatial axes in all sources have the same units - we have no means of storing per-axis unit symbols\n    const xi = source.axesTCZYX[4];\n    const spaceUnitName = source.multiscaleMetadata.axes[xi].unit;\n    const spaceUnitSymbol = (0,_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_2__.unitNameToSymbol)(spaceUnitName) || spaceUnitName || \"\";\n    const ti = source.axesTCZYX[0];\n    const timeUnitName = ti > -1 ? source.multiscaleMetadata.axes[ti].unit : undefined;\n    const timeUnitSymbol = (0,_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_2__.unitNameToSymbol)(timeUnitName) || timeUnitName || \"\";\n    return [spaceUnitSymbol, timeUnitSymbol];\n  }\n  getLevelShapesZYX() {\n    const source = this.sources[0];\n    const [z, y, x] = source.axesTCZYX.slice(-3);\n    return source.scaleLevels.map(({\n      shape\n    }) => [z === -1 ? 1 : shape[z], shape[y], shape[x]]);\n  }\n  getScale(level) {\n    return (0,_zarr_utils_utils_js__WEBPACK_IMPORTED_MODULE_5__.getScale)(this.sources[0].multiscaleMetadata.datasets[level], this.sources[0].axesTCZYX);\n  }\n  orderByDimension(valsTCZYX, sourceIdx = 0) {\n    return (0,_zarr_utils_utils_js__WEBPACK_IMPORTED_MODULE_5__.orderByDimension)(valsTCZYX, this.sources[sourceIdx].axesTCZYX);\n  }\n  orderByTCZYX(valsDimension, defaultValue, sourceIdx = 0) {\n    return (0,_zarr_utils_utils_js__WEBPACK_IMPORTED_MODULE_5__.orderByTCZYX)(valsDimension, this.sources[sourceIdx].axesTCZYX, defaultValue);\n  }\n\n  /**\r\n   * Converts a volume channel index to the index of its zarr source and its channel index within that zarr.\r\n   * e.g., if the loader has 2 sources, the first with 3 channels and the second with 2, then `matchChannelToSource(4)`\r\n   * returns `[1, 1]` (the second channel of the second source).\r\n   */\n  matchChannelToSource(absoluteChannelIndex) {\n    const lastSrcIdx = this.sources.length - 1;\n    const lastSrc = this.sources[lastSrcIdx];\n    const lastSrcNumChannels = lastSrc.scaleLevels[0].shape[lastSrc.axesTCZYX[1]];\n    const maxChannelIndex = lastSrc.channelOffset + lastSrcNumChannels;\n    if (absoluteChannelIndex > maxChannelIndex) {\n      throw new _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_6__.VolumeLoadError(`Volume channel index ${absoluteChannelIndex} out of range (${maxChannelIndex} channels available)`, {\n        type: _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_6__.VolumeLoadErrorType.INVALID_METADATA\n      });\n    }\n    const firstGreaterIdx = this.sources.findIndex(src => src.channelOffset > absoluteChannelIndex);\n    const sourceIndex = firstGreaterIdx === -1 ? lastSrcIdx : firstGreaterIdx - 1;\n    const channelIndexInSource = absoluteChannelIndex - this.sources[sourceIndex].channelOffset;\n    return {\n      sourceIndex,\n      channelIndexInSource\n    };\n  }\n\n  /**\r\n   * Change which directions to prioritize when prefetching. All chunks will be prefetched in these directions before\r\n   * any chunks are prefetched in any other directions.\r\n   */\n  setPrefetchPriority(directions) {\n    this.priorityDirections = directions;\n  }\n  syncMultichannelLoading(sync) {\n    this.syncChannels = sync;\n  }\n  loadDims(loadSpec) {\n    const [spaceUnit, timeUnit] = this.getUnitSymbols();\n    // Compute subregion size so we can factor that in\n    const maxExtent = this.maxExtent ?? new three__WEBPACK_IMPORTED_MODULE_11__.Box3(new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(1, 1, 1));\n    const subregion = (0,_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_2__.composeSubregion)(loadSpec.subregion, maxExtent);\n    const regionSize = subregion.getSize(new three__WEBPACK_IMPORTED_MODULE_11__.Vector3());\n    const regionArr = [1, 1, regionSize.z, regionSize.y, regionSize.x];\n    const result = this.sources[0].scaleLevels.map((level, i) => {\n      const scale = this.getScale(i);\n      const dims = new _IVolumeLoader_js__WEBPACK_IMPORTED_MODULE_1__.VolumeDims();\n      dims.spaceUnit = spaceUnit;\n      dims.timeUnit = timeUnit;\n      dims.shape = this.orderByTCZYX(level.shape, 1).map((val, idx) => Math.max(Math.ceil(val * regionArr[idx]), 1));\n      dims.spacing = this.orderByTCZYX(scale, 1);\n      return dims;\n    });\n    return Promise.resolve(result);\n  }\n  createImageInfo(loadSpec) {\n    // We ensured most info (dims, chunks, etc.) matched between sources earlier, so we can just use the first source.\n    const source0 = this.sources[0];\n    const [t,, z, y, x] = source0.axesTCZYX;\n    const hasT = t > -1;\n    const hasZ = z > -1;\n    const shape0 = source0.scaleLevels[0].shape;\n    const levelToLoad = (0,_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_2__.pickLevelToLoad)(loadSpec, this.getLevelShapesZYX());\n    const shapeLv = source0.scaleLevels[levelToLoad].shape;\n    const [spatialUnit, timeUnit] = this.getUnitSymbols();\n\n    // Now we care about other sources: # of channels is the `channelOffset` of the last source plus its # of channels\n    const sourceLast = this.sources[this.sources.length - 1];\n    const cLast = sourceLast.axesTCZYX[1];\n    const lastHasC = cLast > -1;\n    const numChannels = sourceLast.channelOffset + (lastHasC ? sourceLast.scaleLevels[levelToLoad].shape[cLast] : 1);\n    // we need to make sure that the corresponding matched shapes\n    // use the min size of T\n    let times = 1;\n    if (hasT) {\n      times = shapeLv[t];\n      for (let i = 0; i < this.sources.length; i++) {\n        const shape = this.sources[i].scaleLevels[levelToLoad].shape;\n        const tindex = this.sources[i].axesTCZYX[0];\n        if (shape[tindex] < times) {\n          console.warn(\"The number of time points is not consistent across sources: \", shape[tindex], times);\n          times = shape[tindex];\n        }\n      }\n    }\n    if (!this.maxExtent) {\n      this.maxExtent = loadSpec.subregion.clone();\n    }\n    const pxDims0 = (0,_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_2__.convertSubregionToPixels)(loadSpec.subregion, new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(shape0[x], shape0[y], hasZ ? shape0[z] : 1));\n    const pxSize0 = pxDims0.getSize(new three__WEBPACK_IMPORTED_MODULE_11__.Vector3());\n    const pxDimsLv = (0,_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_2__.convertSubregionToPixels)(loadSpec.subregion, new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(shapeLv[x], shapeLv[y], hasZ ? shapeLv[z] : 1));\n    const pxSizeLv = pxDimsLv.getSize(new three__WEBPACK_IMPORTED_MODULE_11__.Vector3());\n    const atlasTileDims = (0,_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_2__.computePackedAtlasDims)(pxSizeLv.z, pxSizeLv.x, pxSizeLv.y);\n\n    // Channel names is the other place where we have to check every source\n    // Track which channel names we've seen so far, so that we can rename them to avoid name collisions\n    const channelNamesMap = new Map();\n    const channelNames = this.sources.flatMap(src => {\n      const sourceChannelNames = (0,_zarr_utils_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSourceChannelNames)(src);\n\n      // Resolve name collisions\n      return sourceChannelNames.map(channelName => {\n        const numMatchingChannels = channelNamesMap.get(channelName);\n        if (numMatchingChannels !== undefined) {\n          // If e.g. we've seen channel \"Membrane\" once before, rename this one to \"Membrane (1)\"\n          channelNamesMap.set(channelName, numMatchingChannels + 1);\n          return `${channelName} (${numMatchingChannels})`;\n        } else {\n          channelNamesMap.set(channelName, 1);\n          return channelName;\n        }\n      });\n    });\n\n    // for physicalPixelSize, we use the scale of the first level\n    const scale5d = this.getScale(0);\n    // assume that ImageInfo wants the timeScale of level 0\n    const timeScale = hasT ? scale5d[t] : 1;\n    const imgdata = {\n      name: source0.omeroMetadata?.name || \"Volume\",\n      originalSize: pxSize0,\n      atlasTileDims,\n      volumeSize: pxSizeLv,\n      subregionSize: pxSizeLv.clone(),\n      subregionOffset: new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(0, 0, 0),\n      physicalPixelSize: new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(scale5d[x], scale5d[y], hasZ ? scale5d[z] : Math.min(scale5d[x], scale5d[y])),\n      spatialUnit,\n      numChannels,\n      channelNames,\n      times,\n      timeScale,\n      timeUnit,\n      numMultiscaleLevels: source0.scaleLevels.length,\n      multiscaleLevel: levelToLoad,\n      transform: {\n        translation: new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(0, 0, 0),\n        rotation: new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(0, 0, 0)\n      }\n    };\n\n    // The `LoadSpec` passed in at this stage should represent the subset which this loader loads, not that\n    // which the volume contains. The volume contains the full extent of the subset recognized by this loader.\n    const fullExtentLoadSpec = {\n      ...loadSpec,\n      subregion: new three__WEBPACK_IMPORTED_MODULE_11__.Box3(new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(1, 1, 1))\n    };\n    return Promise.resolve({\n      imageInfo: imgdata,\n      loadSpec: fullExtentLoadSpec\n    });\n  }\n  async prefetchChunk(scaleLevel, coords, subscriber) {\n    const {\n      store,\n      path\n    } = scaleLevel;\n    const separator = path.endsWith(\"/\") ? \"\" : \"/\";\n    const key = path + separator + this.orderByDimension(coords).join(\"/\");\n    // Calling `get` and doing nothing with the result still triggers a cache check, fetch, and insertion\n    await store.get(key, {\n      subscriber,\n      isPrefetch: true\n    }).catch((0,_VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_6__.wrapVolumeLoadError)(`Unable to prefetch chunk with key ${key}`, _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_6__.VolumeLoadErrorType.LOAD_DATA_FAILED, CHUNK_REQUEST_CANCEL_REASON));\n  }\n\n  /** Reads a list of chunk keys requested by a `loadVolumeData` call and sets up appropriate prefetch requests. */\n  beginPrefetch(keys, scaleLevel) {\n    // Convert keys to arrays of coords\n    const chunkCoords = keys.map(({\n      sourceIdx,\n      key\n    }) => {\n      const numDims = (0,_zarr_utils_utils_js__WEBPACK_IMPORTED_MODULE_5__.getDimensionCount)(this.sources[sourceIdx].axesTCZYX);\n      const coordsInDimensionOrder = key.trim().split(\"/\").slice(-numDims).filter(s => s !== \"\").map(s => parseInt(s, 10));\n      const sourceCoords = this.orderByTCZYX(coordsInDimensionOrder, 0, sourceIdx);\n      // Convert source channel index to absolute channel index for `ChunkPrefetchIterator`'s benefit\n      // (we match chunk coordinates output from `ChunkPrefetchIterator` back to sources below)\n      sourceCoords[1] += this.sources[sourceIdx].channelOffset;\n      return sourceCoords;\n    });\n\n    // Get number of chunks per dimension in every source array\n    const chunkDimsTCZYX = this.sources.map(src => {\n      const level = src.scaleLevels[scaleLevel];\n      const chunkDimsUnordered = level.shape.map((dim, idx) => Math.ceil(dim / level.chunks[idx]));\n      return this.orderByTCZYX(chunkDimsUnordered, 1);\n    });\n    // `ChunkPrefetchIterator` yields chunk coordinates in order of roughly how likely they are to be loaded next\n    const prefetchIterator = new _zarr_utils_ChunkPrefetchIterator_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](chunkCoords, this.fetchOptions.maxPrefetchDistance, chunkDimsTCZYX, this.priorityDirections);\n    const subscriber = this.requestQueue.addSubscriber();\n    let prefetchCount = 0;\n    for (const chunk of prefetchIterator) {\n      if (prefetchCount >= this.fetchOptions.maxPrefetchChunks) {\n        break;\n      }\n      // Match absolute channel coordinate back to source index and channel index\n      const {\n        sourceIndex,\n        channelIndexInSource\n      } = this.matchChannelToSource(chunk[1]);\n      const sourceScaleLevel = this.sources[sourceIndex].scaleLevels[scaleLevel];\n      chunk[1] = channelIndexInSource;\n      this.prefetchChunk(sourceScaleLevel, chunk, subscriber);\n      prefetchCount++;\n    }\n\n    // Clear out old prefetch requests (requests which also cover this new prefetch will be preserved)\n    if (this.prefetchSubscriber !== undefined) {\n      this.requestQueue.removeSubscriber(this.prefetchSubscriber, CHUNK_REQUEST_CANCEL_REASON);\n    }\n    this.prefetchSubscriber = subscriber;\n  }\n  updateImageInfoForLoad(imageInfo, loadSpec) {\n    // Apply `this.maxExtent` to subregion, if it exists\n    const maxExtent = this.maxExtent ?? new three__WEBPACK_IMPORTED_MODULE_11__.Box3(new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(1, 1, 1));\n    const subregion = (0,_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_2__.composeSubregion)(loadSpec.subregion, maxExtent);\n\n    // Pick the level to load based on the subregion size\n    const multiscaleLevel = (0,_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_2__.pickLevelToLoad)({\n      ...loadSpec,\n      subregion\n    }, this.getLevelShapesZYX());\n    const array0Shape = this.sources[0].scaleLevels[multiscaleLevel].shape;\n\n    // Convert subregion to volume voxels\n    const [z, y, x] = this.sources[0].axesTCZYX.slice(2);\n    const regionPx = (0,_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_2__.convertSubregionToPixels)(subregion, new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(array0Shape[x], array0Shape[y], z === -1 ? 1 : array0Shape[z]));\n\n    // Derive other image info properties from subregion and level to load\n    const subregionSize = regionPx.getSize(new three__WEBPACK_IMPORTED_MODULE_11__.Vector3());\n    const atlasTileDims = (0,_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_2__.computePackedAtlasDims)(subregionSize.z, subregionSize.x, subregionSize.y);\n    const volumeExtent = (0,_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_2__.convertSubregionToPixels)(maxExtent, new three__WEBPACK_IMPORTED_MODULE_11__.Vector3(array0Shape[x], array0Shape[y], z === -1 ? 1 : array0Shape[z]));\n    const volumeSize = volumeExtent.getSize(new three__WEBPACK_IMPORTED_MODULE_11__.Vector3());\n    return {\n      ...imageInfo,\n      atlasTileDims,\n      volumeSize,\n      subregionSize,\n      subregionOffset: regionPx.min,\n      multiscaleLevel\n    };\n  }\n  async loadRawChannelData(imageInfo, loadSpec, onUpdateMetadata, onData) {\n    // This seemingly useless line keeps a stable local copy of `syncChannels` which the async closures below capture\n    // so that changes to `this.syncChannels` don't affect the behavior of loads in progress.\n    const syncChannels = this.syncChannels;\n    const updatedImageInfo = this.updateImageInfoForLoad(imageInfo, loadSpec);\n    onUpdateMetadata(updatedImageInfo);\n    const {\n      numChannels,\n      multiscaleLevel\n    } = updatedImageInfo;\n    const channelIndexes = loadSpec.channels ?? Array.from({\n      length: numChannels\n    }, (_, i) => i);\n    const subscriber = this.requestQueue.addSubscriber();\n\n    // Prefetch housekeeping: we want to save keys involved in this load to prefetch later\n    const keys = [];\n    const reportKeyBase = (sourceIdx, key, sub) => {\n      if (sub === subscriber) {\n        keys.push({\n          sourceIdx,\n          key\n        });\n      }\n    };\n    const resultChannelIndices = [];\n    const resultChannelData = [];\n    const resultChannelRanges = [];\n    const channelPromises = channelIndexes.map(async ch => {\n      // Build slice spec\n      const min = updatedImageInfo.subregionOffset;\n      const max = min.clone().add(updatedImageInfo.subregionSize);\n      const {\n        sourceIndex: sourceIdx,\n        channelIndexInSource: sourceCh\n      } = this.matchChannelToSource(ch);\n      const unorderedSpec = [loadSpec.time, sourceCh, (0,_zarrita_indexing__WEBPACK_IMPORTED_MODULE_12__.slice)(min.z, max.z), (0,_zarrita_indexing__WEBPACK_IMPORTED_MODULE_12__.slice)(min.y, max.y), (0,_zarrita_indexing__WEBPACK_IMPORTED_MODULE_12__.slice)(min.x, max.x)];\n      const level = this.sources[sourceIdx].scaleLevels[multiscaleLevel];\n      const sliceSpec = this.orderByDimension(unorderedSpec, sourceIdx);\n      const reportKey = (key, sub) => reportKeyBase(sourceIdx, key, sub);\n      const result = await (0,_zarrita_indexing__WEBPACK_IMPORTED_MODULE_13__.get)(level, sliceSpec, {\n        opts: {\n          subscriber,\n          reportKey\n        }\n      }).catch((0,_VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_6__.wrapVolumeLoadError)(\"Could not load OME-Zarr volume data\", _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_6__.VolumeLoadErrorType.LOAD_DATA_FAILED, CHUNK_REQUEST_CANCEL_REASON));\n      if (result?.data === undefined) {\n        return;\n      }\n      const converted = convertChannel(result.data);\n      if (syncChannels) {\n        resultChannelData.push(converted[0]);\n        resultChannelIndices.push(ch);\n        resultChannelRanges.push([converted[1], converted[2]]);\n      } else {\n        onData([ch], [converted[0]], [[converted[1], converted[2]]]);\n      }\n    });\n\n    // Cancel any in-flight requests from previous loads that aren't useful to this one\n    if (this.loadSubscriber !== undefined) {\n      this.requestQueue.removeSubscriber(this.loadSubscriber, CHUNK_REQUEST_CANCEL_REASON);\n    }\n    this.loadSubscriber = subscriber;\n    this.beginPrefetch(keys, multiscaleLevel);\n    await Promise.all(channelPromises);\n    if (syncChannels) {\n      onData(resultChannelIndices, resultChannelData, resultChannelRanges);\n    }\n    this.requestQueue.removeSubscriber(subscriber, CHUNK_REQUEST_CANCEL_REASON);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL09tZVphcnJMb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ0E7QUFDb0I7QUFDMUQ7QUFDQTtBQUNxQztBQUN1QztBQUNKO0FBQ3VFO0FBQ3JFO0FBQ2xCO0FBQzZHO0FBQ3BFO0FBQzVCO0FBQ3JFLE1BQU00QiwyQkFBMkIsR0FBRyx5QkFBeUI7O0FBRTdEO0FBQ0EsU0FBU0MsY0FBY0EsQ0FBQ0MsV0FBVyxFQUFFO0VBQ25DO0VBQ0EsSUFBSUMsR0FBRyxHQUFHRCxXQUFXLENBQUMsQ0FBQyxDQUFDO0VBQ3hCLElBQUlFLEdBQUcsR0FBR0YsV0FBVyxDQUFDLENBQUMsQ0FBQztFQUN4QixLQUFLLElBQUlHLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0gsV0FBVyxDQUFDSSxNQUFNLEVBQUVELENBQUMsRUFBRSxFQUFFO0lBQzNDLE1BQU1FLEdBQUcsR0FBR0wsV0FBVyxDQUFDRyxDQUFDLENBQUM7SUFDMUIsSUFBSUUsR0FBRyxHQUFHSixHQUFHLEVBQUU7TUFDYkEsR0FBRyxHQUFHSSxHQUFHO0lBQ1g7SUFDQSxJQUFJQSxHQUFHLEdBQUdILEdBQUcsRUFBRTtNQUNiQSxHQUFHLEdBQUdHLEdBQUc7SUFDWDtFQUNGO0VBQ0EsSUFBSUwsV0FBVyxZQUFZTSxVQUFVLEVBQUU7SUFDckMsT0FBTyxDQUFDTixXQUFXLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxDQUFDO0VBQ2hDOztFQUVBO0VBQ0EsTUFBTUssRUFBRSxHQUFHLElBQUlELFVBQVUsQ0FBQ04sV0FBVyxDQUFDSSxNQUFNLENBQUM7RUFDN0MsTUFBTUksS0FBSyxHQUFHTixHQUFHLEdBQUdELEdBQUc7RUFDdkIsS0FBSyxJQUFJRSxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdILFdBQVcsQ0FBQ0ksTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtJQUMzQ0ksRUFBRSxDQUFDSixDQUFDLENBQUMsR0FBRyxDQUFDSCxXQUFXLENBQUNHLENBQUMsQ0FBQyxHQUFHRixHQUFHLElBQUlPLEtBQUssR0FBRyxHQUFHO0VBQzlDO0VBQ0EsT0FBTyxDQUFDRCxFQUFFLEVBQUVOLEdBQUcsRUFBRUMsR0FBRyxDQUFDO0FBQ3ZCO0FBQ0EsTUFBTU8scUJBQXFCLEdBQUc7RUFDNUJDLG1CQUFtQixFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0VBQ2pDQyxpQkFBaUIsRUFBRTtBQUNyQixDQUFDO0FBQ0QsTUFBTUMsYUFBYSxTQUFTbEMscUVBQXNCLENBQUM7RUFDakQ7O0VBRUE7O0VBRUE7RUFDQTs7RUFFQW1DLFlBQVksR0FBRyxLQUFLO0VBQ3BCQyxXQUFXQTtFQUNYO0FBQ0Y7QUFDQTtBQUNBO0VBQ0VDLE9BQU8sRUFBRTtFQUNUQyxZQUFZLEVBQUU7RUFDZEMsWUFBWSxHQUFHUixxQkFBcUIsRUFBRTtFQUN0Q1Msa0JBQWtCLEdBQUcsRUFBRSxFQUFFO0lBQ3ZCLEtBQUssQ0FBQyxDQUFDO0lBQ1AsSUFBSSxDQUFDSCxPQUFPLEdBQUdBLE9BQU87SUFDdEIsSUFBSSxDQUFDQyxZQUFZLEdBQUdBLFlBQVk7SUFDaEMsSUFBSSxDQUFDQyxZQUFZLEdBQUdBLFlBQVk7SUFDaEMsSUFBSSxDQUFDQyxrQkFBa0IsR0FBR0Esa0JBQWtCO0VBQzlDOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsYUFBYUMsWUFBWUEsQ0FBQ0MsSUFBSSxFQUFFQyxNQUFNLEdBQUcsQ0FBQyxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRU4sWUFBWSxFQUFFO0lBQ3RFO0lBQ0EsSUFBSSxDQUFDTSxLQUFLLEVBQUU7TUFDVkEsS0FBSyxHQUFHLElBQUk5QywwRUFBd0IsQ0FBQ3dDLFlBQVksRUFBRU8sZ0JBQWdCLEVBQUVQLFlBQVksRUFBRVEsd0JBQXdCLENBQUM7SUFDOUc7SUFDQSxNQUFNQyxPQUFPLEdBQUdDLEtBQUssQ0FBQ0MsT0FBTyxDQUFDUixJQUFJLENBQUMsR0FBR0EsSUFBSSxHQUFHLENBQUNBLElBQUksQ0FBQztJQUNuRCxNQUFNUyxTQUFTLEdBQUdGLEtBQUssQ0FBQ0MsT0FBTyxDQUFDUCxNQUFNLENBQUMsR0FBR0EsTUFBTSxHQUFHLENBQUNBLE1BQU0sQ0FBQzs7SUFFM0Q7SUFDQSxNQUFNUyxXQUFXLEdBQUdKLE9BQU8sQ0FBQ0ssR0FBRyxDQUFDLE9BQU9DLEdBQUcsRUFBRTdCLENBQUMsS0FBSztNQUNoRCxNQUFNOEIsS0FBSyxHQUFHLElBQUkvQyxtRUFBWSxDQUFDLElBQUlWLCtDQUFVLENBQUN3RCxHQUFHLENBQUMsRUFBRVYsS0FBSyxFQUFFQyxLQUFLLENBQUM7TUFDakUsTUFBTVcsSUFBSSxHQUFHOUQsK0NBQVMsQ0FBQzZELEtBQUssQ0FBQztNQUM3QixNQUFNRSxLQUFLLEdBQUcsTUFBTS9ELGdEQUFTLENBQUM4RCxJQUFJLEVBQUU7UUFDbENHLElBQUksRUFBRTtNQUNSLENBQUMsQ0FBQyxDQUFDQyxLQUFLLENBQUMxQyx3RUFBbUIsQ0FBRSxtQ0FBa0NvQyxHQUFJLEVBQUMsRUFBRXJDLG9FQUFtQixDQUFDNEMsU0FBUyxDQUFDLENBQUM7O01BRXRHO01BQ0EsSUFBSUMsS0FBSyxHQUFHWCxTQUFTLENBQUNZLElBQUksQ0FBQ3hDLEdBQUcsQ0FBQ0UsQ0FBQyxFQUFFMEIsU0FBUyxDQUFDekIsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO01BQ3hELElBQUlvQyxLQUFLLEdBQUdMLEtBQUssQ0FBQ08sS0FBSyxDQUFDQyxXQUFXLEVBQUV2QyxNQUFNLEVBQUU7UUFDM0N3QyxPQUFPLENBQUNDLElBQUksQ0FBRSxpQ0FBZ0NMLEtBQU0sNkJBQTRCLENBQUM7UUFDakZBLEtBQUssR0FBRyxDQUFDO01BQ1g7TUFDQTNDLGtGQUF1QixDQUFDc0MsS0FBSyxDQUFDTyxLQUFLLEVBQUVGLEtBQUssRUFBRWQsT0FBTyxDQUFDdEIsTUFBTSxHQUFHLENBQUMsR0FBSSxlQUFjRCxDQUFFLEVBQUMsR0FBRyxNQUFNLENBQUM7TUFDN0YsTUFBTTtRQUNKd0MsV0FBVztRQUNYRztNQUNGLENBQUMsR0FBR1gsS0FBSyxDQUFDTyxLQUFLO01BQ2YsTUFBTUssa0JBQWtCLEdBQUdKLFdBQVcsQ0FBQ0gsS0FBSyxDQUFDOztNQUU3QztNQUNBLE1BQU1RLFFBQVEsR0FBR0Qsa0JBQWtCLENBQUNFLFFBQVEsQ0FBQ2xCLEdBQUcsQ0FBQyxDQUFDO1FBQ2hEbUI7TUFDRixDQUFDLEtBQUs5RSxnREFBUyxDQUFDOEQsSUFBSSxDQUFDaUIsT0FBTyxDQUFDRCxJQUFJLENBQUMsRUFBRTtRQUNsQ2IsSUFBSSxFQUFFO01BQ1IsQ0FBQyxDQUFDLENBQUNDLEtBQUssQ0FBQzFDLHdFQUFtQixDQUFFLDhCQUE2QnNELElBQUssd0JBQXVCbEIsR0FBSSxFQUFDLEVBQUVyQyxvRUFBbUIsQ0FBQzRDLFNBQVMsQ0FBQyxDQUFDLENBQUM7TUFDOUgsTUFBTWEsV0FBVyxHQUFHLE1BQU1DLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDTixRQUFRLENBQUM7TUFDL0MsTUFBTU8sU0FBUyxHQUFHOUQsc0VBQWdCLENBQUNzRCxrQkFBa0IsQ0FBQ1MsSUFBSSxDQUFDO01BQzNELE9BQU87UUFDTEosV0FBVztRQUNYTCxrQkFBa0I7UUFDbEJVLGFBQWEsRUFBRVgsS0FBSztRQUNwQlMsU0FBUztRQUNURyxhQUFhLEVBQUU7TUFDakIsQ0FBQztJQUNILENBQUMsQ0FBQztJQUNGLE1BQU0zQyxPQUFPLEdBQUcsTUFBTXNDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDeEIsV0FBVyxDQUFDOztJQUU5QztJQUNBLElBQUk2QixZQUFZLEdBQUcsQ0FBQztJQUNwQixLQUFLLE1BQU1DLENBQUMsSUFBSTdDLE9BQU8sRUFBRTtNQUN2QjZDLENBQUMsQ0FBQ0YsYUFBYSxHQUFHQyxZQUFZO01BQzlCQSxZQUFZLElBQUlDLENBQUMsQ0FBQ0gsYUFBYSxFQUFFSSxRQUFRLENBQUN6RCxNQUFNLElBQUl3RCxDQUFDLENBQUNSLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQ1UsS0FBSyxDQUFDRixDQUFDLENBQUNMLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1RjtJQUNBO0lBQ0FqRSw0RUFBc0IsQ0FBQ3lCLE9BQU8sQ0FBQztJQUMvQjtJQUNBO0lBQ0E7SUFDQSxNQUFNZ0QsWUFBWSxHQUFHOUMsWUFBWSxFQUFFQyxrQkFBa0IsR0FBR0QsWUFBWSxDQUFDQyxrQkFBa0IsQ0FBQzNDLEtBQUssQ0FBQyxDQUFDLEdBQUd5RixTQUFTO0lBQzNHLE9BQU8sSUFBSXBELGFBQWEsQ0FBQ0csT0FBTyxFQUFFUSxLQUFLLEVBQUVOLFlBQVksRUFBRThDLFlBQVksQ0FBQztFQUN0RTtFQUNBRSxjQUFjQSxDQUFBLEVBQUc7SUFDZixNQUFNQyxNQUFNLEdBQUcsSUFBSSxDQUFDbkQsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUM5QjtJQUNBLE1BQU1vRCxFQUFFLEdBQUdELE1BQU0sQ0FBQ1gsU0FBUyxDQUFDLENBQUMsQ0FBQztJQUM5QixNQUFNYSxhQUFhLEdBQUdGLE1BQU0sQ0FBQ25CLGtCQUFrQixDQUFDUyxJQUFJLENBQUNXLEVBQUUsQ0FBQyxDQUFDRSxJQUFJO0lBQzdELE1BQU1DLGVBQWUsR0FBR3RGLHVFQUFnQixDQUFDb0YsYUFBYSxDQUFDLElBQUlBLGFBQWEsSUFBSSxFQUFFO0lBQzlFLE1BQU1HLEVBQUUsR0FBR0wsTUFBTSxDQUFDWCxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBQzlCLE1BQU1pQixZQUFZLEdBQUdELEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBR0wsTUFBTSxDQUFDbkIsa0JBQWtCLENBQUNTLElBQUksQ0FBQ2UsRUFBRSxDQUFDLENBQUNGLElBQUksR0FBR0wsU0FBUztJQUNsRixNQUFNUyxjQUFjLEdBQUd6Rix1RUFBZ0IsQ0FBQ3dGLFlBQVksQ0FBQyxJQUFJQSxZQUFZLElBQUksRUFBRTtJQUMzRSxPQUFPLENBQUNGLGVBQWUsRUFBRUcsY0FBYyxDQUFDO0VBQzFDO0VBQ0FDLGlCQUFpQkEsQ0FBQSxFQUFHO0lBQ2xCLE1BQU1SLE1BQU0sR0FBRyxJQUFJLENBQUNuRCxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQzlCLE1BQU0sQ0FBQzRELENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLENBQUMsR0FBR1gsTUFBTSxDQUFDWCxTQUFTLENBQUNoRixLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDNUMsT0FBTzJGLE1BQU0sQ0FBQ2QsV0FBVyxDQUFDckIsR0FBRyxDQUFDLENBQUM7TUFDN0IrQjtJQUNGLENBQUMsS0FBSyxDQUFDYSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHYixLQUFLLENBQUNhLENBQUMsQ0FBQyxFQUFFYixLQUFLLENBQUNjLENBQUMsQ0FBQyxFQUFFZCxLQUFLLENBQUNlLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDdEQ7RUFDQXpGLFFBQVFBLENBQUMwRixLQUFLLEVBQUU7SUFDZCxPQUFPMUYsOERBQVEsQ0FBQyxJQUFJLENBQUMyQixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUNnQyxrQkFBa0IsQ0FBQ0UsUUFBUSxDQUFDNkIsS0FBSyxDQUFDLEVBQUUsSUFBSSxDQUFDL0QsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDd0MsU0FBUyxDQUFDO0VBQ2hHO0VBQ0FoRSxnQkFBZ0JBLENBQUN3RixTQUFTLEVBQUVDLFNBQVMsR0FBRyxDQUFDLEVBQUU7SUFDekMsT0FBT3pGLHNFQUFnQixDQUFDd0YsU0FBUyxFQUFFLElBQUksQ0FBQ2hFLE9BQU8sQ0FBQ2lFLFNBQVMsQ0FBQyxDQUFDekIsU0FBUyxDQUFDO0VBQ3ZFO0VBQ0EvRCxZQUFZQSxDQUFDeUYsYUFBYSxFQUFFQyxZQUFZLEVBQUVGLFNBQVMsR0FBRyxDQUFDLEVBQUU7SUFDdkQsT0FBT3hGLGtFQUFZLENBQUN5RixhQUFhLEVBQUUsSUFBSSxDQUFDbEUsT0FBTyxDQUFDaUUsU0FBUyxDQUFDLENBQUN6QixTQUFTLEVBQUUyQixZQUFZLENBQUM7RUFDckY7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFQyxvQkFBb0JBLENBQUNDLG9CQUFvQixFQUFFO0lBQ3pDLE1BQU1DLFVBQVUsR0FBRyxJQUFJLENBQUN0RSxPQUFPLENBQUNYLE1BQU0sR0FBRyxDQUFDO0lBQzFDLE1BQU1rRixPQUFPLEdBQUcsSUFBSSxDQUFDdkUsT0FBTyxDQUFDc0UsVUFBVSxDQUFDO0lBQ3hDLE1BQU1FLGtCQUFrQixHQUFHRCxPQUFPLENBQUNsQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUNVLEtBQUssQ0FBQ3dCLE9BQU8sQ0FBQy9CLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3RSxNQUFNaUMsZUFBZSxHQUFHRixPQUFPLENBQUM1QixhQUFhLEdBQUc2QixrQkFBa0I7SUFDbEUsSUFBSUgsb0JBQW9CLEdBQUdJLGVBQWUsRUFBRTtNQUMxQyxNQUFNLElBQUk5RixnRUFBZSxDQUFFLHdCQUF1QjBGLG9CQUFxQixrQkFBaUJJLGVBQWdCLHNCQUFxQixFQUFFO1FBQzdIQyxJQUFJLEVBQUU5RixvRUFBbUIsQ0FBQytGO01BQzVCLENBQUMsQ0FBQztJQUNKO0lBQ0EsTUFBTUMsZUFBZSxHQUFHLElBQUksQ0FBQzVFLE9BQU8sQ0FBQzZFLFNBQVMsQ0FBQ0MsR0FBRyxJQUFJQSxHQUFHLENBQUNuQyxhQUFhLEdBQUcwQixvQkFBb0IsQ0FBQztJQUMvRixNQUFNVSxXQUFXLEdBQUdILGVBQWUsS0FBSyxDQUFDLENBQUMsR0FBR04sVUFBVSxHQUFHTSxlQUFlLEdBQUcsQ0FBQztJQUM3RSxNQUFNSSxvQkFBb0IsR0FBR1gsb0JBQW9CLEdBQUcsSUFBSSxDQUFDckUsT0FBTyxDQUFDK0UsV0FBVyxDQUFDLENBQUNwQyxhQUFhO0lBQzNGLE9BQU87TUFDTG9DLFdBQVc7TUFDWEM7SUFDRixDQUFDO0VBQ0g7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRUMsbUJBQW1CQSxDQUFDQyxVQUFVLEVBQUU7SUFDOUIsSUFBSSxDQUFDL0Usa0JBQWtCLEdBQUcrRSxVQUFVO0VBQ3RDO0VBQ0FDLHVCQUF1QkEsQ0FBQ0MsSUFBSSxFQUFFO0lBQzVCLElBQUksQ0FBQ3RGLFlBQVksR0FBR3NGLElBQUk7RUFDMUI7RUFDQUMsUUFBUUEsQ0FBQ0MsUUFBUSxFQUFFO0lBQ2pCLE1BQU0sQ0FBQ0MsU0FBUyxFQUFFQyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUN0QyxjQUFjLENBQUMsQ0FBQztJQUNuRDtJQUNBLE1BQU11QyxTQUFTLEdBQUcsSUFBSSxDQUFDQSxTQUFTLElBQUksSUFBSXRJLHdDQUFJLENBQUMsSUFBSUMsMkNBQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUlBLDJDQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN4RixNQUFNc0ksU0FBUyxHQUFHN0gsdUVBQWdCLENBQUN5SCxRQUFRLENBQUNJLFNBQVMsRUFBRUQsU0FBUyxDQUFDO0lBQ2pFLE1BQU1FLFVBQVUsR0FBR0QsU0FBUyxDQUFDRSxPQUFPLENBQUMsSUFBSXhJLDJDQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ25ELE1BQU15SSxTQUFTLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFRixVQUFVLENBQUMvQixDQUFDLEVBQUUrQixVQUFVLENBQUM5QixDQUFDLEVBQUU4QixVQUFVLENBQUM3QixDQUFDLENBQUM7SUFDbEUsTUFBTWdDLE1BQU0sR0FBRyxJQUFJLENBQUM5RixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUNxQyxXQUFXLENBQUNyQixHQUFHLENBQUMsQ0FBQytDLEtBQUssRUFBRTNFLENBQUMsS0FBSztNQUMzRCxNQUFNMkcsS0FBSyxHQUFHLElBQUksQ0FBQzFILFFBQVEsQ0FBQ2UsQ0FBQyxDQUFDO01BQzlCLE1BQU00RyxJQUFJLEdBQUcsSUFBSXBJLHlEQUFVLENBQUMsQ0FBQztNQUM3Qm9JLElBQUksQ0FBQ1QsU0FBUyxHQUFHQSxTQUFTO01BQzFCUyxJQUFJLENBQUNSLFFBQVEsR0FBR0EsUUFBUTtNQUN4QlEsSUFBSSxDQUFDakQsS0FBSyxHQUFHLElBQUksQ0FBQ3RFLFlBQVksQ0FBQ3NGLEtBQUssQ0FBQ2hCLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQy9CLEdBQUcsQ0FBQyxDQUFDMUIsR0FBRyxFQUFFMkcsR0FBRyxLQUFLdkUsSUFBSSxDQUFDdkMsR0FBRyxDQUFDdUMsSUFBSSxDQUFDd0UsSUFBSSxDQUFDNUcsR0FBRyxHQUFHdUcsU0FBUyxDQUFDSSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO01BQzlHRCxJQUFJLENBQUNHLE9BQU8sR0FBRyxJQUFJLENBQUMxSCxZQUFZLENBQUNzSCxLQUFLLEVBQUUsQ0FBQyxDQUFDO01BQzFDLE9BQU9DLElBQUk7SUFDYixDQUFDLENBQUM7SUFDRixPQUFPMUQsT0FBTyxDQUFDRixPQUFPLENBQUMwRCxNQUFNLENBQUM7RUFDaEM7RUFDQU0sZUFBZUEsQ0FBQ2QsUUFBUSxFQUFFO0lBQ3hCO0lBQ0EsTUFBTWUsT0FBTyxHQUFHLElBQUksQ0FBQ3JHLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDL0IsTUFBTSxDQUFDc0csQ0FBQyxHQUFHMUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsQ0FBQyxHQUFHdUMsT0FBTyxDQUFDN0QsU0FBUztJQUN2QyxNQUFNK0QsSUFBSSxHQUFHRCxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ25CLE1BQU1FLElBQUksR0FBRzVDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbkIsTUFBTTZDLE1BQU0sR0FBR0osT0FBTyxDQUFDaEUsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDVSxLQUFLO0lBQzNDLE1BQU0yRCxXQUFXLEdBQUcxSSxzRUFBZSxDQUFDc0gsUUFBUSxFQUFFLElBQUksQ0FBQzNCLGlCQUFpQixDQUFDLENBQUMsQ0FBQztJQUN2RSxNQUFNZ0QsT0FBTyxHQUFHTixPQUFPLENBQUNoRSxXQUFXLENBQUNxRSxXQUFXLENBQUMsQ0FBQzNELEtBQUs7SUFDdEQsTUFBTSxDQUFDNkQsV0FBVyxFQUFFcEIsUUFBUSxDQUFDLEdBQUcsSUFBSSxDQUFDdEMsY0FBYyxDQUFDLENBQUM7O0lBRXJEO0lBQ0EsTUFBTTJELFVBQVUsR0FBRyxJQUFJLENBQUM3RyxPQUFPLENBQUMsSUFBSSxDQUFDQSxPQUFPLENBQUNYLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDeEQsTUFBTXlILEtBQUssR0FBR0QsVUFBVSxDQUFDckUsU0FBUyxDQUFDLENBQUMsQ0FBQztJQUNyQyxNQUFNdUUsUUFBUSxHQUFHRCxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQzNCLE1BQU1FLFdBQVcsR0FBR0gsVUFBVSxDQUFDbEUsYUFBYSxJQUFJb0UsUUFBUSxHQUFHRixVQUFVLENBQUN4RSxXQUFXLENBQUNxRSxXQUFXLENBQUMsQ0FBQzNELEtBQUssQ0FBQytELEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNoSDtJQUNBO0lBQ0EsSUFBSUcsS0FBSyxHQUFHLENBQUM7SUFDYixJQUFJVixJQUFJLEVBQUU7TUFDUlUsS0FBSyxHQUFHTixPQUFPLENBQUNMLENBQUMsQ0FBQztNQUNsQixLQUFLLElBQUlsSCxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUcsSUFBSSxDQUFDWSxPQUFPLENBQUNYLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQUU7UUFDNUMsTUFBTTJELEtBQUssR0FBRyxJQUFJLENBQUMvQyxPQUFPLENBQUNaLENBQUMsQ0FBQyxDQUFDaUQsV0FBVyxDQUFDcUUsV0FBVyxDQUFDLENBQUMzRCxLQUFLO1FBQzVELE1BQU1tRSxNQUFNLEdBQUcsSUFBSSxDQUFDbEgsT0FBTyxDQUFDWixDQUFDLENBQUMsQ0FBQ29ELFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDM0MsSUFBSU8sS0FBSyxDQUFDbUUsTUFBTSxDQUFDLEdBQUdELEtBQUssRUFBRTtVQUN6QnBGLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDLDhEQUE4RCxFQUFFaUIsS0FBSyxDQUFDbUUsTUFBTSxDQUFDLEVBQUVELEtBQUssQ0FBQztVQUNsR0EsS0FBSyxHQUFHbEUsS0FBSyxDQUFDbUUsTUFBTSxDQUFDO1FBQ3ZCO01BQ0Y7SUFDRjtJQUNBLElBQUksQ0FBQyxJQUFJLENBQUN6QixTQUFTLEVBQUU7TUFDbkIsSUFBSSxDQUFDQSxTQUFTLEdBQUdILFFBQVEsQ0FBQ0ksU0FBUyxDQUFDeUIsS0FBSyxDQUFDLENBQUM7SUFDN0M7SUFDQSxNQUFNQyxPQUFPLEdBQUdySiwrRUFBd0IsQ0FBQ3VILFFBQVEsQ0FBQ0ksU0FBUyxFQUFFLElBQUl0SSwyQ0FBTyxDQUFDcUosTUFBTSxDQUFDM0MsQ0FBQyxDQUFDLEVBQUUyQyxNQUFNLENBQUM1QyxDQUFDLENBQUMsRUFBRTJDLElBQUksR0FBR0MsTUFBTSxDQUFDN0MsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDckgsTUFBTXlELE9BQU8sR0FBR0QsT0FBTyxDQUFDeEIsT0FBTyxDQUFDLElBQUl4SSwyQ0FBTyxDQUFDLENBQUMsQ0FBQztJQUM5QyxNQUFNa0ssUUFBUSxHQUFHdkosK0VBQXdCLENBQUN1SCxRQUFRLENBQUNJLFNBQVMsRUFBRSxJQUFJdEksMkNBQU8sQ0FBQ3VKLE9BQU8sQ0FBQzdDLENBQUMsQ0FBQyxFQUFFNkMsT0FBTyxDQUFDOUMsQ0FBQyxDQUFDLEVBQUUyQyxJQUFJLEdBQUdHLE9BQU8sQ0FBQy9DLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3pILE1BQU0yRCxRQUFRLEdBQUdELFFBQVEsQ0FBQzFCLE9BQU8sQ0FBQyxJQUFJeEksMkNBQU8sQ0FBQyxDQUFDLENBQUM7SUFDaEQsTUFBTW9LLGFBQWEsR0FBRzFKLDZFQUFzQixDQUFDeUosUUFBUSxDQUFDM0QsQ0FBQyxFQUFFMkQsUUFBUSxDQUFDekQsQ0FBQyxFQUFFeUQsUUFBUSxDQUFDMUQsQ0FBQyxDQUFDOztJQUVoRjtJQUNBO0lBQ0EsTUFBTTRELGVBQWUsR0FBRyxJQUFJQyxHQUFHLENBQUMsQ0FBQztJQUNqQyxNQUFNQyxZQUFZLEdBQUcsSUFBSSxDQUFDM0gsT0FBTyxDQUFDNEgsT0FBTyxDQUFDOUMsR0FBRyxJQUFJO01BQy9DLE1BQU0rQyxrQkFBa0IsR0FBR3ZKLDJFQUFxQixDQUFDd0csR0FBRyxDQUFDOztNQUVyRDtNQUNBLE9BQU8rQyxrQkFBa0IsQ0FBQzdHLEdBQUcsQ0FBQzhHLFdBQVcsSUFBSTtRQUMzQyxNQUFNQyxtQkFBbUIsR0FBR04sZUFBZSxDQUFDbkssR0FBRyxDQUFDd0ssV0FBVyxDQUFDO1FBQzVELElBQUlDLG1CQUFtQixLQUFLOUUsU0FBUyxFQUFFO1VBQ3JDO1VBQ0F3RSxlQUFlLENBQUNPLEdBQUcsQ0FBQ0YsV0FBVyxFQUFFQyxtQkFBbUIsR0FBRyxDQUFDLENBQUM7VUFDekQsT0FBUSxHQUFFRCxXQUFZLEtBQUlDLG1CQUFvQixHQUFFO1FBQ2xELENBQUMsTUFBTTtVQUNMTixlQUFlLENBQUNPLEdBQUcsQ0FBQ0YsV0FBVyxFQUFFLENBQUMsQ0FBQztVQUNuQyxPQUFPQSxXQUFXO1FBQ3BCO01BQ0YsQ0FBQyxDQUFDO0lBQ0osQ0FBQyxDQUFDOztJQUVGO0lBQ0EsTUFBTUcsT0FBTyxHQUFHLElBQUksQ0FBQzVKLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDaEM7SUFDQSxNQUFNNkosU0FBUyxHQUFHM0IsSUFBSSxHQUFHMEIsT0FBTyxDQUFDM0IsQ0FBQyxDQUFDLEdBQUcsQ0FBQztJQUN2QyxNQUFNNkIsT0FBTyxHQUFHO01BQ2RDLElBQUksRUFBRS9CLE9BQU8sQ0FBQzNELGFBQWEsRUFBRTBGLElBQUksSUFBSSxRQUFRO01BQzdDQyxZQUFZLEVBQUVoQixPQUFPO01BQ3JCRyxhQUFhO01BQ2JjLFVBQVUsRUFBRWYsUUFBUTtNQUNwQmdCLGFBQWEsRUFBRWhCLFFBQVEsQ0FBQ0osS0FBSyxDQUFDLENBQUM7TUFDL0JxQixlQUFlLEVBQUUsSUFBSXBMLDJDQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7TUFDckNxTCxpQkFBaUIsRUFBRSxJQUFJckwsMkNBQU8sQ0FBQzZLLE9BQU8sQ0FBQ25FLENBQUMsQ0FBQyxFQUFFbUUsT0FBTyxDQUFDcEUsQ0FBQyxDQUFDLEVBQUUyQyxJQUFJLEdBQUd5QixPQUFPLENBQUNyRSxDQUFDLENBQUMsR0FBR2xDLElBQUksQ0FBQ3hDLEdBQUcsQ0FBQytJLE9BQU8sQ0FBQ25FLENBQUMsQ0FBQyxFQUFFbUUsT0FBTyxDQUFDcEUsQ0FBQyxDQUFDLENBQUMsQ0FBQztNQUM1RytDLFdBQVc7TUFDWEksV0FBVztNQUNYVyxZQUFZO01BQ1pWLEtBQUs7TUFDTGlCLFNBQVM7TUFDVDFDLFFBQVE7TUFDUmtELG1CQUFtQixFQUFFckMsT0FBTyxDQUFDaEUsV0FBVyxDQUFDaEQsTUFBTTtNQUMvQ3NKLGVBQWUsRUFBRWpDLFdBQVc7TUFDNUJrQyxTQUFTLEVBQUU7UUFDVEMsV0FBVyxFQUFFLElBQUl6TCwyQ0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2pDMEwsUUFBUSxFQUFFLElBQUkxTCwyQ0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztNQUMvQjtJQUNGLENBQUM7O0lBRUQ7SUFDQTtJQUNBLE1BQU0yTCxrQkFBa0IsR0FBRztNQUN6QixHQUFHekQsUUFBUTtNQUNYSSxTQUFTLEVBQUUsSUFBSXZJLHdDQUFJLENBQUMsSUFBSUMsMkNBQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUlBLDJDQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUNELE9BQU9rRixPQUFPLENBQUNGLE9BQU8sQ0FBQztNQUNyQjRHLFNBQVMsRUFBRWIsT0FBTztNQUNsQjdDLFFBQVEsRUFBRXlEO0lBQ1osQ0FBQyxDQUFDO0VBQ0o7RUFDQSxNQUFNRSxhQUFhQSxDQUFDQyxVQUFVLEVBQUVDLE1BQU0sRUFBRUMsVUFBVSxFQUFFO0lBQ2xELE1BQU07TUFDSmxJLEtBQUs7TUFDTGlCO0lBQ0YsQ0FBQyxHQUFHK0csVUFBVTtJQUNkLE1BQU1HLFNBQVMsR0FBR2xILElBQUksQ0FBQ21ILFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRztJQUMvQyxNQUFNQyxHQUFHLEdBQUdwSCxJQUFJLEdBQUdrSCxTQUFTLEdBQUcsSUFBSSxDQUFDN0ssZ0JBQWdCLENBQUMySyxNQUFNLENBQUMsQ0FBQ0ssSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUN0RTtJQUNBLE1BQU10SSxLQUFLLENBQUM1RCxHQUFHLENBQUNpTSxHQUFHLEVBQUU7TUFDbkJILFVBQVU7TUFDVkssVUFBVSxFQUFFO0lBQ2QsQ0FBQyxDQUFDLENBQUNsSSxLQUFLLENBQUMxQyx3RUFBbUIsQ0FBRSxxQ0FBb0MwSyxHQUFJLEVBQUMsRUFBRTNLLG9FQUFtQixDQUFDOEssZ0JBQWdCLEVBQUUzSywyQkFBMkIsQ0FBQyxDQUFDO0VBQzlJOztFQUVBO0VBQ0E0SyxhQUFhQSxDQUFDQyxJQUFJLEVBQUVWLFVBQVUsRUFBRTtJQUM5QjtJQUNBLE1BQU1XLFdBQVcsR0FBR0QsSUFBSSxDQUFDNUksR0FBRyxDQUFDLENBQUM7TUFDNUJpRCxTQUFTO01BQ1RzRjtJQUNGLENBQUMsS0FBSztNQUNKLE1BQU1PLE9BQU8sR0FBRzFMLHVFQUFpQixDQUFDLElBQUksQ0FBQzRCLE9BQU8sQ0FBQ2lFLFNBQVMsQ0FBQyxDQUFDekIsU0FBUyxDQUFDO01BQ3BFLE1BQU11SCxzQkFBc0IsR0FBR1IsR0FBRyxDQUFDUyxJQUFJLENBQUMsQ0FBQyxDQUFDQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUN6TSxLQUFLLENBQUMsQ0FBQ3NNLE9BQU8sQ0FBQyxDQUFDSSxNQUFNLENBQUNySCxDQUFDLElBQUlBLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQzdCLEdBQUcsQ0FBQzZCLENBQUMsSUFBSXNILFFBQVEsQ0FBQ3RILENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztNQUNwSCxNQUFNdUgsWUFBWSxHQUFHLElBQUksQ0FBQzNMLFlBQVksQ0FBQ3NMLHNCQUFzQixFQUFFLENBQUMsRUFBRTlGLFNBQVMsQ0FBQztNQUM1RTtNQUNBO01BQ0FtRyxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDcEssT0FBTyxDQUFDaUUsU0FBUyxDQUFDLENBQUN0QixhQUFhO01BQ3hELE9BQU95SCxZQUFZO0lBQ3JCLENBQUMsQ0FBQzs7SUFFRjtJQUNBLE1BQU1DLGNBQWMsR0FBRyxJQUFJLENBQUNySyxPQUFPLENBQUNnQixHQUFHLENBQUM4RCxHQUFHLElBQUk7TUFDN0MsTUFBTWYsS0FBSyxHQUFHZSxHQUFHLENBQUN6QyxXQUFXLENBQUM2RyxVQUFVLENBQUM7TUFDekMsTUFBTW9CLGtCQUFrQixHQUFHdkcsS0FBSyxDQUFDaEIsS0FBSyxDQUFDL0IsR0FBRyxDQUFDLENBQUN1SixHQUFHLEVBQUV0RSxHQUFHLEtBQUt2RSxJQUFJLENBQUN3RSxJQUFJLENBQUNxRSxHQUFHLEdBQUd4RyxLQUFLLENBQUN5RyxNQUFNLENBQUN2RSxHQUFHLENBQUMsQ0FBQyxDQUFDO01BQzVGLE9BQU8sSUFBSSxDQUFDeEgsWUFBWSxDQUFDNkwsa0JBQWtCLEVBQUUsQ0FBQyxDQUFDO0lBQ2pELENBQUMsQ0FBQztJQUNGO0lBQ0EsTUFBTUcsZ0JBQWdCLEdBQUcsSUFBSXZNLDRFQUFxQixDQUFDMkwsV0FBVyxFQUFFLElBQUksQ0FBQzNKLFlBQVksQ0FBQ1AsbUJBQW1CLEVBQUUwSyxjQUFjLEVBQUUsSUFBSSxDQUFDbEssa0JBQWtCLENBQUM7SUFDL0ksTUFBTWlKLFVBQVUsR0FBRyxJQUFJLENBQUNuSixZQUFZLENBQUN5SyxhQUFhLENBQUMsQ0FBQztJQUNwRCxJQUFJQyxhQUFhLEdBQUcsQ0FBQztJQUNyQixLQUFLLE1BQU1DLEtBQUssSUFBSUgsZ0JBQWdCLEVBQUU7TUFDcEMsSUFBSUUsYUFBYSxJQUFJLElBQUksQ0FBQ3pLLFlBQVksQ0FBQ04saUJBQWlCLEVBQUU7UUFDeEQ7TUFDRjtNQUNBO01BQ0EsTUFBTTtRQUNKbUYsV0FBVztRQUNYQztNQUNGLENBQUMsR0FBRyxJQUFJLENBQUNaLG9CQUFvQixDQUFDd0csS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQ3ZDLE1BQU1DLGdCQUFnQixHQUFHLElBQUksQ0FBQzdLLE9BQU8sQ0FBQytFLFdBQVcsQ0FBQyxDQUFDMUMsV0FBVyxDQUFDNkcsVUFBVSxDQUFDO01BQzFFMEIsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHNUYsb0JBQW9CO01BQy9CLElBQUksQ0FBQ2lFLGFBQWEsQ0FBQzRCLGdCQUFnQixFQUFFRCxLQUFLLEVBQUV4QixVQUFVLENBQUM7TUFDdkR1QixhQUFhLEVBQUU7SUFDakI7O0lBRUE7SUFDQSxJQUFJLElBQUksQ0FBQ0csa0JBQWtCLEtBQUs3SCxTQUFTLEVBQUU7TUFDekMsSUFBSSxDQUFDaEQsWUFBWSxDQUFDOEssZ0JBQWdCLENBQUMsSUFBSSxDQUFDRCxrQkFBa0IsRUFBRS9MLDJCQUEyQixDQUFDO0lBQzFGO0lBQ0EsSUFBSSxDQUFDK0wsa0JBQWtCLEdBQUcxQixVQUFVO0VBQ3RDO0VBQ0E0QixzQkFBc0JBLENBQUNoQyxTQUFTLEVBQUUxRCxRQUFRLEVBQUU7SUFDMUM7SUFDQSxNQUFNRyxTQUFTLEdBQUcsSUFBSSxDQUFDQSxTQUFTLElBQUksSUFBSXRJLHdDQUFJLENBQUMsSUFBSUMsMkNBQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUlBLDJDQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN4RixNQUFNc0ksU0FBUyxHQUFHN0gsdUVBQWdCLENBQUN5SCxRQUFRLENBQUNJLFNBQVMsRUFBRUQsU0FBUyxDQUFDOztJQUVqRTtJQUNBLE1BQU1rRCxlQUFlLEdBQUczSyxzRUFBZSxDQUFDO01BQ3RDLEdBQUdzSCxRQUFRO01BQ1hJO0lBQ0YsQ0FBQyxFQUFFLElBQUksQ0FBQy9CLGlCQUFpQixDQUFDLENBQUMsQ0FBQztJQUM1QixNQUFNc0gsV0FBVyxHQUFHLElBQUksQ0FBQ2pMLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQ3FDLFdBQVcsQ0FBQ3NHLGVBQWUsQ0FBQyxDQUFDNUYsS0FBSzs7SUFFdEU7SUFDQSxNQUFNLENBQUNhLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM5RCxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUN3QyxTQUFTLENBQUNoRixLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3BELE1BQU0wTixRQUFRLEdBQUduTiwrRUFBd0IsQ0FBQzJILFNBQVMsRUFBRSxJQUFJdEksMkNBQU8sQ0FBQzZOLFdBQVcsQ0FBQ25ILENBQUMsQ0FBQyxFQUFFbUgsV0FBVyxDQUFDcEgsQ0FBQyxDQUFDLEVBQUVELENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUdxSCxXQUFXLENBQUNySCxDQUFDLENBQUMsQ0FBQyxDQUFDOztJQUVoSTtJQUNBLE1BQU0yRSxhQUFhLEdBQUcyQyxRQUFRLENBQUN0RixPQUFPLENBQUMsSUFBSXhJLDJDQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ3JELE1BQU1vSyxhQUFhLEdBQUcxSiw2RUFBc0IsQ0FBQ3lLLGFBQWEsQ0FBQzNFLENBQUMsRUFBRTJFLGFBQWEsQ0FBQ3pFLENBQUMsRUFBRXlFLGFBQWEsQ0FBQzFFLENBQUMsQ0FBQztJQUMvRixNQUFNc0gsWUFBWSxHQUFHcE4sK0VBQXdCLENBQUMwSCxTQUFTLEVBQUUsSUFBSXJJLDJDQUFPLENBQUM2TixXQUFXLENBQUNuSCxDQUFDLENBQUMsRUFBRW1ILFdBQVcsQ0FBQ3BILENBQUMsQ0FBQyxFQUFFRCxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHcUgsV0FBVyxDQUFDckgsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNwSSxNQUFNMEUsVUFBVSxHQUFHNkMsWUFBWSxDQUFDdkYsT0FBTyxDQUFDLElBQUl4SSwyQ0FBTyxDQUFDLENBQUMsQ0FBQztJQUN0RCxPQUFPO01BQ0wsR0FBRzRMLFNBQVM7TUFDWnhCLGFBQWE7TUFDYmMsVUFBVTtNQUNWQyxhQUFhO01BQ2JDLGVBQWUsRUFBRTBDLFFBQVEsQ0FBQ2hNLEdBQUc7TUFDN0J5SjtJQUNGLENBQUM7RUFDSDtFQUNBLE1BQU15QyxrQkFBa0JBLENBQUNwQyxTQUFTLEVBQUUxRCxRQUFRLEVBQUUrRixnQkFBZ0IsRUFBRUMsTUFBTSxFQUFFO0lBQ3RFO0lBQ0E7SUFDQSxNQUFNeEwsWUFBWSxHQUFHLElBQUksQ0FBQ0EsWUFBWTtJQUN0QyxNQUFNeUwsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDUCxzQkFBc0IsQ0FBQ2hDLFNBQVMsRUFBRTFELFFBQVEsQ0FBQztJQUN6RStGLGdCQUFnQixDQUFDRSxnQkFBZ0IsQ0FBQztJQUNsQyxNQUFNO01BQ0p2RSxXQUFXO01BQ1gyQjtJQUNGLENBQUMsR0FBRzRDLGdCQUFnQjtJQUNwQixNQUFNQyxjQUFjLEdBQUdsRyxRQUFRLENBQUN4QyxRQUFRLElBQUlsQyxLQUFLLENBQUM2SyxJQUFJLENBQUM7TUFDckRwTSxNQUFNLEVBQUUySDtJQUNWLENBQUMsRUFBRSxDQUFDMEUsQ0FBQyxFQUFFdE0sQ0FBQyxLQUFLQSxDQUFDLENBQUM7SUFDZixNQUFNZ0ssVUFBVSxHQUFHLElBQUksQ0FBQ25KLFlBQVksQ0FBQ3lLLGFBQWEsQ0FBQyxDQUFDOztJQUVwRDtJQUNBLE1BQU1kLElBQUksR0FBRyxFQUFFO0lBQ2YsTUFBTStCLGFBQWEsR0FBR0EsQ0FBQzFILFNBQVMsRUFBRXNGLEdBQUcsRUFBRXFDLEdBQUcsS0FBSztNQUM3QyxJQUFJQSxHQUFHLEtBQUt4QyxVQUFVLEVBQUU7UUFDdEJRLElBQUksQ0FBQ2lDLElBQUksQ0FBQztVQUNSNUgsU0FBUztVQUNUc0Y7UUFDRixDQUFDLENBQUM7TUFDSjtJQUNGLENBQUM7SUFDRCxNQUFNdUMsb0JBQW9CLEdBQUcsRUFBRTtJQUMvQixNQUFNQyxpQkFBaUIsR0FBRyxFQUFFO0lBQzVCLE1BQU1DLG1CQUFtQixHQUFHLEVBQUU7SUFDOUIsTUFBTUMsZUFBZSxHQUFHVCxjQUFjLENBQUN4SyxHQUFHLENBQUMsTUFBTWtMLEVBQUUsSUFBSTtNQUNyRDtNQUNBLE1BQU1oTixHQUFHLEdBQUdxTSxnQkFBZ0IsQ0FBQy9DLGVBQWU7TUFDNUMsTUFBTXJKLEdBQUcsR0FBR0QsR0FBRyxDQUFDaUksS0FBSyxDQUFDLENBQUMsQ0FBQ2dGLEdBQUcsQ0FBQ1osZ0JBQWdCLENBQUNoRCxhQUFhLENBQUM7TUFDM0QsTUFBTTtRQUNKeEQsV0FBVyxFQUFFZCxTQUFTO1FBQ3RCZSxvQkFBb0IsRUFBRW9IO01BQ3hCLENBQUMsR0FBRyxJQUFJLENBQUNoSSxvQkFBb0IsQ0FBQzhILEVBQUUsQ0FBQztNQUNqQyxNQUFNRyxhQUFhLEdBQUcsQ0FBQy9HLFFBQVEsQ0FBQ2dILElBQUksRUFBRUYsUUFBUSxFQUFFNU8seURBQUssQ0FBQzBCLEdBQUcsQ0FBQzBFLENBQUMsRUFBRXpFLEdBQUcsQ0FBQ3lFLENBQUMsQ0FBQyxFQUFFcEcseURBQUssQ0FBQzBCLEdBQUcsQ0FBQzJFLENBQUMsRUFBRTFFLEdBQUcsQ0FBQzBFLENBQUMsQ0FBQyxFQUFFckcseURBQUssQ0FBQzBCLEdBQUcsQ0FBQzRFLENBQUMsRUFBRTNFLEdBQUcsQ0FBQzJFLENBQUMsQ0FBQyxDQUFDO01BQzlHLE1BQU1DLEtBQUssR0FBRyxJQUFJLENBQUMvRCxPQUFPLENBQUNpRSxTQUFTLENBQUMsQ0FBQzVCLFdBQVcsQ0FBQ3NHLGVBQWUsQ0FBQztNQUNsRSxNQUFNNEQsU0FBUyxHQUFHLElBQUksQ0FBQy9OLGdCQUFnQixDQUFDNk4sYUFBYSxFQUFFcEksU0FBUyxDQUFDO01BQ2pFLE1BQU11SSxTQUFTLEdBQUdBLENBQUNqRCxHQUFHLEVBQUVxQyxHQUFHLEtBQUtELGFBQWEsQ0FBQzFILFNBQVMsRUFBRXNGLEdBQUcsRUFBRXFDLEdBQUcsQ0FBQztNQUNsRSxNQUFNOUYsTUFBTSxHQUFHLE1BQU12SSx1REFBTyxDQUFDd0csS0FBSyxFQUFFd0ksU0FBUyxFQUFFO1FBQzdDRSxJQUFJLEVBQUU7VUFDSnJELFVBQVU7VUFDVm9EO1FBQ0Y7TUFDRixDQUFDLENBQUMsQ0FBQ2pMLEtBQUssQ0FBQzFDLHdFQUFtQixDQUFDLHFDQUFxQyxFQUFFRCxvRUFBbUIsQ0FBQzhLLGdCQUFnQixFQUFFM0ssMkJBQTJCLENBQUMsQ0FBQztNQUN2SSxJQUFJK0csTUFBTSxFQUFFNEcsSUFBSSxLQUFLekosU0FBUyxFQUFFO1FBQzlCO01BQ0Y7TUFDQSxNQUFNMEosU0FBUyxHQUFHM04sY0FBYyxDQUFDOEcsTUFBTSxDQUFDNEcsSUFBSSxDQUFDO01BQzdDLElBQUk1TSxZQUFZLEVBQUU7UUFDaEJpTSxpQkFBaUIsQ0FBQ0YsSUFBSSxDQUFDYyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcENiLG9CQUFvQixDQUFDRCxJQUFJLENBQUNLLEVBQUUsQ0FBQztRQUM3QkYsbUJBQW1CLENBQUNILElBQUksQ0FBQyxDQUFDYyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUVBLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQ3hELENBQUMsTUFBTTtRQUNMckIsTUFBTSxDQUFDLENBQUNZLEVBQUUsQ0FBQyxFQUFFLENBQUNTLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQ0EsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFQSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQzlEO0lBQ0YsQ0FBQyxDQUFDOztJQUVGO0lBQ0EsSUFBSSxJQUFJLENBQUNDLGNBQWMsS0FBSzNKLFNBQVMsRUFBRTtNQUNyQyxJQUFJLENBQUNoRCxZQUFZLENBQUM4SyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUM2QixjQUFjLEVBQUU3TiwyQkFBMkIsQ0FBQztJQUN0RjtJQUNBLElBQUksQ0FBQzZOLGNBQWMsR0FBR3hELFVBQVU7SUFDaEMsSUFBSSxDQUFDTyxhQUFhLENBQUNDLElBQUksRUFBRWpCLGVBQWUsQ0FBQztJQUN6QyxNQUFNckcsT0FBTyxDQUFDQyxHQUFHLENBQUMwSixlQUFlLENBQUM7SUFDbEMsSUFBSW5NLFlBQVksRUFBRTtNQUNoQndMLE1BQU0sQ0FBQ1Esb0JBQW9CLEVBQUVDLGlCQUFpQixFQUFFQyxtQkFBbUIsQ0FBQztJQUN0RTtJQUNBLElBQUksQ0FBQy9MLFlBQVksQ0FBQzhLLGdCQUFnQixDQUFDM0IsVUFBVSxFQUFFckssMkJBQTJCLENBQUM7RUFDN0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL09tZVphcnJMb2FkZXIuanM/NTBmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCb3gzLCBWZWN0b3IzIH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgKiBhcyB6YXJyIGZyb20gXCJAemFycml0YS9jb3JlXCI7XG5pbXBvcnQgeyBnZXQgYXMgemFyckdldCwgc2xpY2UgfSBmcm9tIFwiQHphcnJpdGEvaW5kZXhpbmdcIjtcbi8vIEltcG9ydGluZyBgRmV0Y2hTdG9yZWAgZnJvbSBpdHMgaG9tZSBzdWJwYWNrYWdlIChAemFycml0YS9zdG9yYWdlKSBjYXVzZXMgZXJyb3JzLlxuLy8gR2V0dGluZyBpdCBmcm9tIHRoZSB0b3AtbGV2ZWwgcGFja2FnZSBtZWFucyB3ZSBkb24ndCBnZXQgaXRzIHR5cGUuIFRoaXMgaXMgYWxzbyBhIGJ1ZywgYnV0IGl0J3MgbW9yZSBhY2NlcHRhYmxlLlxuaW1wb3J0IHsgRmV0Y2hTdG9yZSB9IGZyb20gXCJ6YXJyaXRhXCI7XG5pbXBvcnQgU3Vic2NyaWJhYmxlUmVxdWVzdFF1ZXVlIGZyb20gXCIuLi91dGlscy9TdWJzY3JpYmFibGVSZXF1ZXN0UXVldWUuanNcIjtcbmltcG9ydCB7IFRocmVhZGFibGVWb2x1bWVMb2FkZXIsIFZvbHVtZURpbXMgfSBmcm9tIFwiLi9JVm9sdW1lTG9hZGVyLmpzXCI7XG5pbXBvcnQgeyBjb21wb3NlU3VicmVnaW9uLCBjb21wdXRlUGFja2VkQXRsYXNEaW1zLCBjb252ZXJ0U3VicmVnaW9uVG9QaXhlbHMsIHBpY2tMZXZlbFRvTG9hZCwgdW5pdE5hbWVUb1N5bWJvbCB9IGZyb20gXCIuL1ZvbHVtZUxvYWRlclV0aWxzLmpzXCI7XG5pbXBvcnQgQ2h1bmtQcmVmZXRjaEl0ZXJhdG9yIGZyb20gXCIuL3phcnJfdXRpbHMvQ2h1bmtQcmVmZXRjaEl0ZXJhdG9yLmpzXCI7XG5pbXBvcnQgV3JhcHBlZFN0b3JlIGZyb20gXCIuL3phcnJfdXRpbHMvV3JhcHBlZFN0b3JlLmpzXCI7XG5pbXBvcnQgeyBnZXREaW1lbnNpb25Db3VudCwgZ2V0U2NhbGUsIGdldFNvdXJjZUNoYW5uZWxOYW1lcywgbWF0Y2hTb3VyY2VTY2FsZUxldmVscywgb3JkZXJCeURpbWVuc2lvbiwgb3JkZXJCeVRDWllYLCByZW1hcEF4ZXNUb1RDWllYIH0gZnJvbSBcIi4vemFycl91dGlscy91dGlscy5qc1wiO1xuaW1wb3J0IHsgVm9sdW1lTG9hZEVycm9yLCBWb2x1bWVMb2FkRXJyb3JUeXBlLCB3cmFwVm9sdW1lTG9hZEVycm9yIH0gZnJvbSBcIi4vVm9sdW1lTG9hZEVycm9yLmpzXCI7XG5pbXBvcnQgeyB2YWxpZGF0ZU9NRVphcnJNZXRhZGF0YSB9IGZyb20gXCIuL3phcnJfdXRpbHMvdmFsaWRhdGlvbi5qc1wiO1xuY29uc3QgQ0hVTktfUkVRVUVTVF9DQU5DRUxfUkVBU09OID0gXCJjaHVuayByZXF1ZXN0IGNhbmNlbGxlZFwiO1xuXG4vLyByZXR1cm5zIHRoZSBjb252ZXJ0ZWQgZGF0YSBhbmQgdGhlIG9yaWdpbmFsIG1pbiBhbmQgbWF4IHZhbHVlcyAod2hpY2ggaGF2ZSBiZWVuIHJlbWFwcGVkIHRvIDAgYW5kIDI1NSlcbmZ1bmN0aW9uIGNvbnZlcnRDaGFubmVsKGNoYW5uZWxEYXRhKSB7XG4gIC8vIGdldCBtaW4gYW5kIG1heFxuICBsZXQgbWluID0gY2hhbm5lbERhdGFbMF07XG4gIGxldCBtYXggPSBjaGFubmVsRGF0YVswXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFubmVsRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbCA9IGNoYW5uZWxEYXRhW2ldO1xuICAgIGlmICh2YWwgPCBtaW4pIHtcbiAgICAgIG1pbiA9IHZhbDtcbiAgICB9XG4gICAgaWYgKHZhbCA+IG1heCkge1xuICAgICAgbWF4ID0gdmFsO1xuICAgIH1cbiAgfVxuICBpZiAoY2hhbm5lbERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIFtjaGFubmVsRGF0YSwgbWluLCBtYXhdO1xuICB9XG5cbiAgLy8gbm9ybWFsaXplIGFuZCBjb252ZXJ0IHRvIHU4XG4gIGNvbnN0IHU4ID0gbmV3IFVpbnQ4QXJyYXkoY2hhbm5lbERhdGEubGVuZ3RoKTtcbiAgY29uc3QgcmFuZ2UgPSBtYXggLSBtaW47XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbm5lbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB1OFtpXSA9IChjaGFubmVsRGF0YVtpXSAtIG1pbikgLyByYW5nZSAqIDI1NTtcbiAgfVxuICByZXR1cm4gW3U4LCBtaW4sIG1heF07XG59XG5jb25zdCBERUZBVUxUX0ZFVENIX09QVElPTlMgPSB7XG4gIG1heFByZWZldGNoRGlzdGFuY2U6IFs1LCA1LCA1LCA1XSxcbiAgbWF4UHJlZmV0Y2hDaHVua3M6IDMwXG59O1xuY2xhc3MgT01FWmFyckxvYWRlciBleHRlbmRzIFRocmVhZGFibGVWb2x1bWVMb2FkZXIge1xuICAvKiogVGhlIElEIG9mIHRoZSBzdWJzY3JpYmVyIHJlc3BvbnNpYmxlIGZvciBcImFjdHVhbCBsb2Fkc1wiIChub24tcHJlZmV0Y2ggcmVxdWVzdHMpICovXG5cbiAgLyoqIFRoZSBJRCBvZiB0aGUgc3Vic2NyaWJlciByZXNwb25zaWJsZSBmb3IgcHJlZmV0Y2hlcywgc28gdGhhdCByZXF1ZXN0cyBjYW4gYmUgY2FuY2VsbGVkIGFuZCByZWlzc3VlZCAqL1xuXG4gIC8vIFRPRE86IHRoaXMgcHJvcGVydHkgc2hvdWxkIGRlZmluaXRlbHkgYmUgb3duZWQgYnkgYFZvbHVtZWAgaWYgdGhpcyBsb2FkZXIgaXMgZXZlciB1c2VkIGJ5IG11bHRpcGxlIHZvbHVtZXMuXG4gIC8vICAgVGhpcyBtYXkgY2F1c2UgZXJyb3JzIG9yIGluY29ycmVjdCByZXN1bHRzIG90aGVyd2lzZSFcblxuICBzeW5jQ2hhbm5lbHMgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IoXG4gIC8qKlxyXG4gICAqIEFycmF5IG9mIHJlY29yZHMsIGVhY2ggY29udGFpbmluZyB0aGUgb2JqZWN0cyBhbmQgbWV0YWRhdGEgd2UgbmVlZCB0byBsb2FkIGZyb20gb25lIHNvdXJjZSBvZiBtdWx0aXNjYWxlIHphcnJcclxuICAgKiBkYXRhLiBTZWUgZG9jdW1lbnRhdGlvbiBvbiBgWmFyclNvdXJjZWAgZm9yIG1vcmUuXHJcbiAgICovXG4gIHNvdXJjZXMsIC8qKiBIYW5kbGUgdG8gYSBgU3Vic2NyaWJhYmxlUmVxdWVzdFF1ZXVlYCBmb3Igc21hcnQgY29uY3VycmVuY3kgbWFuYWdlbWVudCBhbmQgcmVxdWVzdCBjYW5jZWxsaW5nL3JlaXNzdWluZy4gKi9cbiAgcmVxdWVzdFF1ZXVlLCAvKiogT3B0aW9ucyB0byBjb25maWd1cmUgKHByZSlmZXRjaGluZyBiZWhhdmlvci4gKi9cbiAgZmV0Y2hPcHRpb25zID0gREVGQVVMVF9GRVRDSF9PUFRJT05TLCAvKiogRGlyZWN0aW9uKHMpIHRvIHByaW9yaXRpemUgd2hlbiBwcmVmZXRjaGluZy4gU3RvcmVkIHNlcGFyYXRlIGZyb20gYGZldGNoT3B0aW9uc2Agc2luY2UgaXQgbWF5IGJlIG11dGF0ZWQuICovXG4gIHByaW9yaXR5RGlyZWN0aW9ucyA9IFtdKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgIHRoaXMucmVxdWVzdFF1ZXVlID0gcmVxdWVzdFF1ZXVlO1xuICAgIHRoaXMuZmV0Y2hPcHRpb25zID0gZmV0Y2hPcHRpb25zO1xuICAgIHRoaXMucHJpb3JpdHlEaXJlY3Rpb25zID0gcHJpb3JpdHlEaXJlY3Rpb25zO1xuICB9XG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBgT01FWmFyckxvYWRlcmAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdXJscyBUaGUgVVJMKHMpIG9mIHRoZSBPTUUtWmFyciBkYXRhIHRvIGxvYWQuIElmIGB1cmxzYCBpcyBhbiBhcnJheSwgdGhlIGxvYWRlciB3aWxsIGF0dGVtcHQgdG8gZmluZCBzY2FsZVxyXG4gICAqICBsZXZlbHMgd2l0aCBleGFjdGx5IHRoZSBzYW1lIHNpemUgaW4gZXZlcnkgc291cmNlLiBJZiBtYXRjaGluZyBsZXZlbChzKSBhcmUgYXZhaWxhYmxlLCB0aGUgbG9hZGVyIHdpbGwgcHJvZHVjZSBhXHJcbiAgICogIHZvbHVtZSBjb250YWluaW5nIGFsbCBjaGFubmVscyBmcm9tIGV2ZXJ5IHByb3ZpZGVkIHphcnIgaW4gdGhlIG9yZGVyIHRoZXkgYXBwZWFyIGluIGB1cmxzYC4gSWYgbm8gbWF0Y2hpbmcgc2V0c1xyXG4gICAqICBvZiBzY2FsZSBsZXZlbHMgYXJlIGF2YWlsYWJsZSwgY3JlYXRpb24gZmFpbHMuXHJcbiAgICogQHBhcmFtIHNjZW5lcyBUaGUgc2NlbmUocykgdG8gbG9hZCBmcm9tIGVhY2ggVVJMLiBJZiBgdXJsc2AgaXMgYW4gYXJyYXksIGBzY2VuZXNgIG1heSBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgdmFsdWVzXHJcbiAgICogIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBVUkwsIG9yIGEgc2luZ2xlIHZhbHVlIHRvIGFwcGx5IHRvIGFsbCBVUkxzLiBEZWZhdWx0IDAuXHJcbiAgICogQHBhcmFtIGNhY2hlIEEgY2FjaGUgdG8gdXNlIGZvciBzdG9yaW5nIGZldGNoZWQgZGF0YS4gSWYgbm90IHByb3ZpZGVkLCBhIG5ldyBjYWNoZSB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICogQHBhcmFtIHF1ZXVlIEEgcXVldWUgdG8gdXNlIGZvciBtYW5hZ2luZyByZXF1ZXN0cy4gSWYgbm90IHByb3ZpZGVkLCBhIG5ldyBxdWV1ZSB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICogQHBhcmFtIGZldGNoT3B0aW9ucyBPcHRpb25zIHRvIGNvbmZpZ3VyZSAocHJlKWZldGNoaW5nIGJlaGF2aW9yLlxyXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlTG9hZGVyKHVybHMsIHNjZW5lcyA9IDAsIGNhY2hlLCBxdWV1ZSwgZmV0Y2hPcHRpb25zKSB7XG4gICAgLy8gU2V0dXAgcXVldWUgYW5kIHN0b3JlLCBnZXQgYmFzaWMgbWV0YWRhdGFcbiAgICBpZiAoIXF1ZXVlKSB7XG4gICAgICBxdWV1ZSA9IG5ldyBTdWJzY3JpYmFibGVSZXF1ZXN0UXVldWUoZmV0Y2hPcHRpb25zPy5jb25jdXJyZW5jeUxpbWl0LCBmZXRjaE9wdGlvbnM/LnByZWZldGNoQ29uY3VycmVuY3lMaW1pdCk7XG4gICAgfVxuICAgIGNvbnN0IHVybHNBcnIgPSBBcnJheS5pc0FycmF5KHVybHMpID8gdXJscyA6IFt1cmxzXTtcbiAgICBjb25zdCBzY2VuZXNBcnIgPSBBcnJheS5pc0FycmF5KHNjZW5lcykgPyBzY2VuZXMgOiBbc2NlbmVzXTtcblxuICAgIC8vIENyZWF0ZSBvbmUgYFphcnJTb3VyY2VgIHBlciBVUkxcbiAgICBjb25zdCBzb3VyY2VQcm9tcyA9IHVybHNBcnIubWFwKGFzeW5jICh1cmwsIGkpID0+IHtcbiAgICAgIGNvbnN0IHN0b3JlID0gbmV3IFdyYXBwZWRTdG9yZShuZXcgRmV0Y2hTdG9yZSh1cmwpLCBjYWNoZSwgcXVldWUpO1xuICAgICAgY29uc3Qgcm9vdCA9IHphcnIucm9vdChzdG9yZSk7XG4gICAgICBjb25zdCBncm91cCA9IGF3YWl0IHphcnIub3Blbihyb290LCB7XG4gICAgICAgIGtpbmQ6IFwiZ3JvdXBcIlxuICAgICAgfSkuY2F0Y2god3JhcFZvbHVtZUxvYWRFcnJvcihgRmFpbGVkIHRvIG9wZW4gT01FLVphcnIgZGF0YSBhdCAke3VybH1gLCBWb2x1bWVMb2FkRXJyb3JUeXBlLk5PVF9GT1VORCkpO1xuXG4gICAgICAvLyBQaWNrIHNjZW5lIChtdWx0aXNjYWxlKVxuICAgICAgbGV0IHNjZW5lID0gc2NlbmVzQXJyW01hdGgubWluKGksIHNjZW5lc0Fyci5sZW5ndGggLSAxKV07XG4gICAgICBpZiAoc2NlbmUgPiBncm91cC5hdHRycy5tdWx0aXNjYWxlcz8ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgV0FSTklORzogT01FWmFyckxvYWRlcjogc2NlbmUgJHtzY2VuZX0gaXMgaW52YWxpZC4gVXNpbmcgc2NlbmUgMC5gKTtcbiAgICAgICAgc2NlbmUgPSAwO1xuICAgICAgfVxuICAgICAgdmFsaWRhdGVPTUVaYXJyTWV0YWRhdGEoZ3JvdXAuYXR0cnMsIHNjZW5lLCB1cmxzQXJyLmxlbmd0aCA+IDEgPyBgWmFyciBzb3VyY2UgJHtpfWAgOiBcIlphcnJcIik7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG11bHRpc2NhbGVzLFxuICAgICAgICBvbWVyb1xuICAgICAgfSA9IGdyb3VwLmF0dHJzO1xuICAgICAgY29uc3QgbXVsdGlzY2FsZU1ldGFkYXRhID0gbXVsdGlzY2FsZXNbc2NlbmVdO1xuXG4gICAgICAvLyBPcGVuIGFsbCBzY2FsZSBsZXZlbHMgb2YgbXVsdGlzY2FsZVxuICAgICAgY29uc3QgbHZsUHJvbXMgPSBtdWx0aXNjYWxlTWV0YWRhdGEuZGF0YXNldHMubWFwKCh7XG4gICAgICAgIHBhdGhcbiAgICAgIH0pID0+IHphcnIub3Blbihyb290LnJlc29sdmUocGF0aCksIHtcbiAgICAgICAga2luZDogXCJhcnJheVwiXG4gICAgICB9KS5jYXRjaCh3cmFwVm9sdW1lTG9hZEVycm9yKGBGYWlsZWQgdG8gb3BlbiBzY2FsZSBsZXZlbCAke3BhdGh9IG9mIE9NRS1aYXJyIGRhdGEgYXQgJHt1cmx9YCwgVm9sdW1lTG9hZEVycm9yVHlwZS5OT1RfRk9VTkQpKSk7XG4gICAgICBjb25zdCBzY2FsZUxldmVscyA9IGF3YWl0IFByb21pc2UuYWxsKGx2bFByb21zKTtcbiAgICAgIGNvbnN0IGF4ZXNUQ1pZWCA9IHJlbWFwQXhlc1RvVENaWVgobXVsdGlzY2FsZU1ldGFkYXRhLmF4ZXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGVMZXZlbHMsXG4gICAgICAgIG11bHRpc2NhbGVNZXRhZGF0YSxcbiAgICAgICAgb21lcm9NZXRhZGF0YTogb21lcm8sXG4gICAgICAgIGF4ZXNUQ1pZWCxcbiAgICAgICAgY2hhbm5lbE9mZnNldDogMFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBzb3VyY2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoc291cmNlUHJvbXMpO1xuXG4gICAgLy8gU2V0IGBjaGFubmVsT2Zmc2V0YHMgc28gd2UgY2FuIG1hdGNoIGNoYW5uZWwgaW5kaWNlcyB0byBzb3VyY2VzXG4gICAgbGV0IGNoYW5uZWxDb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBzIG9mIHNvdXJjZXMpIHtcbiAgICAgIHMuY2hhbm5lbE9mZnNldCA9IGNoYW5uZWxDb3VudDtcbiAgICAgIGNoYW5uZWxDb3VudCArPSBzLm9tZXJvTWV0YWRhdGE/LmNoYW5uZWxzLmxlbmd0aCA/PyBzLnNjYWxlTGV2ZWxzWzBdLnNoYXBlW3MuYXhlc1RDWllYWzFdXTtcbiAgICB9XG4gICAgLy8gRW5zdXJlIHRoZSBzaXplcyBvZiBhbGwgc291cmNlcycgc2NhbGUgbGV2ZWxzIGFyZSBtYXRjaGVkIHVwLiBTZWUgdGhpcyBmdW5jdGlvbidzIGRvY3MgZm9yIG1vcmUuXG4gICAgbWF0Y2hTb3VyY2VTY2FsZUxldmVscyhzb3VyY2VzKTtcbiAgICAvLyBUT0RPOiBpZiBgbWF0Y2hTb3VyY2VTY2FsZUxldmVsc2AgcmV0dXJuZWQgc3VjY2Vzc2Z1bGx5LCBldmVyeSBvbmUgb2YgdGhlc2Ugc291cmNlcycgYG11bHRpc2NhbGVNZXRhZGF0YWAgaXMgdGhlXG4gICAgLy8gc2FtZSBpbiBldmVyeSBmaWVsZCB3ZSBjYXJlIGFib3V0LCBzbyB3ZSBvbmx5IGV2ZXIgdXNlIHRoZSBmaXJzdCBzb3VyY2UncyBgbXVsdGlzY2FsZU1ldGFkYXRhYCBhZnRlciB0aGlzIHBvaW50LlxuICAgIC8vIFNob3VsZCB3ZSBvbmx5IHN0b3JlIG9uZSBgT01FTXVsdGlzY2FsZWAgcmVjb3JkIHRvdGFsLCByYXRoZXIgdGhhbiBvbmUgcGVyIHNvdXJjZT9cbiAgICBjb25zdCBwcmlvcml0eURpcnMgPSBmZXRjaE9wdGlvbnM/LnByaW9yaXR5RGlyZWN0aW9ucyA/IGZldGNoT3B0aW9ucy5wcmlvcml0eURpcmVjdGlvbnMuc2xpY2UoKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbmV3IE9NRVphcnJMb2FkZXIoc291cmNlcywgcXVldWUsIGZldGNoT3B0aW9ucywgcHJpb3JpdHlEaXJzKTtcbiAgfVxuICBnZXRVbml0U3ltYm9scygpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZXNbMF07XG4gICAgLy8gQXNzdW1lIGFsbCBzcGF0aWFsIGF4ZXMgaW4gYWxsIHNvdXJjZXMgaGF2ZSB0aGUgc2FtZSB1bml0cyAtIHdlIGhhdmUgbm8gbWVhbnMgb2Ygc3RvcmluZyBwZXItYXhpcyB1bml0IHN5bWJvbHNcbiAgICBjb25zdCB4aSA9IHNvdXJjZS5heGVzVENaWVhbNF07XG4gICAgY29uc3Qgc3BhY2VVbml0TmFtZSA9IHNvdXJjZS5tdWx0aXNjYWxlTWV0YWRhdGEuYXhlc1t4aV0udW5pdDtcbiAgICBjb25zdCBzcGFjZVVuaXRTeW1ib2wgPSB1bml0TmFtZVRvU3ltYm9sKHNwYWNlVW5pdE5hbWUpIHx8IHNwYWNlVW5pdE5hbWUgfHwgXCJcIjtcbiAgICBjb25zdCB0aSA9IHNvdXJjZS5heGVzVENaWVhbMF07XG4gICAgY29uc3QgdGltZVVuaXROYW1lID0gdGkgPiAtMSA/IHNvdXJjZS5tdWx0aXNjYWxlTWV0YWRhdGEuYXhlc1t0aV0udW5pdCA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCB0aW1lVW5pdFN5bWJvbCA9IHVuaXROYW1lVG9TeW1ib2wodGltZVVuaXROYW1lKSB8fCB0aW1lVW5pdE5hbWUgfHwgXCJcIjtcbiAgICByZXR1cm4gW3NwYWNlVW5pdFN5bWJvbCwgdGltZVVuaXRTeW1ib2xdO1xuICB9XG4gIGdldExldmVsU2hhcGVzWllYKCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlc1swXTtcbiAgICBjb25zdCBbeiwgeSwgeF0gPSBzb3VyY2UuYXhlc1RDWllYLnNsaWNlKC0zKTtcbiAgICByZXR1cm4gc291cmNlLnNjYWxlTGV2ZWxzLm1hcCgoe1xuICAgICAgc2hhcGVcbiAgICB9KSA9PiBbeiA9PT0gLTEgPyAxIDogc2hhcGVbel0sIHNoYXBlW3ldLCBzaGFwZVt4XV0pO1xuICB9XG4gIGdldFNjYWxlKGxldmVsKSB7XG4gICAgcmV0dXJuIGdldFNjYWxlKHRoaXMuc291cmNlc1swXS5tdWx0aXNjYWxlTWV0YWRhdGEuZGF0YXNldHNbbGV2ZWxdLCB0aGlzLnNvdXJjZXNbMF0uYXhlc1RDWllYKTtcbiAgfVxuICBvcmRlckJ5RGltZW5zaW9uKHZhbHNUQ1pZWCwgc291cmNlSWR4ID0gMCkge1xuICAgIHJldHVybiBvcmRlckJ5RGltZW5zaW9uKHZhbHNUQ1pZWCwgdGhpcy5zb3VyY2VzW3NvdXJjZUlkeF0uYXhlc1RDWllYKTtcbiAgfVxuICBvcmRlckJ5VENaWVgodmFsc0RpbWVuc2lvbiwgZGVmYXVsdFZhbHVlLCBzb3VyY2VJZHggPSAwKSB7XG4gICAgcmV0dXJuIG9yZGVyQnlUQ1pZWCh2YWxzRGltZW5zaW9uLCB0aGlzLnNvdXJjZXNbc291cmNlSWR4XS5heGVzVENaWVgsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICAvKipcclxuICAgKiBDb252ZXJ0cyBhIHZvbHVtZSBjaGFubmVsIGluZGV4IHRvIHRoZSBpbmRleCBvZiBpdHMgemFyciBzb3VyY2UgYW5kIGl0cyBjaGFubmVsIGluZGV4IHdpdGhpbiB0aGF0IHphcnIuXHJcbiAgICogZS5nLiwgaWYgdGhlIGxvYWRlciBoYXMgMiBzb3VyY2VzLCB0aGUgZmlyc3Qgd2l0aCAzIGNoYW5uZWxzIGFuZCB0aGUgc2Vjb25kIHdpdGggMiwgdGhlbiBgbWF0Y2hDaGFubmVsVG9Tb3VyY2UoNClgXHJcbiAgICogcmV0dXJucyBgWzEsIDFdYCAodGhlIHNlY29uZCBjaGFubmVsIG9mIHRoZSBzZWNvbmQgc291cmNlKS5cclxuICAgKi9cbiAgbWF0Y2hDaGFubmVsVG9Tb3VyY2UoYWJzb2x1dGVDaGFubmVsSW5kZXgpIHtcbiAgICBjb25zdCBsYXN0U3JjSWR4ID0gdGhpcy5zb3VyY2VzLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgbGFzdFNyYyA9IHRoaXMuc291cmNlc1tsYXN0U3JjSWR4XTtcbiAgICBjb25zdCBsYXN0U3JjTnVtQ2hhbm5lbHMgPSBsYXN0U3JjLnNjYWxlTGV2ZWxzWzBdLnNoYXBlW2xhc3RTcmMuYXhlc1RDWllYWzFdXTtcbiAgICBjb25zdCBtYXhDaGFubmVsSW5kZXggPSBsYXN0U3JjLmNoYW5uZWxPZmZzZXQgKyBsYXN0U3JjTnVtQ2hhbm5lbHM7XG4gICAgaWYgKGFic29sdXRlQ2hhbm5lbEluZGV4ID4gbWF4Q2hhbm5lbEluZGV4KSB7XG4gICAgICB0aHJvdyBuZXcgVm9sdW1lTG9hZEVycm9yKGBWb2x1bWUgY2hhbm5lbCBpbmRleCAke2Fic29sdXRlQ2hhbm5lbEluZGV4fSBvdXQgb2YgcmFuZ2UgKCR7bWF4Q2hhbm5lbEluZGV4fSBjaGFubmVscyBhdmFpbGFibGUpYCwge1xuICAgICAgICB0eXBlOiBWb2x1bWVMb2FkRXJyb3JUeXBlLklOVkFMSURfTUVUQURBVEFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdEdyZWF0ZXJJZHggPSB0aGlzLnNvdXJjZXMuZmluZEluZGV4KHNyYyA9PiBzcmMuY2hhbm5lbE9mZnNldCA+IGFic29sdXRlQ2hhbm5lbEluZGV4KTtcbiAgICBjb25zdCBzb3VyY2VJbmRleCA9IGZpcnN0R3JlYXRlcklkeCA9PT0gLTEgPyBsYXN0U3JjSWR4IDogZmlyc3RHcmVhdGVySWR4IC0gMTtcbiAgICBjb25zdCBjaGFubmVsSW5kZXhJblNvdXJjZSA9IGFic29sdXRlQ2hhbm5lbEluZGV4IC0gdGhpcy5zb3VyY2VzW3NvdXJjZUluZGV4XS5jaGFubmVsT2Zmc2V0O1xuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2VJbmRleCxcbiAgICAgIGNoYW5uZWxJbmRleEluU291cmNlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIENoYW5nZSB3aGljaCBkaXJlY3Rpb25zIHRvIHByaW9yaXRpemUgd2hlbiBwcmVmZXRjaGluZy4gQWxsIGNodW5rcyB3aWxsIGJlIHByZWZldGNoZWQgaW4gdGhlc2UgZGlyZWN0aW9ucyBiZWZvcmVcclxuICAgKiBhbnkgY2h1bmtzIGFyZSBwcmVmZXRjaGVkIGluIGFueSBvdGhlciBkaXJlY3Rpb25zLlxyXG4gICAqL1xuICBzZXRQcmVmZXRjaFByaW9yaXR5KGRpcmVjdGlvbnMpIHtcbiAgICB0aGlzLnByaW9yaXR5RGlyZWN0aW9ucyA9IGRpcmVjdGlvbnM7XG4gIH1cbiAgc3luY011bHRpY2hhbm5lbExvYWRpbmcoc3luYykge1xuICAgIHRoaXMuc3luY0NoYW5uZWxzID0gc3luYztcbiAgfVxuICBsb2FkRGltcyhsb2FkU3BlYykge1xuICAgIGNvbnN0IFtzcGFjZVVuaXQsIHRpbWVVbml0XSA9IHRoaXMuZ2V0VW5pdFN5bWJvbHMoKTtcbiAgICAvLyBDb21wdXRlIHN1YnJlZ2lvbiBzaXplIHNvIHdlIGNhbiBmYWN0b3IgdGhhdCBpblxuICAgIGNvbnN0IG1heEV4dGVudCA9IHRoaXMubWF4RXh0ZW50ID8/IG5ldyBCb3gzKG5ldyBWZWN0b3IzKDAsIDAsIDApLCBuZXcgVmVjdG9yMygxLCAxLCAxKSk7XG4gICAgY29uc3Qgc3VicmVnaW9uID0gY29tcG9zZVN1YnJlZ2lvbihsb2FkU3BlYy5zdWJyZWdpb24sIG1heEV4dGVudCk7XG4gICAgY29uc3QgcmVnaW9uU2l6ZSA9IHN1YnJlZ2lvbi5nZXRTaXplKG5ldyBWZWN0b3IzKCkpO1xuICAgIGNvbnN0IHJlZ2lvbkFyciA9IFsxLCAxLCByZWdpb25TaXplLnosIHJlZ2lvblNpemUueSwgcmVnaW9uU2l6ZS54XTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNvdXJjZXNbMF0uc2NhbGVMZXZlbHMubWFwKChsZXZlbCwgaSkgPT4ge1xuICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLmdldFNjYWxlKGkpO1xuICAgICAgY29uc3QgZGltcyA9IG5ldyBWb2x1bWVEaW1zKCk7XG4gICAgICBkaW1zLnNwYWNlVW5pdCA9IHNwYWNlVW5pdDtcbiAgICAgIGRpbXMudGltZVVuaXQgPSB0aW1lVW5pdDtcbiAgICAgIGRpbXMuc2hhcGUgPSB0aGlzLm9yZGVyQnlUQ1pZWChsZXZlbC5zaGFwZSwgMSkubWFwKCh2YWwsIGlkeCkgPT4gTWF0aC5tYXgoTWF0aC5jZWlsKHZhbCAqIHJlZ2lvbkFycltpZHhdKSwgMSkpO1xuICAgICAgZGltcy5zcGFjaW5nID0gdGhpcy5vcmRlckJ5VENaWVgoc2NhbGUsIDEpO1xuICAgICAgcmV0dXJuIGRpbXM7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICB9XG4gIGNyZWF0ZUltYWdlSW5mbyhsb2FkU3BlYykge1xuICAgIC8vIFdlIGVuc3VyZWQgbW9zdCBpbmZvIChkaW1zLCBjaHVua3MsIGV0Yy4pIG1hdGNoZWQgYmV0d2VlbiBzb3VyY2VzIGVhcmxpZXIsIHNvIHdlIGNhbiBqdXN0IHVzZSB0aGUgZmlyc3Qgc291cmNlLlxuICAgIGNvbnN0IHNvdXJjZTAgPSB0aGlzLnNvdXJjZXNbMF07XG4gICAgY29uc3QgW3QsLCB6LCB5LCB4XSA9IHNvdXJjZTAuYXhlc1RDWllYO1xuICAgIGNvbnN0IGhhc1QgPSB0ID4gLTE7XG4gICAgY29uc3QgaGFzWiA9IHogPiAtMTtcbiAgICBjb25zdCBzaGFwZTAgPSBzb3VyY2UwLnNjYWxlTGV2ZWxzWzBdLnNoYXBlO1xuICAgIGNvbnN0IGxldmVsVG9Mb2FkID0gcGlja0xldmVsVG9Mb2FkKGxvYWRTcGVjLCB0aGlzLmdldExldmVsU2hhcGVzWllYKCkpO1xuICAgIGNvbnN0IHNoYXBlTHYgPSBzb3VyY2UwLnNjYWxlTGV2ZWxzW2xldmVsVG9Mb2FkXS5zaGFwZTtcbiAgICBjb25zdCBbc3BhdGlhbFVuaXQsIHRpbWVVbml0XSA9IHRoaXMuZ2V0VW5pdFN5bWJvbHMoKTtcblxuICAgIC8vIE5vdyB3ZSBjYXJlIGFib3V0IG90aGVyIHNvdXJjZXM6ICMgb2YgY2hhbm5lbHMgaXMgdGhlIGBjaGFubmVsT2Zmc2V0YCBvZiB0aGUgbGFzdCBzb3VyY2UgcGx1cyBpdHMgIyBvZiBjaGFubmVsc1xuICAgIGNvbnN0IHNvdXJjZUxhc3QgPSB0aGlzLnNvdXJjZXNbdGhpcy5zb3VyY2VzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGNMYXN0ID0gc291cmNlTGFzdC5heGVzVENaWVhbMV07XG4gICAgY29uc3QgbGFzdEhhc0MgPSBjTGFzdCA+IC0xO1xuICAgIGNvbnN0IG51bUNoYW5uZWxzID0gc291cmNlTGFzdC5jaGFubmVsT2Zmc2V0ICsgKGxhc3RIYXNDID8gc291cmNlTGFzdC5zY2FsZUxldmVsc1tsZXZlbFRvTG9hZF0uc2hhcGVbY0xhc3RdIDogMSk7XG4gICAgLy8gd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgY29ycmVzcG9uZGluZyBtYXRjaGVkIHNoYXBlc1xuICAgIC8vIHVzZSB0aGUgbWluIHNpemUgb2YgVFxuICAgIGxldCB0aW1lcyA9IDE7XG4gICAgaWYgKGhhc1QpIHtcbiAgICAgIHRpbWVzID0gc2hhcGVMdlt0XTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5zb3VyY2VzW2ldLnNjYWxlTGV2ZWxzW2xldmVsVG9Mb2FkXS5zaGFwZTtcbiAgICAgICAgY29uc3QgdGluZGV4ID0gdGhpcy5zb3VyY2VzW2ldLmF4ZXNUQ1pZWFswXTtcbiAgICAgICAgaWYgKHNoYXBlW3RpbmRleF0gPCB0aW1lcykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBudW1iZXIgb2YgdGltZSBwb2ludHMgaXMgbm90IGNvbnNpc3RlbnQgYWNyb3NzIHNvdXJjZXM6IFwiLCBzaGFwZVt0aW5kZXhdLCB0aW1lcyk7XG4gICAgICAgICAgdGltZXMgPSBzaGFwZVt0aW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5tYXhFeHRlbnQpIHtcbiAgICAgIHRoaXMubWF4RXh0ZW50ID0gbG9hZFNwZWMuc3VicmVnaW9uLmNsb25lKCk7XG4gICAgfVxuICAgIGNvbnN0IHB4RGltczAgPSBjb252ZXJ0U3VicmVnaW9uVG9QaXhlbHMobG9hZFNwZWMuc3VicmVnaW9uLCBuZXcgVmVjdG9yMyhzaGFwZTBbeF0sIHNoYXBlMFt5XSwgaGFzWiA/IHNoYXBlMFt6XSA6IDEpKTtcbiAgICBjb25zdCBweFNpemUwID0gcHhEaW1zMC5nZXRTaXplKG5ldyBWZWN0b3IzKCkpO1xuICAgIGNvbnN0IHB4RGltc0x2ID0gY29udmVydFN1YnJlZ2lvblRvUGl4ZWxzKGxvYWRTcGVjLnN1YnJlZ2lvbiwgbmV3IFZlY3RvcjMoc2hhcGVMdlt4XSwgc2hhcGVMdlt5XSwgaGFzWiA/IHNoYXBlTHZbel0gOiAxKSk7XG4gICAgY29uc3QgcHhTaXplTHYgPSBweERpbXNMdi5nZXRTaXplKG5ldyBWZWN0b3IzKCkpO1xuICAgIGNvbnN0IGF0bGFzVGlsZURpbXMgPSBjb21wdXRlUGFja2VkQXRsYXNEaW1zKHB4U2l6ZUx2LnosIHB4U2l6ZUx2LngsIHB4U2l6ZUx2LnkpO1xuXG4gICAgLy8gQ2hhbm5lbCBuYW1lcyBpcyB0aGUgb3RoZXIgcGxhY2Ugd2hlcmUgd2UgaGF2ZSB0byBjaGVjayBldmVyeSBzb3VyY2VcbiAgICAvLyBUcmFjayB3aGljaCBjaGFubmVsIG5hbWVzIHdlJ3ZlIHNlZW4gc28gZmFyLCBzbyB0aGF0IHdlIGNhbiByZW5hbWUgdGhlbSB0byBhdm9pZCBuYW1lIGNvbGxpc2lvbnNcbiAgICBjb25zdCBjaGFubmVsTmFtZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgY2hhbm5lbE5hbWVzID0gdGhpcy5zb3VyY2VzLmZsYXRNYXAoc3JjID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZUNoYW5uZWxOYW1lcyA9IGdldFNvdXJjZUNoYW5uZWxOYW1lcyhzcmMpO1xuXG4gICAgICAvLyBSZXNvbHZlIG5hbWUgY29sbGlzaW9uc1xuICAgICAgcmV0dXJuIHNvdXJjZUNoYW5uZWxOYW1lcy5tYXAoY2hhbm5lbE5hbWUgPT4ge1xuICAgICAgICBjb25zdCBudW1NYXRjaGluZ0NoYW5uZWxzID0gY2hhbm5lbE5hbWVzTWFwLmdldChjaGFubmVsTmFtZSk7XG4gICAgICAgIGlmIChudW1NYXRjaGluZ0NoYW5uZWxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBJZiBlLmcuIHdlJ3ZlIHNlZW4gY2hhbm5lbCBcIk1lbWJyYW5lXCIgb25jZSBiZWZvcmUsIHJlbmFtZSB0aGlzIG9uZSB0byBcIk1lbWJyYW5lICgxKVwiXG4gICAgICAgICAgY2hhbm5lbE5hbWVzTWFwLnNldChjaGFubmVsTmFtZSwgbnVtTWF0Y2hpbmdDaGFubmVscyArIDEpO1xuICAgICAgICAgIHJldHVybiBgJHtjaGFubmVsTmFtZX0gKCR7bnVtTWF0Y2hpbmdDaGFubmVsc30pYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFubmVsTmFtZXNNYXAuc2V0KGNoYW5uZWxOYW1lLCAxKTtcbiAgICAgICAgICByZXR1cm4gY2hhbm5lbE5hbWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gZm9yIHBoeXNpY2FsUGl4ZWxTaXplLCB3ZSB1c2UgdGhlIHNjYWxlIG9mIHRoZSBmaXJzdCBsZXZlbFxuICAgIGNvbnN0IHNjYWxlNWQgPSB0aGlzLmdldFNjYWxlKDApO1xuICAgIC8vIGFzc3VtZSB0aGF0IEltYWdlSW5mbyB3YW50cyB0aGUgdGltZVNjYWxlIG9mIGxldmVsIDBcbiAgICBjb25zdCB0aW1lU2NhbGUgPSBoYXNUID8gc2NhbGU1ZFt0XSA6IDE7XG4gICAgY29uc3QgaW1nZGF0YSA9IHtcbiAgICAgIG5hbWU6IHNvdXJjZTAub21lcm9NZXRhZGF0YT8ubmFtZSB8fCBcIlZvbHVtZVwiLFxuICAgICAgb3JpZ2luYWxTaXplOiBweFNpemUwLFxuICAgICAgYXRsYXNUaWxlRGltcyxcbiAgICAgIHZvbHVtZVNpemU6IHB4U2l6ZUx2LFxuICAgICAgc3VicmVnaW9uU2l6ZTogcHhTaXplTHYuY2xvbmUoKSxcbiAgICAgIHN1YnJlZ2lvbk9mZnNldDogbmV3IFZlY3RvcjMoMCwgMCwgMCksXG4gICAgICBwaHlzaWNhbFBpeGVsU2l6ZTogbmV3IFZlY3RvcjMoc2NhbGU1ZFt4XSwgc2NhbGU1ZFt5XSwgaGFzWiA/IHNjYWxlNWRbel0gOiBNYXRoLm1pbihzY2FsZTVkW3hdLCBzY2FsZTVkW3ldKSksXG4gICAgICBzcGF0aWFsVW5pdCxcbiAgICAgIG51bUNoYW5uZWxzLFxuICAgICAgY2hhbm5lbE5hbWVzLFxuICAgICAgdGltZXMsXG4gICAgICB0aW1lU2NhbGUsXG4gICAgICB0aW1lVW5pdCxcbiAgICAgIG51bU11bHRpc2NhbGVMZXZlbHM6IHNvdXJjZTAuc2NhbGVMZXZlbHMubGVuZ3RoLFxuICAgICAgbXVsdGlzY2FsZUxldmVsOiBsZXZlbFRvTG9hZCxcbiAgICAgIHRyYW5zZm9ybToge1xuICAgICAgICB0cmFuc2xhdGlvbjogbmV3IFZlY3RvcjMoMCwgMCwgMCksXG4gICAgICAgIHJvdGF0aW9uOiBuZXcgVmVjdG9yMygwLCAwLCAwKVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBUaGUgYExvYWRTcGVjYCBwYXNzZWQgaW4gYXQgdGhpcyBzdGFnZSBzaG91bGQgcmVwcmVzZW50IHRoZSBzdWJzZXQgd2hpY2ggdGhpcyBsb2FkZXIgbG9hZHMsIG5vdCB0aGF0XG4gICAgLy8gd2hpY2ggdGhlIHZvbHVtZSBjb250YWlucy4gVGhlIHZvbHVtZSBjb250YWlucyB0aGUgZnVsbCBleHRlbnQgb2YgdGhlIHN1YnNldCByZWNvZ25pemVkIGJ5IHRoaXMgbG9hZGVyLlxuICAgIGNvbnN0IGZ1bGxFeHRlbnRMb2FkU3BlYyA9IHtcbiAgICAgIC4uLmxvYWRTcGVjLFxuICAgICAgc3VicmVnaW9uOiBuZXcgQm94MyhuZXcgVmVjdG9yMygwLCAwLCAwKSwgbmV3IFZlY3RvcjMoMSwgMSwgMSkpXG4gICAgfTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIGltYWdlSW5mbzogaW1nZGF0YSxcbiAgICAgIGxvYWRTcGVjOiBmdWxsRXh0ZW50TG9hZFNwZWNcbiAgICB9KTtcbiAgfVxuICBhc3luYyBwcmVmZXRjaENodW5rKHNjYWxlTGV2ZWwsIGNvb3Jkcywgc3Vic2NyaWJlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0b3JlLFxuICAgICAgcGF0aFxuICAgIH0gPSBzY2FsZUxldmVsO1xuICAgIGNvbnN0IHNlcGFyYXRvciA9IHBhdGguZW5kc1dpdGgoXCIvXCIpID8gXCJcIiA6IFwiL1wiO1xuICAgIGNvbnN0IGtleSA9IHBhdGggKyBzZXBhcmF0b3IgKyB0aGlzLm9yZGVyQnlEaW1lbnNpb24oY29vcmRzKS5qb2luKFwiL1wiKTtcbiAgICAvLyBDYWxsaW5nIGBnZXRgIGFuZCBkb2luZyBub3RoaW5nIHdpdGggdGhlIHJlc3VsdCBzdGlsbCB0cmlnZ2VycyBhIGNhY2hlIGNoZWNrLCBmZXRjaCwgYW5kIGluc2VydGlvblxuICAgIGF3YWl0IHN0b3JlLmdldChrZXksIHtcbiAgICAgIHN1YnNjcmliZXIsXG4gICAgICBpc1ByZWZldGNoOiB0cnVlXG4gICAgfSkuY2F0Y2god3JhcFZvbHVtZUxvYWRFcnJvcihgVW5hYmxlIHRvIHByZWZldGNoIGNodW5rIHdpdGgga2V5ICR7a2V5fWAsIFZvbHVtZUxvYWRFcnJvclR5cGUuTE9BRF9EQVRBX0ZBSUxFRCwgQ0hVTktfUkVRVUVTVF9DQU5DRUxfUkVBU09OKSk7XG4gIH1cblxuICAvKiogUmVhZHMgYSBsaXN0IG9mIGNodW5rIGtleXMgcmVxdWVzdGVkIGJ5IGEgYGxvYWRWb2x1bWVEYXRhYCBjYWxsIGFuZCBzZXRzIHVwIGFwcHJvcHJpYXRlIHByZWZldGNoIHJlcXVlc3RzLiAqL1xuICBiZWdpblByZWZldGNoKGtleXMsIHNjYWxlTGV2ZWwpIHtcbiAgICAvLyBDb252ZXJ0IGtleXMgdG8gYXJyYXlzIG9mIGNvb3Jkc1xuICAgIGNvbnN0IGNodW5rQ29vcmRzID0ga2V5cy5tYXAoKHtcbiAgICAgIHNvdXJjZUlkeCxcbiAgICAgIGtleVxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IG51bURpbXMgPSBnZXREaW1lbnNpb25Db3VudCh0aGlzLnNvdXJjZXNbc291cmNlSWR4XS5heGVzVENaWVgpO1xuICAgICAgY29uc3QgY29vcmRzSW5EaW1lbnNpb25PcmRlciA9IGtleS50cmltKCkuc3BsaXQoXCIvXCIpLnNsaWNlKC1udW1EaW1zKS5maWx0ZXIocyA9PiBzICE9PSBcIlwiKS5tYXAocyA9PiBwYXJzZUludChzLCAxMCkpO1xuICAgICAgY29uc3Qgc291cmNlQ29vcmRzID0gdGhpcy5vcmRlckJ5VENaWVgoY29vcmRzSW5EaW1lbnNpb25PcmRlciwgMCwgc291cmNlSWR4KTtcbiAgICAgIC8vIENvbnZlcnQgc291cmNlIGNoYW5uZWwgaW5kZXggdG8gYWJzb2x1dGUgY2hhbm5lbCBpbmRleCBmb3IgYENodW5rUHJlZmV0Y2hJdGVyYXRvcmAncyBiZW5lZml0XG4gICAgICAvLyAod2UgbWF0Y2ggY2h1bmsgY29vcmRpbmF0ZXMgb3V0cHV0IGZyb20gYENodW5rUHJlZmV0Y2hJdGVyYXRvcmAgYmFjayB0byBzb3VyY2VzIGJlbG93KVxuICAgICAgc291cmNlQ29vcmRzWzFdICs9IHRoaXMuc291cmNlc1tzb3VyY2VJZHhdLmNoYW5uZWxPZmZzZXQ7XG4gICAgICByZXR1cm4gc291cmNlQ29vcmRzO1xuICAgIH0pO1xuXG4gICAgLy8gR2V0IG51bWJlciBvZiBjaHVua3MgcGVyIGRpbWVuc2lvbiBpbiBldmVyeSBzb3VyY2UgYXJyYXlcbiAgICBjb25zdCBjaHVua0RpbXNUQ1pZWCA9IHRoaXMuc291cmNlcy5tYXAoc3JjID0+IHtcbiAgICAgIGNvbnN0IGxldmVsID0gc3JjLnNjYWxlTGV2ZWxzW3NjYWxlTGV2ZWxdO1xuICAgICAgY29uc3QgY2h1bmtEaW1zVW5vcmRlcmVkID0gbGV2ZWwuc2hhcGUubWFwKChkaW0sIGlkeCkgPT4gTWF0aC5jZWlsKGRpbSAvIGxldmVsLmNodW5rc1tpZHhdKSk7XG4gICAgICByZXR1cm4gdGhpcy5vcmRlckJ5VENaWVgoY2h1bmtEaW1zVW5vcmRlcmVkLCAxKTtcbiAgICB9KTtcbiAgICAvLyBgQ2h1bmtQcmVmZXRjaEl0ZXJhdG9yYCB5aWVsZHMgY2h1bmsgY29vcmRpbmF0ZXMgaW4gb3JkZXIgb2Ygcm91Z2hseSBob3cgbGlrZWx5IHRoZXkgYXJlIHRvIGJlIGxvYWRlZCBuZXh0XG4gICAgY29uc3QgcHJlZmV0Y2hJdGVyYXRvciA9IG5ldyBDaHVua1ByZWZldGNoSXRlcmF0b3IoY2h1bmtDb29yZHMsIHRoaXMuZmV0Y2hPcHRpb25zLm1heFByZWZldGNoRGlzdGFuY2UsIGNodW5rRGltc1RDWllYLCB0aGlzLnByaW9yaXR5RGlyZWN0aW9ucyk7XG4gICAgY29uc3Qgc3Vic2NyaWJlciA9IHRoaXMucmVxdWVzdFF1ZXVlLmFkZFN1YnNjcmliZXIoKTtcbiAgICBsZXQgcHJlZmV0Y2hDb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBjaHVuayBvZiBwcmVmZXRjaEl0ZXJhdG9yKSB7XG4gICAgICBpZiAocHJlZmV0Y2hDb3VudCA+PSB0aGlzLmZldGNoT3B0aW9ucy5tYXhQcmVmZXRjaENodW5rcykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIE1hdGNoIGFic29sdXRlIGNoYW5uZWwgY29vcmRpbmF0ZSBiYWNrIHRvIHNvdXJjZSBpbmRleCBhbmQgY2hhbm5lbCBpbmRleFxuICAgICAgY29uc3Qge1xuICAgICAgICBzb3VyY2VJbmRleCxcbiAgICAgICAgY2hhbm5lbEluZGV4SW5Tb3VyY2VcbiAgICAgIH0gPSB0aGlzLm1hdGNoQ2hhbm5lbFRvU291cmNlKGNodW5rWzFdKTtcbiAgICAgIGNvbnN0IHNvdXJjZVNjYWxlTGV2ZWwgPSB0aGlzLnNvdXJjZXNbc291cmNlSW5kZXhdLnNjYWxlTGV2ZWxzW3NjYWxlTGV2ZWxdO1xuICAgICAgY2h1bmtbMV0gPSBjaGFubmVsSW5kZXhJblNvdXJjZTtcbiAgICAgIHRoaXMucHJlZmV0Y2hDaHVuayhzb3VyY2VTY2FsZUxldmVsLCBjaHVuaywgc3Vic2NyaWJlcik7XG4gICAgICBwcmVmZXRjaENvdW50Kys7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgb3V0IG9sZCBwcmVmZXRjaCByZXF1ZXN0cyAocmVxdWVzdHMgd2hpY2ggYWxzbyBjb3ZlciB0aGlzIG5ldyBwcmVmZXRjaCB3aWxsIGJlIHByZXNlcnZlZClcbiAgICBpZiAodGhpcy5wcmVmZXRjaFN1YnNjcmliZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5yZXF1ZXN0UXVldWUucmVtb3ZlU3Vic2NyaWJlcih0aGlzLnByZWZldGNoU3Vic2NyaWJlciwgQ0hVTktfUkVRVUVTVF9DQU5DRUxfUkVBU09OKTtcbiAgICB9XG4gICAgdGhpcy5wcmVmZXRjaFN1YnNjcmliZXIgPSBzdWJzY3JpYmVyO1xuICB9XG4gIHVwZGF0ZUltYWdlSW5mb0ZvckxvYWQoaW1hZ2VJbmZvLCBsb2FkU3BlYykge1xuICAgIC8vIEFwcGx5IGB0aGlzLm1heEV4dGVudGAgdG8gc3VicmVnaW9uLCBpZiBpdCBleGlzdHNcbiAgICBjb25zdCBtYXhFeHRlbnQgPSB0aGlzLm1heEV4dGVudCA/PyBuZXcgQm94MyhuZXcgVmVjdG9yMygwLCAwLCAwKSwgbmV3IFZlY3RvcjMoMSwgMSwgMSkpO1xuICAgIGNvbnN0IHN1YnJlZ2lvbiA9IGNvbXBvc2VTdWJyZWdpb24obG9hZFNwZWMuc3VicmVnaW9uLCBtYXhFeHRlbnQpO1xuXG4gICAgLy8gUGljayB0aGUgbGV2ZWwgdG8gbG9hZCBiYXNlZCBvbiB0aGUgc3VicmVnaW9uIHNpemVcbiAgICBjb25zdCBtdWx0aXNjYWxlTGV2ZWwgPSBwaWNrTGV2ZWxUb0xvYWQoe1xuICAgICAgLi4ubG9hZFNwZWMsXG4gICAgICBzdWJyZWdpb25cbiAgICB9LCB0aGlzLmdldExldmVsU2hhcGVzWllYKCkpO1xuICAgIGNvbnN0IGFycmF5MFNoYXBlID0gdGhpcy5zb3VyY2VzWzBdLnNjYWxlTGV2ZWxzW211bHRpc2NhbGVMZXZlbF0uc2hhcGU7XG5cbiAgICAvLyBDb252ZXJ0IHN1YnJlZ2lvbiB0byB2b2x1bWUgdm94ZWxzXG4gICAgY29uc3QgW3osIHksIHhdID0gdGhpcy5zb3VyY2VzWzBdLmF4ZXNUQ1pZWC5zbGljZSgyKTtcbiAgICBjb25zdCByZWdpb25QeCA9IGNvbnZlcnRTdWJyZWdpb25Ub1BpeGVscyhzdWJyZWdpb24sIG5ldyBWZWN0b3IzKGFycmF5MFNoYXBlW3hdLCBhcnJheTBTaGFwZVt5XSwgeiA9PT0gLTEgPyAxIDogYXJyYXkwU2hhcGVbel0pKTtcblxuICAgIC8vIERlcml2ZSBvdGhlciBpbWFnZSBpbmZvIHByb3BlcnRpZXMgZnJvbSBzdWJyZWdpb24gYW5kIGxldmVsIHRvIGxvYWRcbiAgICBjb25zdCBzdWJyZWdpb25TaXplID0gcmVnaW9uUHguZ2V0U2l6ZShuZXcgVmVjdG9yMygpKTtcbiAgICBjb25zdCBhdGxhc1RpbGVEaW1zID0gY29tcHV0ZVBhY2tlZEF0bGFzRGltcyhzdWJyZWdpb25TaXplLnosIHN1YnJlZ2lvblNpemUueCwgc3VicmVnaW9uU2l6ZS55KTtcbiAgICBjb25zdCB2b2x1bWVFeHRlbnQgPSBjb252ZXJ0U3VicmVnaW9uVG9QaXhlbHMobWF4RXh0ZW50LCBuZXcgVmVjdG9yMyhhcnJheTBTaGFwZVt4XSwgYXJyYXkwU2hhcGVbeV0sIHogPT09IC0xID8gMSA6IGFycmF5MFNoYXBlW3pdKSk7XG4gICAgY29uc3Qgdm9sdW1lU2l6ZSA9IHZvbHVtZUV4dGVudC5nZXRTaXplKG5ldyBWZWN0b3IzKCkpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5pbWFnZUluZm8sXG4gICAgICBhdGxhc1RpbGVEaW1zLFxuICAgICAgdm9sdW1lU2l6ZSxcbiAgICAgIHN1YnJlZ2lvblNpemUsXG4gICAgICBzdWJyZWdpb25PZmZzZXQ6IHJlZ2lvblB4Lm1pbixcbiAgICAgIG11bHRpc2NhbGVMZXZlbFxuICAgIH07XG4gIH1cbiAgYXN5bmMgbG9hZFJhd0NoYW5uZWxEYXRhKGltYWdlSW5mbywgbG9hZFNwZWMsIG9uVXBkYXRlTWV0YWRhdGEsIG9uRGF0YSkge1xuICAgIC8vIFRoaXMgc2VlbWluZ2x5IHVzZWxlc3MgbGluZSBrZWVwcyBhIHN0YWJsZSBsb2NhbCBjb3B5IG9mIGBzeW5jQ2hhbm5lbHNgIHdoaWNoIHRoZSBhc3luYyBjbG9zdXJlcyBiZWxvdyBjYXB0dXJlXG4gICAgLy8gc28gdGhhdCBjaGFuZ2VzIHRvIGB0aGlzLnN5bmNDaGFubmVsc2AgZG9uJ3QgYWZmZWN0IHRoZSBiZWhhdmlvciBvZiBsb2FkcyBpbiBwcm9ncmVzcy5cbiAgICBjb25zdCBzeW5jQ2hhbm5lbHMgPSB0aGlzLnN5bmNDaGFubmVscztcbiAgICBjb25zdCB1cGRhdGVkSW1hZ2VJbmZvID0gdGhpcy51cGRhdGVJbWFnZUluZm9Gb3JMb2FkKGltYWdlSW5mbywgbG9hZFNwZWMpO1xuICAgIG9uVXBkYXRlTWV0YWRhdGEodXBkYXRlZEltYWdlSW5mbyk7XG4gICAgY29uc3Qge1xuICAgICAgbnVtQ2hhbm5lbHMsXG4gICAgICBtdWx0aXNjYWxlTGV2ZWxcbiAgICB9ID0gdXBkYXRlZEltYWdlSW5mbztcbiAgICBjb25zdCBjaGFubmVsSW5kZXhlcyA9IGxvYWRTcGVjLmNoYW5uZWxzID8/IEFycmF5LmZyb20oe1xuICAgICAgbGVuZ3RoOiBudW1DaGFubmVsc1xuICAgIH0sIChfLCBpKSA9PiBpKTtcbiAgICBjb25zdCBzdWJzY3JpYmVyID0gdGhpcy5yZXF1ZXN0UXVldWUuYWRkU3Vic2NyaWJlcigpO1xuXG4gICAgLy8gUHJlZmV0Y2ggaG91c2VrZWVwaW5nOiB3ZSB3YW50IHRvIHNhdmUga2V5cyBpbnZvbHZlZCBpbiB0aGlzIGxvYWQgdG8gcHJlZmV0Y2ggbGF0ZXJcbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgY29uc3QgcmVwb3J0S2V5QmFzZSA9IChzb3VyY2VJZHgsIGtleSwgc3ViKSA9PiB7XG4gICAgICBpZiAoc3ViID09PSBzdWJzY3JpYmVyKSB7XG4gICAgICAgIGtleXMucHVzaCh7XG4gICAgICAgICAgc291cmNlSWR4LFxuICAgICAgICAgIGtleVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdENoYW5uZWxJbmRpY2VzID0gW107XG4gICAgY29uc3QgcmVzdWx0Q2hhbm5lbERhdGEgPSBbXTtcbiAgICBjb25zdCByZXN1bHRDaGFubmVsUmFuZ2VzID0gW107XG4gICAgY29uc3QgY2hhbm5lbFByb21pc2VzID0gY2hhbm5lbEluZGV4ZXMubWFwKGFzeW5jIGNoID0+IHtcbiAgICAgIC8vIEJ1aWxkIHNsaWNlIHNwZWNcbiAgICAgIGNvbnN0IG1pbiA9IHVwZGF0ZWRJbWFnZUluZm8uc3VicmVnaW9uT2Zmc2V0O1xuICAgICAgY29uc3QgbWF4ID0gbWluLmNsb25lKCkuYWRkKHVwZGF0ZWRJbWFnZUluZm8uc3VicmVnaW9uU2l6ZSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNvdXJjZUluZGV4OiBzb3VyY2VJZHgsXG4gICAgICAgIGNoYW5uZWxJbmRleEluU291cmNlOiBzb3VyY2VDaFxuICAgICAgfSA9IHRoaXMubWF0Y2hDaGFubmVsVG9Tb3VyY2UoY2gpO1xuICAgICAgY29uc3QgdW5vcmRlcmVkU3BlYyA9IFtsb2FkU3BlYy50aW1lLCBzb3VyY2VDaCwgc2xpY2UobWluLnosIG1heC56KSwgc2xpY2UobWluLnksIG1heC55KSwgc2xpY2UobWluLngsIG1heC54KV07XG4gICAgICBjb25zdCBsZXZlbCA9IHRoaXMuc291cmNlc1tzb3VyY2VJZHhdLnNjYWxlTGV2ZWxzW211bHRpc2NhbGVMZXZlbF07XG4gICAgICBjb25zdCBzbGljZVNwZWMgPSB0aGlzLm9yZGVyQnlEaW1lbnNpb24odW5vcmRlcmVkU3BlYywgc291cmNlSWR4KTtcbiAgICAgIGNvbnN0IHJlcG9ydEtleSA9IChrZXksIHN1YikgPT4gcmVwb3J0S2V5QmFzZShzb3VyY2VJZHgsIGtleSwgc3ViKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHphcnJHZXQobGV2ZWwsIHNsaWNlU3BlYywge1xuICAgICAgICBvcHRzOiB7XG4gICAgICAgICAgc3Vic2NyaWJlcixcbiAgICAgICAgICByZXBvcnRLZXlcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2god3JhcFZvbHVtZUxvYWRFcnJvcihcIkNvdWxkIG5vdCBsb2FkIE9NRS1aYXJyIHZvbHVtZSBkYXRhXCIsIFZvbHVtZUxvYWRFcnJvclR5cGUuTE9BRF9EQVRBX0ZBSUxFRCwgQ0hVTktfUkVRVUVTVF9DQU5DRUxfUkVBU09OKSk7XG4gICAgICBpZiAocmVzdWx0Py5kYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udmVydGVkID0gY29udmVydENoYW5uZWwocmVzdWx0LmRhdGEpO1xuICAgICAgaWYgKHN5bmNDaGFubmVscykge1xuICAgICAgICByZXN1bHRDaGFubmVsRGF0YS5wdXNoKGNvbnZlcnRlZFswXSk7XG4gICAgICAgIHJlc3VsdENoYW5uZWxJbmRpY2VzLnB1c2goY2gpO1xuICAgICAgICByZXN1bHRDaGFubmVsUmFuZ2VzLnB1c2goW2NvbnZlcnRlZFsxXSwgY29udmVydGVkWzJdXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbkRhdGEoW2NoXSwgW2NvbnZlcnRlZFswXV0sIFtbY29udmVydGVkWzFdLCBjb252ZXJ0ZWRbMl1dXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDYW5jZWwgYW55IGluLWZsaWdodCByZXF1ZXN0cyBmcm9tIHByZXZpb3VzIGxvYWRzIHRoYXQgYXJlbid0IHVzZWZ1bCB0byB0aGlzIG9uZVxuICAgIGlmICh0aGlzLmxvYWRTdWJzY3JpYmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLnJlbW92ZVN1YnNjcmliZXIodGhpcy5sb2FkU3Vic2NyaWJlciwgQ0hVTktfUkVRVUVTVF9DQU5DRUxfUkVBU09OKTtcbiAgICB9XG4gICAgdGhpcy5sb2FkU3Vic2NyaWJlciA9IHN1YnNjcmliZXI7XG4gICAgdGhpcy5iZWdpblByZWZldGNoKGtleXMsIG11bHRpc2NhbGVMZXZlbCk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoY2hhbm5lbFByb21pc2VzKTtcbiAgICBpZiAoc3luY0NoYW5uZWxzKSB7XG4gICAgICBvbkRhdGEocmVzdWx0Q2hhbm5lbEluZGljZXMsIHJlc3VsdENoYW5uZWxEYXRhLCByZXN1bHRDaGFubmVsUmFuZ2VzKTtcbiAgICB9XG4gICAgdGhpcy5yZXF1ZXN0UXVldWUucmVtb3ZlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBDSFVOS19SRVFVRVNUX0NBTkNFTF9SRUFTT04pO1xuICB9XG59XG5leHBvcnQgeyBPTUVaYXJyTG9hZGVyIH07Il0sIm5hbWVzIjpbIkJveDMiLCJWZWN0b3IzIiwiemFyciIsImdldCIsInphcnJHZXQiLCJzbGljZSIsIkZldGNoU3RvcmUiLCJTdWJzY3JpYmFibGVSZXF1ZXN0UXVldWUiLCJUaHJlYWRhYmxlVm9sdW1lTG9hZGVyIiwiVm9sdW1lRGltcyIsImNvbXBvc2VTdWJyZWdpb24iLCJjb21wdXRlUGFja2VkQXRsYXNEaW1zIiwiY29udmVydFN1YnJlZ2lvblRvUGl4ZWxzIiwicGlja0xldmVsVG9Mb2FkIiwidW5pdE5hbWVUb1N5bWJvbCIsIkNodW5rUHJlZmV0Y2hJdGVyYXRvciIsIldyYXBwZWRTdG9yZSIsImdldERpbWVuc2lvbkNvdW50IiwiZ2V0U2NhbGUiLCJnZXRTb3VyY2VDaGFubmVsTmFtZXMiLCJtYXRjaFNvdXJjZVNjYWxlTGV2ZWxzIiwib3JkZXJCeURpbWVuc2lvbiIsIm9yZGVyQnlUQ1pZWCIsInJlbWFwQXhlc1RvVENaWVgiLCJWb2x1bWVMb2FkRXJyb3IiLCJWb2x1bWVMb2FkRXJyb3JUeXBlIiwid3JhcFZvbHVtZUxvYWRFcnJvciIsInZhbGlkYXRlT01FWmFyck1ldGFkYXRhIiwiQ0hVTktfUkVRVUVTVF9DQU5DRUxfUkVBU09OIiwiY29udmVydENoYW5uZWwiLCJjaGFubmVsRGF0YSIsIm1pbiIsIm1heCIsImkiLCJsZW5ndGgiLCJ2YWwiLCJVaW50OEFycmF5IiwidTgiLCJyYW5nZSIsIkRFRkFVTFRfRkVUQ0hfT1BUSU9OUyIsIm1heFByZWZldGNoRGlzdGFuY2UiLCJtYXhQcmVmZXRjaENodW5rcyIsIk9NRVphcnJMb2FkZXIiLCJzeW5jQ2hhbm5lbHMiLCJjb25zdHJ1Y3RvciIsInNvdXJjZXMiLCJyZXF1ZXN0UXVldWUiLCJmZXRjaE9wdGlvbnMiLCJwcmlvcml0eURpcmVjdGlvbnMiLCJjcmVhdGVMb2FkZXIiLCJ1cmxzIiwic2NlbmVzIiwiY2FjaGUiLCJxdWV1ZSIsImNvbmN1cnJlbmN5TGltaXQiLCJwcmVmZXRjaENvbmN1cnJlbmN5TGltaXQiLCJ1cmxzQXJyIiwiQXJyYXkiLCJpc0FycmF5Iiwic2NlbmVzQXJyIiwic291cmNlUHJvbXMiLCJtYXAiLCJ1cmwiLCJzdG9yZSIsInJvb3QiLCJncm91cCIsIm9wZW4iLCJraW5kIiwiY2F0Y2giLCJOT1RfRk9VTkQiLCJzY2VuZSIsIk1hdGgiLCJhdHRycyIsIm11bHRpc2NhbGVzIiwiY29uc29sZSIsIndhcm4iLCJvbWVybyIsIm11bHRpc2NhbGVNZXRhZGF0YSIsImx2bFByb21zIiwiZGF0YXNldHMiLCJwYXRoIiwicmVzb2x2ZSIsInNjYWxlTGV2ZWxzIiwiUHJvbWlzZSIsImFsbCIsImF4ZXNUQ1pZWCIsImF4ZXMiLCJvbWVyb01ldGFkYXRhIiwiY2hhbm5lbE9mZnNldCIsImNoYW5uZWxDb3VudCIsInMiLCJjaGFubmVscyIsInNoYXBlIiwicHJpb3JpdHlEaXJzIiwidW5kZWZpbmVkIiwiZ2V0VW5pdFN5bWJvbHMiLCJzb3VyY2UiLCJ4aSIsInNwYWNlVW5pdE5hbWUiLCJ1bml0Iiwic3BhY2VVbml0U3ltYm9sIiwidGkiLCJ0aW1lVW5pdE5hbWUiLCJ0aW1lVW5pdFN5bWJvbCIsImdldExldmVsU2hhcGVzWllYIiwieiIsInkiLCJ4IiwibGV2ZWwiLCJ2YWxzVENaWVgiLCJzb3VyY2VJZHgiLCJ2YWxzRGltZW5zaW9uIiwiZGVmYXVsdFZhbHVlIiwibWF0Y2hDaGFubmVsVG9Tb3VyY2UiLCJhYnNvbHV0ZUNoYW5uZWxJbmRleCIsImxhc3RTcmNJZHgiLCJsYXN0U3JjIiwibGFzdFNyY051bUNoYW5uZWxzIiwibWF4Q2hhbm5lbEluZGV4IiwidHlwZSIsIklOVkFMSURfTUVUQURBVEEiLCJmaXJzdEdyZWF0ZXJJZHgiLCJmaW5kSW5kZXgiLCJzcmMiLCJzb3VyY2VJbmRleCIsImNoYW5uZWxJbmRleEluU291cmNlIiwic2V0UHJlZmV0Y2hQcmlvcml0eSIsImRpcmVjdGlvbnMiLCJzeW5jTXVsdGljaGFubmVsTG9hZGluZyIsInN5bmMiLCJsb2FkRGltcyIsImxvYWRTcGVjIiwic3BhY2VVbml0IiwidGltZVVuaXQiLCJtYXhFeHRlbnQiLCJzdWJyZWdpb24iLCJyZWdpb25TaXplIiwiZ2V0U2l6ZSIsInJlZ2lvbkFyciIsInJlc3VsdCIsInNjYWxlIiwiZGltcyIsImlkeCIsImNlaWwiLCJzcGFjaW5nIiwiY3JlYXRlSW1hZ2VJbmZvIiwic291cmNlMCIsInQiLCJoYXNUIiwiaGFzWiIsInNoYXBlMCIsImxldmVsVG9Mb2FkIiwic2hhcGVMdiIsInNwYXRpYWxVbml0Iiwic291cmNlTGFzdCIsImNMYXN0IiwibGFzdEhhc0MiLCJudW1DaGFubmVscyIsInRpbWVzIiwidGluZGV4IiwiY2xvbmUiLCJweERpbXMwIiwicHhTaXplMCIsInB4RGltc0x2IiwicHhTaXplTHYiLCJhdGxhc1RpbGVEaW1zIiwiY2hhbm5lbE5hbWVzTWFwIiwiTWFwIiwiY2hhbm5lbE5hbWVzIiwiZmxhdE1hcCIsInNvdXJjZUNoYW5uZWxOYW1lcyIsImNoYW5uZWxOYW1lIiwibnVtTWF0Y2hpbmdDaGFubmVscyIsInNldCIsInNjYWxlNWQiLCJ0aW1lU2NhbGUiLCJpbWdkYXRhIiwibmFtZSIsIm9yaWdpbmFsU2l6ZSIsInZvbHVtZVNpemUiLCJzdWJyZWdpb25TaXplIiwic3VicmVnaW9uT2Zmc2V0IiwicGh5c2ljYWxQaXhlbFNpemUiLCJudW1NdWx0aXNjYWxlTGV2ZWxzIiwibXVsdGlzY2FsZUxldmVsIiwidHJhbnNmb3JtIiwidHJhbnNsYXRpb24iLCJyb3RhdGlvbiIsImZ1bGxFeHRlbnRMb2FkU3BlYyIsImltYWdlSW5mbyIsInByZWZldGNoQ2h1bmsiLCJzY2FsZUxldmVsIiwiY29vcmRzIiwic3Vic2NyaWJlciIsInNlcGFyYXRvciIsImVuZHNXaXRoIiwia2V5Iiwiam9pbiIsImlzUHJlZmV0Y2giLCJMT0FEX0RBVEFfRkFJTEVEIiwiYmVnaW5QcmVmZXRjaCIsImtleXMiLCJjaHVua0Nvb3JkcyIsIm51bURpbXMiLCJjb29yZHNJbkRpbWVuc2lvbk9yZGVyIiwidHJpbSIsInNwbGl0IiwiZmlsdGVyIiwicGFyc2VJbnQiLCJzb3VyY2VDb29yZHMiLCJjaHVua0RpbXNUQ1pZWCIsImNodW5rRGltc1Vub3JkZXJlZCIsImRpbSIsImNodW5rcyIsInByZWZldGNoSXRlcmF0b3IiLCJhZGRTdWJzY3JpYmVyIiwicHJlZmV0Y2hDb3VudCIsImNodW5rIiwic291cmNlU2NhbGVMZXZlbCIsInByZWZldGNoU3Vic2NyaWJlciIsInJlbW92ZVN1YnNjcmliZXIiLCJ1cGRhdGVJbWFnZUluZm9Gb3JMb2FkIiwiYXJyYXkwU2hhcGUiLCJyZWdpb25QeCIsInZvbHVtZUV4dGVudCIsImxvYWRSYXdDaGFubmVsRGF0YSIsIm9uVXBkYXRlTWV0YWRhdGEiLCJvbkRhdGEiLCJ1cGRhdGVkSW1hZ2VJbmZvIiwiY2hhbm5lbEluZGV4ZXMiLCJmcm9tIiwiXyIsInJlcG9ydEtleUJhc2UiLCJzdWIiLCJwdXNoIiwicmVzdWx0Q2hhbm5lbEluZGljZXMiLCJyZXN1bHRDaGFubmVsRGF0YSIsInJlc3VsdENoYW5uZWxSYW5nZXMiLCJjaGFubmVsUHJvbWlzZXMiLCJjaCIsImFkZCIsInNvdXJjZUNoIiwidW5vcmRlcmVkU3BlYyIsInRpbWUiLCJzbGljZVNwZWMiLCJyZXBvcnRLZXkiLCJvcHRzIiwiZGF0YSIsImNvbnZlcnRlZCIsImxvYWRTdWJzY3JpYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../volume-viewer/es/loaders/OmeZarrLoader.js\n");

/***/ }),

/***/ "../volume-viewer/es/loaders/RawArrayLoader.js":
/*!*****************************************************!*\
  !*** ../volume-viewer/es/loaders/RawArrayLoader.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RawArrayLoader: () => (/* binding */ RawArrayLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"../volume-viewer/node_modules/three/build/three.module.js\");\n/* harmony import */ var _IVolumeLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IVolumeLoader.js */ \"../volume-viewer/es/loaders/IVolumeLoader.js\");\n/* harmony import */ var _VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VolumeLoaderUtils.js */ \"../volume-viewer/es/loaders/VolumeLoaderUtils.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../types.js */ \"../volume-viewer/es/types.js\");\n\n\n\n\n\n// this is the form in which a 4D numpy array arrives as converted\n// by jupyterlab into a js object.\n// This loader does not yet support multiple time samples.\n\n// minimal metadata for visualization\n\nconst convertImageInfo = json => ({\n  name: json.name,\n  // assumption: the data is already sized to fit in our viewer's preferred\n  // memory footprint (a tiled atlas texture as of this writing)\n  originalSize: new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(json.sizeX, json.sizeY, json.sizeZ),\n  atlasTileDims: (0,_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.computePackedAtlasDims)(json.sizeZ, json.sizeX, json.sizeY),\n  volumeSize: new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(json.sizeX, json.sizeY, json.sizeZ),\n  subregionSize: new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(json.sizeX, json.sizeY, json.sizeZ),\n  subregionOffset: new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0),\n  physicalPixelSize: new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(json.physicalPixelSize[0], json.physicalPixelSize[1], json.physicalPixelSize[2]),\n  spatialUnit: json.spatialUnit || \"m\",\n  numChannels: json.sizeC,\n  channelNames: json.channelNames,\n  channelColors: undefined,\n  //json.channelColors,\n\n  times: 1,\n  timeScale: 1,\n  timeUnit: \"s\",\n  numMultiscaleLevels: 1,\n  multiscaleLevel: 0,\n  transform: {\n    translation: new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0),\n    rotation: new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0)\n  },\n  userData: json.userData\n});\nclass RawArrayLoader extends _IVolumeLoader_js__WEBPACK_IMPORTED_MODULE_0__.ThreadableVolumeLoader {\n  constructor(rawData, rawDataInfo) {\n    super();\n    this.jsonInfo = rawDataInfo;\n    this.data = rawData;\n    // check consistent dims\n    if (this.data.shape[0] !== this.jsonInfo.sizeC || this.data.shape[1] !== this.jsonInfo.sizeZ || this.data.shape[2] !== this.jsonInfo.sizeY || this.data.shape[3] !== this.jsonInfo.sizeX) {\n      throw new Error(\"RawArrayLoader: data shape does not match metadata\");\n    }\n  }\n  async loadDims(_loadSpec) {\n    const jsonInfo = this.jsonInfo;\n    const d = new _IVolumeLoader_js__WEBPACK_IMPORTED_MODULE_0__.VolumeDims();\n    d.shape = [1, jsonInfo.sizeC, jsonInfo.sizeZ, jsonInfo.sizeY, jsonInfo.sizeX];\n    d.spacing = [1, 1, jsonInfo.physicalPixelSize[2], jsonInfo.physicalPixelSize[1], jsonInfo.physicalPixelSize[0]];\n    d.spaceUnit = jsonInfo.spatialUnit || \"m\";\n    d.dataType = \"uint8\";\n    return [d];\n  }\n  async createImageInfo(loadSpec) {\n    return {\n      imageInfo: convertImageInfo(this.jsonInfo),\n      loadSpec\n    };\n  }\n  loadRawChannelData(imageInfo, loadSpec, onUpdateMetadata, onData) {\n    const requestedChannels = loadSpec.channels;\n    const adjustedLoadSpec = {\n      ...loadSpec,\n      // `subregion` and `multiscaleLevel` are unused by this loader\n      subregion: new three__WEBPACK_IMPORTED_MODULE_3__.Box3(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(1, 1, 1)),\n      multiscaleLevel: 0\n    };\n    onUpdateMetadata(undefined, adjustedLoadSpec);\n    for (let chindex = 0; chindex < imageInfo.numChannels; ++chindex) {\n      if (requestedChannels && requestedChannels.length > 0 && !requestedChannels.includes(chindex)) {\n        continue;\n      }\n      const volSizeBytes = this.data.shape[3] * this.data.shape[2] * this.data.shape[1]; // x*y*z pixels * 1 byte/pixel\n      const channelData = new Uint8Array(this.data.buffer.buffer, chindex * volSizeBytes, volSizeBytes);\n      // all data coming from this loader is natively 8-bit\n      onData([chindex], [channelData], [_types_js__WEBPACK_IMPORTED_MODULE_2__.DATARANGE_UINT8]);\n    }\n    return Promise.resolve();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL1Jhd0FycmF5TG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNDO0FBQ2tDO0FBQ1I7QUFDbEI7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNTSxnQkFBZ0IsR0FBR0MsSUFBSSxLQUFLO0VBQ2hDQyxJQUFJLEVBQUVELElBQUksQ0FBQ0MsSUFBSTtFQUNmO0VBQ0E7RUFDQUMsWUFBWSxFQUFFLElBQUlSLDBDQUFPLENBQUNNLElBQUksQ0FBQ0csS0FBSyxFQUFFSCxJQUFJLENBQUNJLEtBQUssRUFBRUosSUFBSSxDQUFDSyxLQUFLLENBQUM7RUFDN0RDLGFBQWEsRUFBRVQsNkVBQXNCLENBQUNHLElBQUksQ0FBQ0ssS0FBSyxFQUFFTCxJQUFJLENBQUNHLEtBQUssRUFBRUgsSUFBSSxDQUFDSSxLQUFLLENBQUM7RUFDekVHLFVBQVUsRUFBRSxJQUFJYiwwQ0FBTyxDQUFDTSxJQUFJLENBQUNHLEtBQUssRUFBRUgsSUFBSSxDQUFDSSxLQUFLLEVBQUVKLElBQUksQ0FBQ0ssS0FBSyxDQUFDO0VBQzNERyxhQUFhLEVBQUUsSUFBSWQsMENBQU8sQ0FBQ00sSUFBSSxDQUFDRyxLQUFLLEVBQUVILElBQUksQ0FBQ0ksS0FBSyxFQUFFSixJQUFJLENBQUNLLEtBQUssQ0FBQztFQUM5REksZUFBZSxFQUFFLElBQUlmLDBDQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDckNnQixpQkFBaUIsRUFBRSxJQUFJaEIsMENBQU8sQ0FBQ00sSUFBSSxDQUFDVSxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsRUFBRVYsSUFBSSxDQUFDVSxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsRUFBRVYsSUFBSSxDQUFDVSxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUMvR0MsV0FBVyxFQUFFWCxJQUFJLENBQUNXLFdBQVcsSUFBSSxJQUFJO0VBQ3JDQyxXQUFXLEVBQUVaLElBQUksQ0FBQ2Es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QUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSUEsMENBQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO01BQy9EMkIsZUFBZSxFQUFFO0lBQ25CLENBQUM7SUFDRHVCLGdCQUFnQixDQUFDNUIsU0FBUyxFQUFFZ0MsZ0JBQWdCLENBQUM7SUFDN0MsS0FBSyxJQUFJRSxPQUFPLEdBQUcsQ0FBQyxFQUFFQSxPQUFPLEdBQUdSLFNBQVMsQ0FBQzlCLFdBQVcsRUFBRSxFQUFFc0MsT0FBTyxFQUFFO01BQ2hFLElBQUlKLGlCQUFpQixJQUFJQSxpQkFBaUIsQ0FBQ0ssTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDTCxpQkFBaUIsQ0FBQ00sUUFBUSxDQUFDRixPQUFPLENBQUMsRUFBRTtRQUM3RjtNQUNGO01BQ0EsTUFBTUcsWUFBWSxHQUFHLElBQUksQ0FBQ3RCLElBQUksQ0FBQ0MsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQ0QsSUFBSSxDQUFDQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDRCxJQUFJLENBQUNDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQ25GLE1BQU1zQixXQUFXLEdBQUcsSUFBSUMsVUFBVSxDQUFDLElBQUksQ0FBQ3hCLElBQUksQ0FBQ3lCLE1BQU0sQ0FBQ0EsTUFBTSxFQUFFTixPQUFPLEdBQUdHLFlBQVksRUFBRUEsWUFBWSxDQUFDO01BQ2pHO01BQ0FSLE1BQU0sQ0FBQyxDQUFDSyxPQUFPLENBQUMsRUFBRSxDQUFDSSxXQUFXLENBQUMsRUFBRSxDQUFDeEQsc0RBQWUsQ0FBQyxDQUFDO0lBQ3JEO0lBQ0EsT0FBTzJELE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLENBQUM7RUFDMUI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL1Jhd0FycmF5TG9hZGVyLmpzPzVkZjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQm94MywgVmVjdG9yMyB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgVGhyZWFkYWJsZVZvbHVtZUxvYWRlciwgVm9sdW1lRGltcyB9IGZyb20gXCIuL0lWb2x1bWVMb2FkZXIuanNcIjtcbmltcG9ydCB7IGNvbXB1dGVQYWNrZWRBdGxhc0RpbXMgfSBmcm9tIFwiLi9Wb2x1bWVMb2FkZXJVdGlscy5qc1wiO1xuaW1wb3J0IHsgREFUQVJBTkdFX1VJTlQ4IH0gZnJvbSBcIi4uL3R5cGVzLmpzXCI7XG5cbi8vIHRoaXMgaXMgdGhlIGZvcm0gaW4gd2hpY2ggYSA0RCBudW1weSBhcnJheSBhcnJpdmVzIGFzIGNvbnZlcnRlZFxuLy8gYnkganVweXRlcmxhYiBpbnRvIGEganMgb2JqZWN0LlxuLy8gVGhpcyBsb2FkZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgbXVsdGlwbGUgdGltZSBzYW1wbGVzLlxuXG4vLyBtaW5pbWFsIG1ldGFkYXRhIGZvciB2aXN1YWxpemF0aW9uXG5cbmNvbnN0IGNvbnZlcnRJbWFnZUluZm8gPSBqc29uID0+ICh7XG4gIG5hbWU6IGpzb24ubmFtZSxcbiAgLy8gYXNzdW1wdGlvbjogdGhlIGRhdGEgaXMgYWxyZWFkeSBzaXplZCB0byBmaXQgaW4gb3VyIHZpZXdlcidzIHByZWZlcnJlZFxuICAvLyBtZW1vcnkgZm9vdHByaW50IChhIHRpbGVkIGF0bGFzIHRleHR1cmUgYXMgb2YgdGhpcyB3cml0aW5nKVxuICBvcmlnaW5hbFNpemU6IG5ldyBWZWN0b3IzKGpzb24uc2l6ZVgsIGpzb24uc2l6ZVksIGpzb24uc2l6ZVopLFxuICBhdGxhc1RpbGVEaW1zOiBjb21wdXRlUGFja2VkQXRsYXNEaW1zKGpzb24uc2l6ZVosIGpzb24uc2l6ZVgsIGpzb24uc2l6ZVkpLFxuICB2b2x1bWVTaXplOiBuZXcgVmVjdG9yMyhqc29uLnNpemVYLCBqc29uLnNpemVZLCBqc29uLnNpemVaKSxcbiAgc3VicmVnaW9uU2l6ZTogbmV3IFZlY3RvcjMoanNvbi5zaXplWCwganNvbi5zaXplWSwganNvbi5zaXplWiksXG4gIHN1YnJlZ2lvbk9mZnNldDogbmV3IFZlY3RvcjMoMCwgMCwgMCksXG4gIHBoeXNpY2FsUGl4ZWxTaXplOiBuZXcgVmVjdG9yMyhqc29uLnBoeXNpY2FsUGl4ZWxTaXplWzBdLCBqc29uLnBoeXNpY2FsUGl4ZWxTaXplWzFdLCBqc29uLnBoeXNpY2FsUGl4ZWxTaXplWzJdKSxcbiAgc3BhdGlhbFVuaXQ6IGpzb24uc3BhdGlhbFVuaXQgfHwgXCLOvG1cIixcbiAgbnVtQ2hhbm5lbHM6IGpzb24uc2l6ZUMsXG4gIGNoYW5uZWxOYW1lczoganNvbi5jaGFubmVsTmFtZXMsXG4gIGNoYW5uZWxDb2xvcnM6IHVuZGVmaW5lZCxcbiAgLy9qc29uLmNoYW5uZWxDb2xvcnMsXG5cbiAgdGltZXM6IDEsXG4gIHRpbWVTY2FsZTogMSxcbiAgdGltZVVuaXQ6IFwic1wiLFxuICBudW1NdWx0aXNjYWxlTGV2ZWxzOiAxLFxuICBtdWx0aXNjYWxlTGV2ZWw6IDAsXG4gIHRyYW5zZm9ybToge1xuICAgIHRyYW5zbGF0aW9uOiBuZXcgVmVjdG9yMygwLCAwLCAwKSxcbiAgICByb3RhdGlvbjogbmV3IFZlY3RvcjMoMCwgMCwgMClcbiAgfSxcbiAgdXNlckRhdGE6IGpzb24udXNlckRhdGFcbn0pO1xuY2xhc3MgUmF3QXJyYXlMb2FkZXIgZXh0ZW5kcyBUaHJlYWRhYmxlVm9sdW1lTG9hZGVyIHtcbiAgY29uc3RydWN0b3IocmF3RGF0YSwgcmF3RGF0YUluZm8pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuanNvbkluZm8gPSByYXdEYXRhSW5mbztcbiAgICB0aGlzLmRhdGEgPSByYXdEYXRhO1xuICAgIC8vIGNoZWNrIGNvbnNpc3RlbnQgZGltc1xuICAgIGlmICh0aGlzLmRhdGEuc2hhcGVbMF0gIT09IHRoaXMuanNvbkluZm8uc2l6ZUMgfHwgdGhpcy5kYXRhLnNoYXBlWzFdICE9PSB0aGlzLmpzb25JbmZvLnNpemVaIHx8IHRoaXMuZGF0YS5zaGFwZVsyXSAhPT0gdGhpcy5qc29uSW5mby5zaXplWSB8fCB0aGlzLmRhdGEuc2hhcGVbM10gIT09IHRoaXMuanNvbkluZm8uc2l6ZVgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhd0FycmF5TG9hZGVyOiBkYXRhIHNoYXBlIGRvZXMgbm90IG1hdGNoIG1ldGFkYXRhXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyBsb2FkRGltcyhfbG9hZFNwZWMpIHtcbiAgICBjb25zdCBqc29uSW5mbyA9IHRoaXMuanNvbkluZm87XG4gICAgY29uc3QgZCA9IG5ldyBWb2x1bWVEaW1zKCk7XG4gICAgZC5zaGFwZSA9IFsxLCBqc29uSW5mby5zaXplQywganNvbkluZm8uc2l6ZVosIGpzb25JbmZvLnNpemVZLCBqc29uSW5mby5zaXplWF07XG4gICAgZC5zcGFjaW5nID0gWzEsIDEsIGpzb25JbmZvLnBoeXNpY2FsUGl4ZWxTaXplWzJdLCBqc29uSW5mby5waHlzaWNhbFBpeGVsU2l6ZVsxXSwganNvbkluZm8ucGh5c2ljYWxQaXhlbFNpemVbMF1dO1xuICAgIGQuc3BhY2VVbml0ID0ganNvbkluZm8uc3BhdGlhbFVuaXQgfHwgXCLOvG1cIjtcbiAgICBkLmRhdGFUeXBlID0gXCJ1aW50OFwiO1xuICAgIHJldHVybiBbZF07XG4gIH1cbiAgYXN5bmMgY3JlYXRlSW1hZ2VJbmZvKGxvYWRTcGVjKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGltYWdlSW5mbzogY29udmVydEltYWdlSW5mbyh0aGlzLmpzb25JbmZvKSxcbiAgICAgIGxvYWRTcGVjXG4gICAgfTtcbiAgfVxuICBsb2FkUmF3Q2hhbm5lbERhdGEoaW1hZ2VJbmZvLCBsb2FkU3BlYywgb25VcGRhdGVNZXRhZGF0YSwgb25EYXRhKSB7XG4gICAgY29uc3QgcmVxdWVzdGVkQ2hhbm5lbHMgPSBsb2FkU3BlYy5jaGFubmVscztcbiAgICBjb25zdCBhZGp1c3RlZExvYWRTcGVjID0ge1xuICAgICAgLi4ubG9hZFNwZWMsXG4gICAgICAvLyBgc3VicmVnaW9uYCBhbmQgYG11bHRpc2NhbGVMZXZlbGAgYXJlIHVudXNlZCBieSB0aGlzIGxvYWRlclxuICAgICAgc3VicmVnaW9uOiBuZXcgQm94MyhuZXcgVmVjdG9yMygwLCAwLCAwKSwgbmV3IFZlY3RvcjMoMSwgMSwgMSkpLFxuICAgICAgbXVsdGlzY2FsZUxldmVsOiAwXG4gICAgfTtcbiAgICBvblVwZGF0ZU1ldGFkYXRhKHVuZGVmaW5lZCwgYWRqdXN0ZWRMb2FkU3BlYyk7XG4gICAgZm9yIChsZXQgY2hpbmRleCA9IDA7IGNoaW5kZXggPCBpbWFnZUluZm8ubnVtQ2hhbm5lbHM7ICsrY2hpbmRleCkge1xuICAgICAgaWYgKHJlcXVlc3RlZENoYW5uZWxzICYmIHJlcXVlc3RlZENoYW5uZWxzLmxlbmd0aCA+IDAgJiYgIXJlcXVlc3RlZENoYW5uZWxzLmluY2x1ZGVzKGNoaW5kZXgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgdm9sU2l6ZUJ5dGVzID0gdGhpcy5kYXRhLnNoYXBlWzNdICogdGhpcy5kYXRhLnNoYXBlWzJdICogdGhpcy5kYXRhLnNoYXBlWzFdOyAvLyB4KnkqeiBwaXhlbHMgKiAxIGJ5dGUvcGl4ZWxcbiAgICAgIGNvbnN0IGNoYW5uZWxEYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlci5idWZmZXIsIGNoaW5kZXggKiB2b2xTaXplQnl0ZXMsIHZvbFNpemVCeXRlcyk7XG4gICAgICAvLyBhbGwgZGF0YSBjb21pbmcgZnJvbSB0aGlzIGxvYWRlciBpcyBuYXRpdmVseSA4LWJpdFxuICAgICAgb25EYXRhKFtjaGluZGV4XSwgW2NoYW5uZWxEYXRhXSwgW0RBVEFSQU5HRV9VSU5UOF0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbmV4cG9ydCB7IFJhd0FycmF5TG9hZGVyIH07Il0sIm5hbWVzIjpbIkJveDMiLCJWZWN0b3IzIiwiVGhyZWFkYWJsZVZvbHVtZUxvYWRlciIsIlZvbHVtZURpbXMiLCJjb21wdXRlUGFja2VkQXRsYXNEaW1zIiwiREFUQVJBTkdFX1VJTlQ4IiwiY29udmVydEltYWdlSW5mbyIsImpzb24iLCJuYW1lIiwib3JpZ2luYWxTaXplIiwic2l6ZVgiLCJzaXplWSIsInNpemVaIiwiYXRsYXNUaWxlRGltcyIsInZvbHVtZVNpemUiLCJzdWJyZWdpb25TaXplIiwic3VicmVnaW9uT2Zmc2V0IiwicGh5c2ljYWxQaXhlbFNpemUiLCJzcGF0aWFsVW5pdCIsIm51bUNoYW5uZWxzIiwic2l6ZUMiLCJjaGFubmVsTmFtZXMiLCJjaGFubmVsQ29sb3JzIiwidW5kZWZpbmVkIiwidGltZXMiLCJ0aW1lU2NhbGUiLCJ0aW1lVW5pdCIsIm51bU11bHRpc2NhbGVMZXZlbHMiLCJtdWx0aXNjYWxlTGV2ZWwiLCJ0cmFuc2Zvcm0iLCJ0cmFuc2xhdGlvbiIsInJvdGF0aW9uIiwidXNlckRhdGEiLCJSYXdBcnJheUxvYWRlciIsImNvbnN0cnVjdG9yIiwicmF3RGF0YSIsInJhd0RhdGFJbmZvIiwianNvbkluZm8iLCJkYXRhIiwic2hhcGUiLCJFcnJvciIsImxvYWREaW1zIiwiX2xvYWRTcGVjIiwiZCIsInNwYWNpbmciLCJzcGFjZVVuaXQiLCJkYXRhVHlwZSIsImNyZWF0ZUltYWdlSW5mbyIsImxvYWRTcGVjIiwiaW1hZ2VJbmZvIiwibG9hZFJhd0NoYW5uZWxEYXRhIiwib25VcGRhdGVNZXRhZGF0YSIsIm9uRGF0YSIsInJlcXVlc3RlZENoYW5uZWxzIiwiY2hhbm5lbHMiLCJhZGp1c3RlZExvYWRTcGVjIiwic3VicmVnaW9uIiwiY2hpbmRleCIsImxlbmd0aCIsImluY2x1ZGVzIiwidm9sU2l6ZUJ5dGVzIiwiY2hhbm5lbERhdGEiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwiUHJvbWlzZSIsInJlc29sdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../volume-viewer/es/loaders/RawArrayLoader.js\n");

/***/ }),

/***/ "../volume-viewer/es/loaders/TiffLoader.js":
/*!*************************************************!*\
  !*** ../volume-viewer/es/loaders/TiffLoader.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TiffLoader: () => (/* binding */ TiffLoader)\n/* harmony export */ });\n/* harmony import */ var geotiff__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! geotiff */ \"../volume-viewer/node_modules/geotiff/dist-module/geotiff.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"../volume-viewer/node_modules/three/build/three.module.js\");\n/* harmony import */ var serialize_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! serialize-error */ \"../volume-viewer/node_modules/serialize-error/index.js\");\n/* harmony import */ var _IVolumeLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IVolumeLoader.js */ \"../volume-viewer/es/loaders/IVolumeLoader.js\");\n/* harmony import */ var _VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VolumeLoaderUtils.js */ \"../volume-viewer/es/loaders/VolumeLoaderUtils.js\");\n/* harmony import */ var _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VolumeLoadError.js */ \"../volume-viewer/es/loaders/VolumeLoadError.js\");\n\n\n\n\n\n\nfunction prepareXML(xml) {\n  // trim trailing unicode zeros?\n  // eslint-disable-next-line no-control-regex\n  const expr = /[\\u0000]$/g;\n  return xml.trim().replace(expr, \"\").trim();\n}\nfunction getOME(xml) {\n  const parser = new DOMParser();\n  try {\n    const xmlDoc = parser.parseFromString(xml, \"text/xml\");\n    return xmlDoc.getElementsByTagName(\"OME\")[0];\n  } catch (e) {\n    throw new _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_2__.VolumeLoadError(\"Could not find OME metadata in TIFF file\", {\n      type: _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_2__.VolumeLoadErrorType.INVALID_METADATA,\n      cause: e\n    });\n  }\n}\nclass OMEDims {\n  sizex = 0;\n  sizey = 0;\n  sizez = 1;\n  sizec = 1;\n  sizet = 1;\n  unit = \"\";\n  pixeltype = \"\";\n  dimensionorder = \"\";\n  pixelsizex = 1;\n  pixelsizey = 1;\n  pixelsizez = 1;\n  channelnames = [];\n}\nfunction getAttributeOrError(el, attr) {\n  const val = el.getAttribute(attr);\n  if (val === null) {\n    throw new _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_2__.VolumeLoadError(`Missing attribute ${attr} in OME-TIFF metadata`, {\n      type: _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_2__.VolumeLoadErrorType.INVALID_METADATA\n    });\n  }\n  return val;\n}\nfunction getOMEDims(imageEl) {\n  const dims = new OMEDims();\n  const pixelsEl = imageEl.getElementsByTagName(\"Pixels\")[0];\n  dims.sizex = Number(getAttributeOrError(pixelsEl, \"SizeX\"));\n  dims.sizey = Number(getAttributeOrError(pixelsEl, \"SizeY\"));\n  dims.sizez = Number(pixelsEl.getAttribute(\"SizeZ\"));\n  dims.sizec = Number(pixelsEl.getAttribute(\"SizeC\"));\n  dims.sizet = Number(pixelsEl.getAttribute(\"SizeT\"));\n  dims.unit = pixelsEl.getAttribute(\"PhysicalSizeXUnit\") || \"\";\n  dims.pixeltype = pixelsEl.getAttribute(\"Type\") || \"\";\n  dims.dimensionorder = pixelsEl.getAttribute(\"DimensionOrder\") || \"XYZCT\";\n  dims.pixelsizex = Number(pixelsEl.getAttribute(\"PhysicalSizeX\"));\n  dims.pixelsizey = Number(pixelsEl.getAttribute(\"PhysicalSizeY\"));\n  dims.pixelsizez = Number(pixelsEl.getAttribute(\"PhysicalSizeZ\"));\n  const channelsEls = pixelsEl.getElementsByTagName(\"Channel\");\n  for (let i = 0; i < channelsEls.length; ++i) {\n    const name = channelsEls[i].getAttribute(\"Name\");\n    const id = channelsEls[i].getAttribute(\"ID\");\n    dims.channelnames.push(name ? name : id ? id : \"Channel\" + i);\n  }\n  return dims;\n}\nconst getBytesPerSample = type => type === \"uint8\" ? 1 : type === \"uint16\" ? 2 : 4;\n\n// Despite the class `TiffLoader` extends, this loader is not threadable, since geotiff internally uses features that\n// aren't available on workers. It uses its own specialized workers anyways.\nclass TiffLoader extends _IVolumeLoader_js__WEBPACK_IMPORTED_MODULE_0__.ThreadableVolumeLoader {\n  constructor(url) {\n    super();\n    this.url = url;\n  }\n  async loadOmeDims() {\n    if (!this.dims) {\n      const tiff = await (0,geotiff__WEBPACK_IMPORTED_MODULE_3__.fromUrl)(this.url, {\n        allowFullFile: true\n      }).catch((0,_VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_2__.wrapVolumeLoadError)(`Could not open TIFF file at ${this.url}`, _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_2__.VolumeLoadErrorType.NOT_FOUND));\n      // DO NOT DO THIS, ITS SLOW\n      // const imagecount = await tiff.getImageCount();\n      // read the FIRST image\n      const image = await tiff.getImage().catch((0,_VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_2__.wrapVolumeLoadError)(\"Failed to open TIFF image\", _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_2__.VolumeLoadErrorType.NOT_FOUND));\n      const tiffimgdesc = prepareXML(image.getFileDirectory().ImageDescription);\n      const omeEl = getOME(tiffimgdesc);\n      const image0El = omeEl.getElementsByTagName(\"Image\")[0];\n      this.dims = getOMEDims(image0El);\n    }\n    return this.dims;\n  }\n  async loadDims(_loadSpec) {\n    const dims = await this.loadOmeDims();\n    const d = new _IVolumeLoader_js__WEBPACK_IMPORTED_MODULE_0__.VolumeDims();\n    d.shape = [dims.sizet, dims.sizec, dims.sizez, dims.sizey, dims.sizex];\n    d.spacing = [1, 1, dims.pixelsizez, dims.pixelsizey, dims.pixelsizex];\n    d.spaceUnit = dims.unit ? dims.unit : \"micron\";\n    d.dataType = dims.pixeltype ? dims.pixeltype : \"uint8\";\n    return [d];\n  }\n  async createImageInfo(_loadSpec) {\n    const dims = await this.loadOmeDims();\n    // compare with sizex, sizey\n    //const width = image.getWidth();\n    //const height = image.getHeight();\n\n    // TODO allow user setting of this downsampling info?\n    // TODO allow ROI selection: range of x,y,z,c for a given t\n    const atlasDims = (0,_VolumeLoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.computePackedAtlasDims)(dims.sizez, dims.sizex, dims.sizey);\n    // fit tiles to max of 2048x2048?\n    const targetSize = 2048;\n    const tilesizex = Math.floor(targetSize / atlasDims.x);\n    const tilesizey = Math.floor(targetSize / atlasDims.y);\n\n    // load tiff and check metadata\n\n    const imgdata = {\n      name: \"TEST\",\n      originalSize: new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(dims.sizex, dims.sizey, dims.sizez),\n      atlasTileDims: atlasDims,\n      volumeSize: new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(tilesizex, tilesizey, dims.sizez),\n      subregionSize: new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(tilesizex, tilesizey, dims.sizez),\n      subregionOffset: new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0),\n      physicalPixelSize: new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(dims.pixelsizex, dims.pixelsizey, dims.pixelsizez),\n      spatialUnit: dims.unit || \"\",\n      numChannels: dims.sizec,\n      channelNames: dims.channelnames,\n      times: dims.sizet,\n      timeScale: 1,\n      timeUnit: \"\",\n      numMultiscaleLevels: 1,\n      multiscaleLevel: 0,\n      transform: {\n        translation: new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0),\n        rotation: new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0)\n      }\n    };\n\n    // This loader uses no fields from `LoadSpec`. Initialize volume with defaults.\n    return {\n      imageInfo: imgdata,\n      loadSpec: new _IVolumeLoader_js__WEBPACK_IMPORTED_MODULE_0__.LoadSpec()\n    };\n  }\n  async loadRawChannelData(imageInfo, _loadSpec, _onUpdateMetadata, onData) {\n    const dims = await this.loadOmeDims();\n    const channelProms = [];\n    // do each channel on a worker?\n    for (let channel = 0; channel < imageInfo.numChannels; ++channel) {\n      const thisChannelProm = new Promise((resolve, reject) => {\n        const params = {\n          channel: channel,\n          // these are target xy sizes for the in-memory volume data\n          // they may or may not be the same size as original xy sizes\n          tilesizex: imageInfo.volumeSize.x,\n          tilesizey: imageInfo.volumeSize.y,\n          sizec: imageInfo.numChannels,\n          sizez: imageInfo.volumeSize.z,\n          dimensionOrder: dims.dimensionorder,\n          bytesPerSample: getBytesPerSample(dims.pixeltype),\n          url: this.url\n        };\n        const worker = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"volume-viewer_es_workers_FetchTiffWorker_js\"), __webpack_require__.b));\n        worker.onmessage = e => {\n          if (e.data.isError) {\n            reject((0,serialize_error__WEBPACK_IMPORTED_MODULE_5__.deserializeError)(e.data.error));\n            return;\n          }\n          const {\n            data,\n            channel,\n            range\n          } = e.data;\n          onData([channel], [data], [range]);\n          worker.terminate();\n          resolve();\n        };\n        worker.postMessage(params);\n      });\n      channelProms.push(thisChannelProm);\n    }\n\n    // waiting for all channels to load allows errors to propagate to the caller via this promise\n    await Promise.all(channelProms);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL1RpZmZMb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFrQztBQUNGO0FBQ21CO0FBQytCO0FBQ2xCO0FBQ2lDO0FBQ2pHLFNBQVNVLFVBQVVBLENBQUNDLEdBQUcsRUFBRTtFQUN2QjtFQUNBO0VBQ0EsTUFBTUMsSUFBSSxHQUFHLFlBQVk7RUFDekIsT0FBT0QsR0FBRyxDQUFDRSxJQUFJLENBQUMsQ0FBQyxDQUFDQyxPQUFPLENBQUNGLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQ0MsSUFBSSxDQUFDLENBQUM7QUFDNUM7QUFDQSxTQUFTRSxNQUFNQSxDQUFDSixHQUFHLEVBQUU7RUFDbkIsTUFBTUssTUFBTSxHQUFHLElBQUlDLFNBQVMsQ0FBQyxDQUFDO0VBQzlCLElBQUk7SUFDRixNQUFNQyxNQUFNLEdBQUdGLE1BQU0sQ0FBQ0csZUFBZSxDQUFDUixHQUFHLEVBQUUsVUFBVSxDQUFDO0lBQ3RELE9BQU9PLE1BQU0sQ0FBQ0Usb0JBQW9CLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQzlDLENBQUMsQ0FBQyxPQUFPQyxDQUFDLEVBQUU7SUFDVixNQUFNLElBQUlkLGdFQUFlLENBQUMsMENBQTBDLEVBQUU7TUFDcEVlLElBQUksRUFBRWQsb0VBQW1CLENBQUNlLGdCQUFnQjtNQUMxQ0MsS0FBSyxFQUFFSDtJQUNULENBQUMsQ0FBQztFQUNKO0FBQ0Y7QUFDQSxNQUFNSSxPQUFPLENBQUM7RUFDWkMsS0FBSyxHQUFHLENBQUM7RUFDVEMsS0FBSyxHQUFHLENBQUM7RUFDVEMsS0FBSyxHQUFHLENBQUM7RUFDVEMsS0FBSyxHQUFHLENBQUM7RUFDVEMsS0FBSyxHQUFHLENBQUM7RUFDVEMsSUFBSSxHQUFHLEVBQUU7RUFDVEMsU0FBUyxHQUFHLEVBQUU7RUFDZEMsY0FBYyxHQUFHLEVBQUU7RUFDbkJDLFVBQVUsR0FBRyxDQUFDO0VBQ2RDLFVBQVUsR0FBRyxDQUFDO0VBQ2RDLFVBQVUsR0FBRyxDQUFDO0VBQ2RDLFlBQVksR0FBRyxFQUFFO0FBQ25CO0FBQ0EsU0FBU0MsbUJBQW1CQSxDQUFDQyxFQUFFLEVBQUVDLElBQUksRUFBRTtFQUNyQyxNQUFNQyxHQUFHLEdBQUdGLEVBQUUsQ0FBQ0csWUFBWSxDQUFDRixJQUFJLENBQUM7RUFDakMsSUFBSUMsR0FBRyxLQUFLLElBQUksRUFBRTtJQUNoQixNQUFNLElBQUlsQyxnRUFBZSxDQUFFLHFCQUFvQmlDLElBQUssdUJBQXNCLEVBQUU7TUFDMUVsQixJQUFJLEVBQUVkLG9FQUFtQixDQUFDZTtJQUM1QixDQUFDLENBQUM7RUFDSjtFQUNBLE9BQU9rQixHQUFHO0FBQ1o7QUFDQSxTQUFTRSxVQUFVQSxDQUFDQyxPQUFPLEVBQUU7RUFDM0IsTUFBTUMsSUFBSSxHQUFHLElBQUlwQixPQUFPLENBQUMsQ0FBQztFQUMxQixNQUFNcUIsUUFBUSxHQUFHRixPQUFPLENBQUN4QixvQkFBb0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDMUR5QixJQUFJLENBQUNuQixLQUFLLEdBQUdxQixNQUFNLENBQUNULG1CQUFtQixDQUFDUSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7RUFDM0RELElBQUksQ0FBQ2xCLEtBQUssR0FBR29CLE1BQU0sQ0FBQ1QsbUJBQW1CLENBQUNRLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztFQUMzREQsSUFBSSxDQUFDakIsS0FBSyxHQUFHbUIsTUFBTSxDQUFDRCxRQUFRLENBQUNKLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztFQUNuREcsSUFBSSxDQUFDaEIsS0FBSyxHQUFHa0IsTUFBTSxDQUFDRCxRQUFRLENBQUNKLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztFQUNuREcsSUFBSSxDQUFDZixLQUFLLEdBQUdpQixNQUFNLENBQUNELFFBQVEsQ0FBQ0osWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0VBQ25ERyxJQUFJLENBQUNkLElBQUksR0FBR2UsUUFBUSxDQUFDSixZQUFZLENBQUMsbUJBQW1CLENBQUMsSUFBSSxFQUFFO0VBQzVERyxJQUFJLENBQUNiLFNBQVMsR0FBR2MsUUFBUSxDQUFDSixZQUFZLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRTtFQUNwREcsSUFBSSxDQUFDWixjQUFjLEdBQUdhLFFBQVEsQ0FBQ0osWUFBWSxDQUFDLGdCQUFnQixDQUFDLElBQUksT0FBTztFQUN4RUcsSUFBSSxDQUFDWCxVQUFVLEdBQUdhLE1BQU0sQ0FBQ0QsUUFBUSxDQUFDSixZQUFZLENBQUMsZUFBZSxDQUFDLENBQUM7RUFDaEVHLElBQUksQ0FBQ1YsVUFBVSxHQUFHWSxNQUFNLENBQUNELFFBQVEsQ0FBQ0osWUFBWSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0VBQ2hFRyxJQUFJLENBQUNULFVBQVUsR0FBR1csTUFBTSxDQUFDRCxRQUFRLENBQUNKLFlBQVksQ0FBQyxlQUFlLENBQUMsQ0FBQztFQUNoRSxNQUFNTSxXQUFXLEdBQUdGLFFBQVEsQ0FBQzFCLG9CQUFvQixDQUFDLFNBQVMsQ0FBQztFQUM1RCxLQUFLLElBQUk2QixDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdELFdBQVcsQ0FBQ0UsTUFBTSxFQUFFLEVBQUVELENBQUMsRUFBRTtJQUMzQyxNQUFNRSxJQUFJLEdBQUdILFdBQVcsQ0FBQ0MsQ0FBQyxDQUFDLENBQUNQLFlBQVksQ0FBQyxNQUFNLENBQUM7SUFDaEQsTUFBTVUsRUFBRSxHQUFHSixXQUFXLENBQUNDLENBQUMsQ0FBQyxDQUFDUCxZQUFZLENBQUMsSUFBSSxDQUFDO0lBQzVDRyxJQUFJLENBQUNSLFlBQVksQ0FBQ2dCLElBQUksQ0FBQ0YsSUFBSSxHQUFHQSxJQUFJLEdBQUdDLEVBQUUsR0FBR0EsRUFBRSxHQUFHLFNBQVMsR0FBR0gsQ0FBQyxDQUFDO0VBQy9EO0VBQ0EsT0FBT0osSUFBSTtBQUNiO0FBQ0EsTUFBTVMsaUJBQWlCLEdBQUdoQyxJQUFJLElBQUlBLElBQUksS0FBSyxPQUFPLEdBQUcsQ0FBQyxHQUFHQSxJQUFJLEtBQUssUUFBUSxHQUFHLENBQUMsR0FBRyxDQUFDOztBQUVsRjtBQUNBO0FBQ0EsTUFBTWlDLFVBQVUsU0FBU3BELHFFQUFzQixDQUFDO0VBQzlDcUQsV0FBV0EsQ0FBQ0MsR0FBRyxFQUFFO0lBQ2YsS0FBSyxDQUFDLENBQUM7SUFDUCxJQUFJLENBQUNBLEdBQUcsR0FBR0EsR0FBRztFQUNoQjtFQUNBLE1BQU1DLFdBQVdBLENBQUEsRUFBRztJQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDYixJQUFJLEVBQUU7TUFDZCxNQUFNYyxJQUFJLEdBQUcsTUFBTTNELGdEQUFPLENBQUMsSUFBSSxDQUFDeUQsR0FBRyxFQUFFO1FBQ25DRyxhQUFhLEVBQUU7TUFDakIsQ0FBQyxDQUFDLENBQUNDLEtBQUssQ0FBQ3BELHdFQUFtQixDQUFFLCtCQUE4QixJQUFJLENBQUNnRCxHQUFJLEVBQUMsRUFBRWpELG9FQUFtQixDQUFDc0QsU0FBUyxDQUFDLENBQUM7TUFDdkc7TUFDQTtNQUNBO01BQ0EsTUFBTUMsS0FBSyxHQUFHLE1BQU1KLElBQUksQ0FBQ0ssUUFBUSxDQUFDLENBQUMsQ0FBQ0gsS0FBSyxDQUFDcEQsd0VBQW1CLENBQUMsMkJBQTJCLEVBQUVELG9FQUFtQixDQUFDc0QsU0FBUyxDQUFDLENBQUM7TUFDMUgsTUFBTUcsV0FBVyxHQUFHdkQsVUFBVSxDQUFDcUQsS0FBSyxDQUFDRyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUNDLGdCQUFnQixDQUFDO01BQ3pFLE1BQU1DLEtBQUssR0FBR3JELE1BQU0sQ0FBQ2tELFdBQVcsQ0FBQztNQUNqQyxNQUFNSSxRQUFRLEdBQUdELEtBQUssQ0FBQ2hELG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztNQUN2RCxJQUFJLENBQUN5QixJQUFJLEdBQUdGLFVBQVUsQ0FBQzBCLFFBQVEsQ0FBQztJQUNsQztJQUNBLE9BQU8sSUFBSSxDQUFDeEIsSUFBSTtFQUNsQjtFQUNBLE1BQU15QixRQUFRQSxDQUFDQyxTQUFTLEVBQUU7SUFDeEIsTUFBTTFCLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQ2EsV0FBVyxDQUFDLENBQUM7SUFDckMsTUFBTWMsQ0FBQyxHQUFHLElBQUluRSx5REFBVSxDQUFDLENBQUM7SUFDMUJtRSxDQUFDLENBQUNDLEtBQUssR0FBRyxDQUFDNUIsSUFBSSxDQUFDZixLQUFLLEVBQUVlLElBQUksQ0FBQ2hCLEtBQUssRUFBRWdCLElBQUksQ0FBQ2pCLEtBQUssRUFBRWlCLElBQUksQ0FBQ2xCLEtBQUssRUFBRWtCLElBQUksQ0FBQ25CLEtBQUssQ0FBQztJQUN0RThDLENBQUMsQ0FBQ0UsT0FBTyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRTdCLElBQUksQ0FBQ1QsVUFBVSxFQUFFUyxJQUFJLENBQUNWLFVBQVUsRUFBRVUsSUFBSSxDQUFDWCxVQUFVLENBQUM7SUFDckVzQyxDQUFDLENBQUNHLFNBQVMsR0FBRzlCLElBQUksQ0FBQ2QsSUFBSSxHQUFHYyxJQUFJLENBQUNkLElBQUksR0FBRyxRQUFRO0lBQzlDeUMsQ0FBQyxDQUFDSSxRQUFRLEdBQUcvQixJQUFJLENBQUNiLFNBQVMsR0FBR2EsSUFBSSxDQUFDYixTQUFTLEdBQUcsT0FBTztJQUN0RCxPQUFPLENBQUN3QyxDQUFDLENBQUM7RUFDWjtFQUNBLE1BQU1LLGVBQWVBLENBQUNOLFNBQVMsRUFBRTtJQUMvQixNQUFNMUIsSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDYSxXQUFXLENBQUMsQ0FBQztJQUNyQztJQUNBO0lBQ0E7O0lBRUE7SUFDQTtJQUNBLE1BQU1vQixTQUFTLEdBQUd4RSw2RUFBc0IsQ0FBQ3VDLElBQUksQ0FBQ2pCLEtBQUssRUFBRWlCLElBQUksQ0FBQ25CLEtBQUssRUFBRW1CLElBQUksQ0FBQ2xCLEtBQUssQ0FBQztJQUM1RTtJQUNBLE1BQU1vRCxVQUFVLEdBQUcsSUFBSTtJQUN2QixNQUFNQyxTQUFTLEdBQUdDLElBQUksQ0FBQ0MsS0FBSyxDQUFDSCxVQUFVLEdBQUdELFNBQVMsQ0FBQ0ssQ0FBQyxDQUFDO0lBQ3RELE1BQU1DLFNBQVMsR0FBR0gsSUFBSSxDQUFDQyxLQUFLLENBQUNILFVBQVUsR0FBR0QsU0FBUyxDQUFDTyxDQUFDLENBQUM7O0lBRXREOztJQUVBLE1BQU1DLE9BQU8sR0FBRztNQUNkbkMsSUFBSSxFQUFFLE1BQU07TUFDWm9DLFlBQVksRUFBRSxJQUFJdEYsMENBQU8sQ0FBQzRDLElBQUksQ0FBQ25CLEtBQUssRUFBRW1CLElBQUksQ0FBQ2xCLEtBQUssRUFBRWtCLElBQUksQ0FBQ2pCLEtBQUssQ0FBQztNQUM3RDRELGFBQWEsRUFBRVYsU0FBUztNQUN4QlcsVUFBVSxFQUFFLElBQUl4RiwwQ0FBTyxDQUFDK0UsU0FBUyxFQUFFSSxTQUFTLEVBQUV2QyxJQUFJLENBQUNqQixLQUFLLENBQUM7TUFDekQ4RCxhQUFhLEVBQUUsSUFBSXpGLDBDQUFPLENBQUMrRSxTQUFTLEVBQUVJLFNBQVMsRUFBRXZDLElBQUksQ0FBQ2pCLEtBQUssQ0FBQztNQUM1RCtELGVBQWUsRUFBRSxJQUFJMUYsMENBQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztNQUNyQzJGLGlCQUFpQixFQUFFLElBQUkzRiwwQ0FBTyxDQUFDNEMsSUFBSSxDQUFDWCxVQUFVLEVBQUVXLElBQUksQ0FBQ1YsVUFBVSxFQUFFVSxJQUFJLENBQUNULFVBQVUsQ0FBQztNQUNqRnlELFdBQVcsRUFBRWhELElBQUksQ0FBQ2QsSUFBSSxJQUFJLEVBQUU7TUFDNUIrRCxXQUFXLEVBQUVqRCxJQUFJLENBQUNoQixLQUFLO01BQ3ZCa0UsWUFBWSxFQUFFbEQsSUFBSSxDQUFDUixZQUFZO01BQy9CMkQsS0FBSyxFQUFFbkQsSUFBSSxDQUFDZixLQUFLO01BQ2pCbUUsU0FBUyxFQUFFLENBQUM7TUFDWkMsUUFBUSxFQUFFLEVBQUU7TUFDWkMsbUJBQW1CLEVBQUUsQ0FBQztNQUN0QkMsZUFBZSxFQUFFLENBQUM7TUFDbEJDLFNBQVMsRUFBRTtRQUNUQyxXQUFXLEVBQUUsSUFBSXJHLDBDQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDakNzRyxRQUFRLEVBQUUsSUFBSXRHLDBDQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO01BQy9CO0lBQ0YsQ0FBQzs7SUFFRDtJQUNBLE9BQU87TUFDTHVHLFNBQVMsRUFBRWxCLE9BQU87TUFDbEJtQixRQUFRLEVBQUUsSUFBSXJHLHVEQUFRLENBQUM7SUFDekIsQ0FBQztFQUNIO0VBQ0EsTUFBTXNHLGtCQUFrQkEsQ0FBQ0YsU0FBUyxFQUFFakMsU0FBUyxFQUFFb0MsaUJBQWlCLEVBQUVDLE1BQU0sRUFBRTtJQUN4RSxNQUFNL0QsSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDYSxXQUFXLENBQUMsQ0FBQztJQUNyQyxNQUFNbUQsWUFBWSxHQUFHLEVBQUU7SUFDdkI7SUFDQSxLQUFLLElBQUlDLE9BQU8sR0FBRyxDQUFDLEVBQUVBLE9BQU8sR0FBR04sU0FBUyxDQUFDVixXQUFXLEVBQUUsRUFBRWdCLE9BQU8sRUFBRTtNQUNoRSxNQUFNQyxlQUFlLEdBQUcsSUFBSUMsT0FBTyxDQUFDLENBQUNDLE9BQU8sRUFBRUMsTUFBTSxLQUFLO1FBQ3ZELE1BQU1DLE1BQU0sR0FBRztVQUNiTCxPQUFPLEVBQUVBLE9BQU87VUFDaEI7VUFDQTtVQUNBOUIsU0FBUyxFQUFFd0IsU0FBUyxDQUFDZixVQUFVLENBQUNOLENBQUM7VUFDakNDLFNBQVMsRUFBRW9CLFNBQVMsQ0FBQ2YsVUFBVSxDQUFDSixDQUFDO1VBQ2pDeEQsS0FBSyxFQUFFMkUsU0FBUyxDQUFDVixXQUFXO1VBQzVCbEUsS0FBSyxFQUFFNEUsU0FBUyxDQUFDZixVQUFVLENBQUMyQixDQUFDO1VBQzdCQyxjQUFjLEVBQUV4RSxJQUFJLENBQUNaLGNBQWM7VUFDbkNxRixjQUFjLEVBQUVoRSxpQkFBaUIsQ0FBQ1QsSUFBSSxDQUFDYixTQUFTLENBQUM7VUFDakR5QixHQUFHLEVBQUUsSUFBSSxDQUFDQTtRQUNaLENBQUM7UUFDRCxNQUFNOEQsTUFBTSxHQUFHLElBQUlDLE1BQU0sQ0FBQyxJQUFJQyxHQUFHLENBQUMsdUlBQTZDLENBQUMsQ0FBQztRQUNqRkYsTUFBTSxDQUFDSyxTQUFTLEdBQUd2RyxDQUFDLElBQUk7VUFDdEIsSUFBSUEsQ0FBQyxDQUFDd0csSUFBSSxDQUFDQyxPQUFPLEVBQUU7WUFDbEJaLE1BQU0sQ0FBQ2hILGlFQUFnQixDQUFDbUIsQ0FBQyxDQUFDd0csSUFBSSxDQUFDRSxLQUFLLENBQUMsQ0FBQztZQUN0QztVQUNGO1VBQ0EsTUFBTTtZQUNKRixJQUFJO1lBQ0pmLE9BQU87WUFDUGtCO1VBQ0YsQ0FBQyxHQUFHM0csQ0FBQyxDQUFDd0csSUFBSTtVQUNWakIsTUFBTSxDQUFDLENBQUNFLE9BQU8sQ0FBQyxFQUFFLENBQUNlLElBQUksQ0FBQyxFQUFFLENBQUNHLEtBQUssQ0FBQyxDQUFDO1VBQ2xDVCxNQUFNLENBQUNVLFNBQVMsQ0FBQyxDQUFDO1VBQ2xCaEIsT0FBTyxDQUFDLENBQUM7UUFDWCxDQUFDO1FBQ0RNLE1BQU0sQ0FBQ1csV0FBVyxDQUFDZixNQUFNLENBQUM7TUFDNUIsQ0FBQyxDQUFDO01BQ0ZOLFlBQVksQ0FBQ3hELElBQUksQ0FBQzBELGVBQWUsQ0FBQztJQUNwQzs7SUFFQTtJQUNBLE1BQU1DLE9BQU8sQ0FBQ21CLEdBQUcsQ0FBQ3RCLFlBQVksQ0FBQztFQUNqQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uLi92b2x1bWUtdmlld2VyL2VzL2xvYWRlcnMvVGlmZkxvYWRlci5qcz9hNGE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZyb21VcmwgfSBmcm9tIFwiZ2VvdGlmZlwiO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgZGVzZXJpYWxpemVFcnJvciB9IGZyb20gXCJzZXJpYWxpemUtZXJyb3JcIjtcbmltcG9ydCB7IFRocmVhZGFibGVWb2x1bWVMb2FkZXIsIExvYWRTcGVjLCBWb2x1bWVEaW1zIH0gZnJvbSBcIi4vSVZvbHVtZUxvYWRlci5qc1wiO1xuaW1wb3J0IHsgY29tcHV0ZVBhY2tlZEF0bGFzRGltcyB9IGZyb20gXCIuL1ZvbHVtZUxvYWRlclV0aWxzLmpzXCI7XG5pbXBvcnQgeyBWb2x1bWVMb2FkRXJyb3IsIFZvbHVtZUxvYWRFcnJvclR5cGUsIHdyYXBWb2x1bWVMb2FkRXJyb3IgfSBmcm9tIFwiLi9Wb2x1bWVMb2FkRXJyb3IuanNcIjtcbmZ1bmN0aW9uIHByZXBhcmVYTUwoeG1sKSB7XG4gIC8vIHRyaW0gdHJhaWxpbmcgdW5pY29kZSB6ZXJvcz9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgY29uc3QgZXhwciA9IC9bXFx1MDAwMF0kL2c7XG4gIHJldHVybiB4bWwudHJpbSgpLnJlcGxhY2UoZXhwciwgXCJcIikudHJpbSgpO1xufVxuZnVuY3Rpb24gZ2V0T01FKHhtbCkge1xuICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gIHRyeSB7XG4gICAgY29uc3QgeG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWwsIFwidGV4dC94bWxcIik7XG4gICAgcmV0dXJuIHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcIk9NRVwiKVswXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBWb2x1bWVMb2FkRXJyb3IoXCJDb3VsZCBub3QgZmluZCBPTUUgbWV0YWRhdGEgaW4gVElGRiBmaWxlXCIsIHtcbiAgICAgIHR5cGU6IFZvbHVtZUxvYWRFcnJvclR5cGUuSU5WQUxJRF9NRVRBREFUQSxcbiAgICAgIGNhdXNlOiBlXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIE9NRURpbXMge1xuICBzaXpleCA9IDA7XG4gIHNpemV5ID0gMDtcbiAgc2l6ZXogPSAxO1xuICBzaXplYyA9IDE7XG4gIHNpemV0ID0gMTtcbiAgdW5pdCA9IFwiXCI7XG4gIHBpeGVsdHlwZSA9IFwiXCI7XG4gIGRpbWVuc2lvbm9yZGVyID0gXCJcIjtcbiAgcGl4ZWxzaXpleCA9IDE7XG4gIHBpeGVsc2l6ZXkgPSAxO1xuICBwaXhlbHNpemV6ID0gMTtcbiAgY2hhbm5lbG5hbWVzID0gW107XG59XG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVPckVycm9yKGVsLCBhdHRyKSB7XG4gIGNvbnN0IHZhbCA9IGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBWb2x1bWVMb2FkRXJyb3IoYE1pc3NpbmcgYXR0cmlidXRlICR7YXR0cn0gaW4gT01FLVRJRkYgbWV0YWRhdGFgLCB7XG4gICAgICB0eXBlOiBWb2x1bWVMb2FkRXJyb3JUeXBlLklOVkFMSURfTUVUQURBVEFcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gZ2V0T01FRGltcyhpbWFnZUVsKSB7XG4gIGNvbnN0IGRpbXMgPSBuZXcgT01FRGltcygpO1xuICBjb25zdCBwaXhlbHNFbCA9IGltYWdlRWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJQaXhlbHNcIilbMF07XG4gIGRpbXMuc2l6ZXggPSBOdW1iZXIoZ2V0QXR0cmlidXRlT3JFcnJvcihwaXhlbHNFbCwgXCJTaXplWFwiKSk7XG4gIGRpbXMuc2l6ZXkgPSBOdW1iZXIoZ2V0QXR0cmlidXRlT3JFcnJvcihwaXhlbHNFbCwgXCJTaXplWVwiKSk7XG4gIGRpbXMuc2l6ZXogPSBOdW1iZXIocGl4ZWxzRWwuZ2V0QXR0cmlidXRlKFwiU2l6ZVpcIikpO1xuICBkaW1zLnNpemVjID0gTnVtYmVyKHBpeGVsc0VsLmdldEF0dHJpYnV0ZShcIlNpemVDXCIpKTtcbiAgZGltcy5zaXpldCA9IE51bWJlcihwaXhlbHNFbC5nZXRBdHRyaWJ1dGUoXCJTaXplVFwiKSk7XG4gIGRpbXMudW5pdCA9IHBpeGVsc0VsLmdldEF0dHJpYnV0ZShcIlBoeXNpY2FsU2l6ZVhVbml0XCIpIHx8IFwiXCI7XG4gIGRpbXMucGl4ZWx0eXBlID0gcGl4ZWxzRWwuZ2V0QXR0cmlidXRlKFwiVHlwZVwiKSB8fCBcIlwiO1xuICBkaW1zLmRpbWVuc2lvbm9yZGVyID0gcGl4ZWxzRWwuZ2V0QXR0cmlidXRlKFwiRGltZW5zaW9uT3JkZXJcIikgfHwgXCJYWVpDVFwiO1xuICBkaW1zLnBpeGVsc2l6ZXggPSBOdW1iZXIocGl4ZWxzRWwuZ2V0QXR0cmlidXRlKFwiUGh5c2ljYWxTaXplWFwiKSk7XG4gIGRpbXMucGl4ZWxzaXpleSA9IE51bWJlcihwaXhlbHNFbC5nZXRBdHRyaWJ1dGUoXCJQaHlzaWNhbFNpemVZXCIpKTtcbiAgZGltcy5waXhlbHNpemV6ID0gTnVtYmVyKHBpeGVsc0VsLmdldEF0dHJpYnV0ZShcIlBoeXNpY2FsU2l6ZVpcIikpO1xuICBjb25zdCBjaGFubmVsc0VscyA9IHBpeGVsc0VsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiQ2hhbm5lbFwiKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFubmVsc0Vscy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IG5hbWUgPSBjaGFubmVsc0Vsc1tpXS5nZXRBdHRyaWJ1dGUoXCJOYW1lXCIpO1xuICAgIGNvbnN0IGlkID0gY2hhbm5lbHNFbHNbaV0uZ2V0QXR0cmlidXRlKFwiSURcIik7XG4gICAgZGltcy5jaGFubmVsbmFtZXMucHVzaChuYW1lID8gbmFtZSA6IGlkID8gaWQgOiBcIkNoYW5uZWxcIiArIGkpO1xuICB9XG4gIHJldHVybiBkaW1zO1xufVxuY29uc3QgZ2V0Qnl0ZXNQZXJTYW1wbGUgPSB0eXBlID0+IHR5cGUgPT09IFwidWludDhcIiA/IDEgOiB0eXBlID09PSBcInVpbnQxNlwiID8gMiA6IDQ7XG5cbi8vIERlc3BpdGUgdGhlIGNsYXNzIGBUaWZmTG9hZGVyYCBleHRlbmRzLCB0aGlzIGxvYWRlciBpcyBub3QgdGhyZWFkYWJsZSwgc2luY2UgZ2VvdGlmZiBpbnRlcm5hbGx5IHVzZXMgZmVhdHVyZXMgdGhhdFxuLy8gYXJlbid0IGF2YWlsYWJsZSBvbiB3b3JrZXJzLiBJdCB1c2VzIGl0cyBvd24gc3BlY2lhbGl6ZWQgd29ya2VycyBhbnl3YXlzLlxuY2xhc3MgVGlmZkxvYWRlciBleHRlbmRzIFRocmVhZGFibGVWb2x1bWVMb2FkZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICB9XG4gIGFzeW5jIGxvYWRPbWVEaW1zKCkge1xuICAgIGlmICghdGhpcy5kaW1zKSB7XG4gICAgICBjb25zdCB0aWZmID0gYXdhaXQgZnJvbVVybCh0aGlzLnVybCwge1xuICAgICAgICBhbGxvd0Z1bGxGaWxlOiB0cnVlXG4gICAgICB9KS5jYXRjaCh3cmFwVm9sdW1lTG9hZEVycm9yKGBDb3VsZCBub3Qgb3BlbiBUSUZGIGZpbGUgYXQgJHt0aGlzLnVybH1gLCBWb2x1bWVMb2FkRXJyb3JUeXBlLk5PVF9GT1VORCkpO1xuICAgICAgLy8gRE8gTk9UIERPIFRISVMsIElUUyBTTE9XXG4gICAgICAvLyBjb25zdCBpbWFnZWNvdW50ID0gYXdhaXQgdGlmZi5nZXRJbWFnZUNvdW50KCk7XG4gICAgICAvLyByZWFkIHRoZSBGSVJTVCBpbWFnZVxuICAgICAgY29uc3QgaW1hZ2UgPSBhd2FpdCB0aWZmLmdldEltYWdlKCkuY2F0Y2god3JhcFZvbHVtZUxvYWRFcnJvcihcIkZhaWxlZCB0byBvcGVuIFRJRkYgaW1hZ2VcIiwgVm9sdW1lTG9hZEVycm9yVHlwZS5OT1RfRk9VTkQpKTtcbiAgICAgIGNvbnN0IHRpZmZpbWdkZXNjID0gcHJlcGFyZVhNTChpbWFnZS5nZXRGaWxlRGlyZWN0b3J5KCkuSW1hZ2VEZXNjcmlwdGlvbik7XG4gICAgICBjb25zdCBvbWVFbCA9IGdldE9NRSh0aWZmaW1nZGVzYyk7XG4gICAgICBjb25zdCBpbWFnZTBFbCA9IG9tZUVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiSW1hZ2VcIilbMF07XG4gICAgICB0aGlzLmRpbXMgPSBnZXRPTUVEaW1zKGltYWdlMEVsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGltcztcbiAgfVxuICBhc3luYyBsb2FkRGltcyhfbG9hZFNwZWMpIHtcbiAgICBjb25zdCBkaW1zID0gYXdhaXQgdGhpcy5sb2FkT21lRGltcygpO1xuICAgIGNvbnN0IGQgPSBuZXcgVm9sdW1lRGltcygpO1xuICAgIGQuc2hhcGUgPSBbZGltcy5zaXpldCwgZGltcy5zaXplYywgZGltcy5zaXpleiwgZGltcy5zaXpleSwgZGltcy5zaXpleF07XG4gICAgZC5zcGFjaW5nID0gWzEsIDEsIGRpbXMucGl4ZWxzaXpleiwgZGltcy5waXhlbHNpemV5LCBkaW1zLnBpeGVsc2l6ZXhdO1xuICAgIGQuc3BhY2VVbml0ID0gZGltcy51bml0ID8gZGltcy51bml0IDogXCJtaWNyb25cIjtcbiAgICBkLmRhdGFUeXBlID0gZGltcy5waXhlbHR5cGUgPyBkaW1zLnBpeGVsdHlwZSA6IFwidWludDhcIjtcbiAgICByZXR1cm4gW2RdO1xuICB9XG4gIGFzeW5jIGNyZWF0ZUltYWdlSW5mbyhfbG9hZFNwZWMpIHtcbiAgICBjb25zdCBkaW1zID0gYXdhaXQgdGhpcy5sb2FkT21lRGltcygpO1xuICAgIC8vIGNvbXBhcmUgd2l0aCBzaXpleCwgc2l6ZXlcbiAgICAvL2NvbnN0IHdpZHRoID0gaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICAvL2NvbnN0IGhlaWdodCA9IGltYWdlLmdldEhlaWdodCgpO1xuXG4gICAgLy8gVE9ETyBhbGxvdyB1c2VyIHNldHRpbmcgb2YgdGhpcyBkb3duc2FtcGxpbmcgaW5mbz9cbiAgICAvLyBUT0RPIGFsbG93IFJPSSBzZWxlY3Rpb246IHJhbmdlIG9mIHgseSx6LGMgZm9yIGEgZ2l2ZW4gdFxuICAgIGNvbnN0IGF0bGFzRGltcyA9IGNvbXB1dGVQYWNrZWRBdGxhc0RpbXMoZGltcy5zaXpleiwgZGltcy5zaXpleCwgZGltcy5zaXpleSk7XG4gICAgLy8gZml0IHRpbGVzIHRvIG1heCBvZiAyMDQ4eDIwNDg/XG4gICAgY29uc3QgdGFyZ2V0U2l6ZSA9IDIwNDg7XG4gICAgY29uc3QgdGlsZXNpemV4ID0gTWF0aC5mbG9vcih0YXJnZXRTaXplIC8gYXRsYXNEaW1zLngpO1xuICAgIGNvbnN0IHRpbGVzaXpleSA9IE1hdGguZmxvb3IodGFyZ2V0U2l6ZSAvIGF0bGFzRGltcy55KTtcblxuICAgIC8vIGxvYWQgdGlmZiBhbmQgY2hlY2sgbWV0YWRhdGFcblxuICAgIGNvbnN0IGltZ2RhdGEgPSB7XG4gICAgICBuYW1lOiBcIlRFU1RcIixcbiAgICAgIG9yaWdpbmFsU2l6ZTogbmV3IFZlY3RvcjMoZGltcy5zaXpleCwgZGltcy5zaXpleSwgZGltcy5zaXpleiksXG4gICAgICBhdGxhc1RpbGVEaW1zOiBhdGxhc0RpbXMsXG4gICAgICB2b2x1bWVTaXplOiBuZXcgVmVjdG9yMyh0aWxlc2l6ZXgsIHRpbGVzaXpleSwgZGltcy5zaXpleiksXG4gICAgICBzdWJyZWdpb25TaXplOiBuZXcgVmVjdG9yMyh0aWxlc2l6ZXgsIHRpbGVzaXpleSwgZGltcy5zaXpleiksXG4gICAgICBzdWJyZWdpb25PZmZzZXQ6IG5ldyBWZWN0b3IzKDAsIDAsIDApLFxuICAgICAgcGh5c2ljYWxQaXhlbFNpemU6IG5ldyBWZWN0b3IzKGRpbXMucGl4ZWxzaXpleCwgZGltcy5waXhlbHNpemV5LCBkaW1zLnBpeGVsc2l6ZXopLFxuICAgICAgc3BhdGlhbFVuaXQ6IGRpbXMudW5pdCB8fCBcIlwiLFxuICAgICAgbnVtQ2hhbm5lbHM6IGRpbXMuc2l6ZWMsXG4gICAgICBjaGFubmVsTmFtZXM6IGRpbXMuY2hhbm5lbG5hbWVzLFxuICAgICAgdGltZXM6IGRpbXMuc2l6ZXQsXG4gICAgICB0aW1lU2NhbGU6IDEsXG4gICAgICB0aW1lVW5pdDogXCJcIixcbiAgICAgIG51bU11bHRpc2NhbGVMZXZlbHM6IDEsXG4gICAgICBtdWx0aXNjYWxlTGV2ZWw6IDAsXG4gICAgICB0cmFuc2Zvcm06IHtcbiAgICAgICAgdHJhbnNsYXRpb246IG5ldyBWZWN0b3IzKDAsIDAsIDApLFxuICAgICAgICByb3RhdGlvbjogbmV3IFZlY3RvcjMoMCwgMCwgMClcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVGhpcyBsb2FkZXIgdXNlcyBubyBmaWVsZHMgZnJvbSBgTG9hZFNwZWNgLiBJbml0aWFsaXplIHZvbHVtZSB3aXRoIGRlZmF1bHRzLlxuICAgIHJldHVybiB7XG4gICAgICBpbWFnZUluZm86IGltZ2RhdGEsXG4gICAgICBsb2FkU3BlYzogbmV3IExvYWRTcGVjKClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGxvYWRSYXdDaGFubmVsRGF0YShpbWFnZUluZm8sIF9sb2FkU3BlYywgX29uVXBkYXRlTWV0YWRhdGEsIG9uRGF0YSkge1xuICAgIGNvbnN0IGRpbXMgPSBhd2FpdCB0aGlzLmxvYWRPbWVEaW1zKCk7XG4gICAgY29uc3QgY2hhbm5lbFByb21zID0gW107XG4gICAgLy8gZG8gZWFjaCBjaGFubmVsIG9uIGEgd29ya2VyP1xuICAgIGZvciAobGV0IGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgaW1hZ2VJbmZvLm51bUNoYW5uZWxzOyArK2NoYW5uZWwpIHtcbiAgICAgIGNvbnN0IHRoaXNDaGFubmVsUHJvbSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgIGNoYW5uZWw6IGNoYW5uZWwsXG4gICAgICAgICAgLy8gdGhlc2UgYXJlIHRhcmdldCB4eSBzaXplcyBmb3IgdGhlIGluLW1lbW9yeSB2b2x1bWUgZGF0YVxuICAgICAgICAgIC8vIHRoZXkgbWF5IG9yIG1heSBub3QgYmUgdGhlIHNhbWUgc2l6ZSBhcyBvcmlnaW5hbCB4eSBzaXplc1xuICAgICAgICAgIHRpbGVzaXpleDogaW1hZ2VJbmZvLnZvbHVtZVNpemUueCxcbiAgICAgICAgICB0aWxlc2l6ZXk6IGltYWdlSW5mby52b2x1bWVTaXplLnksXG4gICAgICAgICAgc2l6ZWM6IGltYWdlSW5mby5udW1DaGFubmVscyxcbiAgICAgICAgICBzaXplejogaW1hZ2VJbmZvLnZvbHVtZVNpemUueixcbiAgICAgICAgICBkaW1lbnNpb25PcmRlcjogZGltcy5kaW1lbnNpb25vcmRlcixcbiAgICAgICAgICBieXRlc1BlclNhbXBsZTogZ2V0Qnl0ZXNQZXJTYW1wbGUoZGltcy5waXhlbHR5cGUpLFxuICAgICAgICAgIHVybDogdGhpcy51cmxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihuZXcgVVJMKFwiLi4vd29ya2Vycy9GZXRjaFRpZmZXb3JrZXJcIiwgaW1wb3J0Lm1ldGEudXJsKSk7XG4gICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBlID0+IHtcbiAgICAgICAgICBpZiAoZS5kYXRhLmlzRXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChkZXNlcmlhbGl6ZUVycm9yKGUuZGF0YS5lcnJvcikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgICAgIHJhbmdlXG4gICAgICAgICAgfSA9IGUuZGF0YTtcbiAgICAgICAgICBvbkRhdGEoW2NoYW5uZWxdLCBbZGF0YV0sIFtyYW5nZV0pO1xuICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShwYXJhbXMpO1xuICAgICAgfSk7XG4gICAgICBjaGFubmVsUHJvbXMucHVzaCh0aGlzQ2hhbm5lbFByb20pO1xuICAgIH1cblxuICAgIC8vIHdhaXRpbmcgZm9yIGFsbCBjaGFubmVscyB0byBsb2FkIGFsbG93cyBlcnJvcnMgdG8gcHJvcGFnYXRlIHRvIHRoZSBjYWxsZXIgdmlhIHRoaXMgcHJvbWlzZVxuICAgIGF3YWl0IFByb21pc2UuYWxsKGNoYW5uZWxQcm9tcyk7XG4gIH1cbn1cbmV4cG9ydCB7IFRpZmZMb2FkZXIgfTsiXSwibmFtZXMiOlsiZnJvbVVybCIsIlZlY3RvcjMiLCJkZXNlcmlhbGl6ZUVycm9yIiwiVGhyZWFkYWJsZVZvbHVtZUxvYWRlciIsIkxvYWRTcGVjIiwiVm9sdW1lRGltcyIsImNvbXB1dGVQYWNrZWRBdGxhc0RpbXMiLCJWb2x1bWVMb2FkRXJyb3IiLCJWb2x1bWVMb2FkRXJyb3JUeXBlIiwid3JhcFZvbHVtZUxvYWRFcnJvciIsInByZXBhcmVYTUwiLCJ4bWwiLCJleHByIiwidHJpbSIsInJlcGxhY2UiLCJnZXRPTUUiLCJwYXJzZXIiLCJET01QYXJzZXIiLCJ4bWxEb2MiLCJwYXJzZUZyb21TdHJpbmciLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImUiLCJ0eXBlIiwiSU5WQUxJRF9NRVRBREFUQSIsImNhdXNlIiwiT01FRGltcyIsInNpemV4Iiwic2l6ZXkiLCJzaXpleiIsInNpemVjIiwic2l6ZXQiLCJ1bml0IiwicGl4ZWx0eXBlIiwiZGltZW5zaW9ub3JkZXIiLCJwaXhlbHNpemV4IiwicGl4ZWxzaXpleSIsInBpeGVsc2l6ZXoiLCJjaGFubmVsbmFtZXMiLCJnZXRBdHRyaWJ1dGVPckVycm9yIiwiZWwiLCJhdHRyIiwidmFsIiwiZ2V0QXR0cmlidXRlIiwiZ2V0T01FRGltcyIsImltYWdlRWwiLCJkaW1zIiwicGl4ZWxzRWwiLCJOdW1iZXIiLCJjaGFubmVsc0VscyIsImkiLCJsZW5ndGgiLCJuYW1lIiwiaWQiLCJwdXNoIiwiZ2V0Qnl0ZXNQZXJTYW1wbGUiLCJUaWZmTG9hZGVyIiwiY29uc3RydWN0b3IiLCJ1cmwiLCJsb2FkT21lRGltcyIsInRpZmYiLCJhbGxvd0Z1bGxGaWxlIiwiY2F0Y2giLCJOT1RfRk9VTkQiLCJpbWFnZSIsImdldEltYWdlIiwidGlmZmltZ2Rlc2MiLCJnZXRGaWxlRGlyZWN0b3J5IiwiSW1hZ2VEZXNjcmlwdGlvbiIsIm9tZUVsIiwiaW1hZ2UwRWwiLCJsb2FkRGltcyIsIl9sb2FkU3BlYyIsImQiLCJzaGFwZSIsInNwYWNpbmciLCJzcGFjZVVuaXQiLCJkYXRhVHlwZSIsImNyZWF0ZUltYWdlSW5mbyIsImF0bGFzRGltcyIsInRhcmdldFNpemUiLCJ0aWxlc2l6ZXgiLCJNYXRoIiwiZmxvb3IiLCJ4IiwidGlsZXNpemV5IiwieSIsImltZ2RhdGEiLCJvcmlnaW5hbFNpemUiLCJhdGxhc1RpbGVEaW1zIiwidm9sdW1lU2l6ZSIsInN1YnJlZ2lvblNpemUiLCJzdWJyZWdpb25PZmZzZXQiLCJwaHlzaWNhbFBpeGVsU2l6ZSIsInNwYXRpYWxVbml0IiwibnVtQ2hhbm5lbHMiLCJjaGFubmVsTmFtZXMiLCJ0aW1lcyIsInRpbWVTY2FsZSIsInRpbWVVbml0IiwibnVtTXVsdGlzY2FsZUxldmVscyIsIm11bHRpc2NhbGVMZXZlbCIsInRyYW5zZm9ybSIsInRyYW5zbGF0aW9uIiwicm90YXRpb24iLCJpbWFnZUluZm8iLCJsb2FkU3BlYyIsImxvYWRSYXdDaGFubmVsRGF0YSIsIl9vblVwZGF0ZU1ldGFkYXRhIiwib25EYXRhIiwiY2hhbm5lbFByb21zIiwiY2hhbm5lbCIsInRoaXNDaGFubmVsUHJvbSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicGFyYW1zIiwieiIsImRpbWVuc2lvbk9yZGVyIiwiYnl0ZXNQZXJTYW1wbGUiLCJ3b3JrZXIiLCJXb3JrZXIiLCJVUkwiLCJpbXBvcnQiLCJtZXRhIiwib25tZXNzYWdlIiwiZGF0YSIsImlzRXJyb3IiLCJlcnJvciIsInJhbmdlIiwidGVybWluYXRlIiwicG9zdE1lc3NhZ2UiLCJhbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../volume-viewer/es/loaders/TiffLoader.js\n");

/***/ }),

/***/ "../volume-viewer/es/loaders/VolumeLoadError.js":
/*!******************************************************!*\
  !*** ../volume-viewer/es/loaders/VolumeLoadError.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VolumeLoadError: () => (/* binding */ VolumeLoadError),\n/* harmony export */   VolumeLoadErrorType: () => (/* binding */ VolumeLoadErrorType),\n/* harmony export */   wrapVolumeLoadError: () => (/* binding */ wrapVolumeLoadError)\n/* harmony export */ });\n/* harmony import */ var serialize_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! serialize-error */ \"../volume-viewer/node_modules/serialize-error/error-constructors.js\");\n/* harmony import */ var _zarrita_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zarrita/core */ \"../volume-viewer/node_modules/@zarrita/core/dist/src/errors.js\");\n\n\n// geotiff doesn't export its error types...\n\n/** Groups possible load errors into a few broad categories which we can give similar guidance to the user about. */\nlet VolumeLoadErrorType = /*#__PURE__*/function (VolumeLoadErrorType) {\n  VolumeLoadErrorType[\"UNKNOWN\"] = \"unknown\";\n  VolumeLoadErrorType[\"NOT_FOUND\"] = \"not_found\";\n  VolumeLoadErrorType[\"TOO_LARGE\"] = \"too_large\";\n  VolumeLoadErrorType[\"LOAD_DATA_FAILED\"] = \"load_data_failed\";\n  VolumeLoadErrorType[\"INVALID_METADATA\"] = \"invalid_metadata\";\n  VolumeLoadErrorType[\"INVALID_MULTI_SOURCE_ZARR\"] = \"invalid_multi_source_zarr\";\n  return VolumeLoadErrorType;\n}({});\nclass VolumeLoadError extends Error {\n  constructor(message, options) {\n    super(message, options);\n    this.name = \"VolumeLoadError\";\n    this.type = options?.type ?? VolumeLoadErrorType.UNKNOWN;\n  }\n}\n\n// serialize-error only ever calls an error constructor with zero arguments. The required `ErrorConstructor`\n// type is a bit too restrictive - as long as the constructor can be called with no arguments it's fine.\nserialize_error__WEBPACK_IMPORTED_MODULE_0__[\"default\"].set(\"NodeNotFoundError\", _zarrita_core__WEBPACK_IMPORTED_MODULE_1__.NodeNotFoundError);\nserialize_error__WEBPACK_IMPORTED_MODULE_0__[\"default\"].set(\"KeyError\", _zarrita_core__WEBPACK_IMPORTED_MODULE_1__.KeyError);\nserialize_error__WEBPACK_IMPORTED_MODULE_0__[\"default\"].set(\"VolumeLoadError\", VolumeLoadError);\n\n/** Curried function to re-throw an error wrapped in a `VolumeLoadError` with the given `message` and `type`. */\nfunction wrapVolumeLoadError(message = \"Unknown error occurred while loading volume data\", type = VolumeLoadErrorType.UNKNOWN, ignore) {\n  return e => {\n    if (ignore !== undefined && e === ignore) {\n      return e;\n    }\n    if (e instanceof VolumeLoadError) {\n      throw e;\n    }\n    throw new VolumeLoadError(message, {\n      type,\n      cause: e\n    });\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL1ZvbHVtZUxvYWRFcnJvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvRDtBQUNRO0FBQzVEOztBQUVBO0FBQ08sSUFBSUcsbUJBQW1CLEdBQUcsYUFBYSxVQUFVQSxtQkFBbUIsRUFBRTtFQUMzRUEsbUJBQW1CLENBQUMsU0FBUyxDQUFDLEdBQUcsU0FBUztFQUMxQ0EsbUJBQW1CLENBQUMsV0FBVyxDQUFDLEdBQUcsV0FBVztFQUM5Q0EsbUJBQW1CLENBQUMsV0FBVyxDQUFDLEdBQUcsV0FBVztFQUM5Q0EsbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsR0FBRyxrQkFBa0I7RUFDNURBLG1CQUFtQixDQUFDLGtCQUFrQixDQUFDLEdBQUcsa0JBQWtCO0VBQzVEQSxtQkFBbUIsQ0FBQywyQkFBMkIsQ0FBQyxHQUFHLDJCQUEyQjtFQUM5RSxPQUFPQSxtQkFBbUI7QUFDNUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0UsTUFBTUMsZUFBZSxTQUFTQyxLQUFLLENBQUM7RUFDekNDLFdBQVdBLENBQUNDLE9BQU8sRUFBRUMsT0FBTyxFQUFFO0lBQzVCLEtBQUssQ0FBQ0QsT0FBTyxFQUFFQyxPQUFPLENBQUM7SUFDdkIsSUFBSSxDQUFDQyxJQUFJLEdBQUcsaUJBQWlCO0lBQzdCLElBQUksQ0FBQ0MsSUFBSSxHQUFHRixPQUFPLEVBQUVFLElBQUksSUFBSVAsbUJBQW1CLENBQUNRLE9BQU87RUFDMUQ7QUFDRjs7QUFFQTtBQUNBO0FBQ0FYLHVEQUFpQixDQUFDWSxHQUFHLENBQUMsbUJBQW1CLEVBQUVYLDREQUFpQixDQUFDO0FBQzdERCx1REFBaUIsQ0FBQ1ksR0FBRyxDQUFDLFVBQVUsRUFBRVYsbURBQVEsQ0FBQztBQUMzQ0YsdURBQWlCLENBQUNZLEdBQUcsQ0FBQyxpQkFBaUIsRUFBRVIsZUFBZSxDQUFDOztBQUV6RDtBQUNPLFNBQVNTLG1CQUFtQkEsQ0FBQ04sT0FBTyxHQUFHLGtEQUFrRCxFQUFFRyxJQUFJLEdBQUdQLG1CQUFtQixDQUFDUSxPQUFPLEVBQUVHLE1BQU0sRUFBRTtFQUM1SSxPQUFPQyxDQUFDLElBQUk7SUFDVixJQUFJRCxNQUFNLEtBQUtFLFNBQVMsSUFBSUQsQ0FBQyxLQUFLRCxNQUFNLEVBQUU7TUFDeEMsT0FBT0MsQ0FBQztJQUNWO0lBQ0EsSUFBSUEsQ0FBQyxZQUFZWCxlQUFlLEVBQUU7TUFDaEMsTUFBTVcsQ0FBQztJQUNUO0lBQ0EsTUFBTSxJQUFJWCxlQUFlLENBQUNHLE9BQU8sRUFBRTtNQUNqQ0csSUFBSTtNQUNKTyxLQUFLLEVBQUVGO0lBQ1QsQ0FBQyxDQUFDO0VBQ0osQ0FBQztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uLi92b2x1bWUtdmlld2VyL2VzL2xvYWRlcnMvVm9sdW1lTG9hZEVycm9yLmpzP2VkMWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXJyb3JDb25zdHJ1Y3RvcnMgfSBmcm9tIFwic2VyaWFsaXplLWVycm9yXCI7XG5pbXBvcnQgeyBOb2RlTm90Rm91bmRFcnJvciwgS2V5RXJyb3IgfSBmcm9tIFwiQHphcnJpdGEvY29yZVwiO1xuLy8gZ2VvdGlmZiBkb2Vzbid0IGV4cG9ydCBpdHMgZXJyb3IgdHlwZXMuLi5cblxuLyoqIEdyb3VwcyBwb3NzaWJsZSBsb2FkIGVycm9ycyBpbnRvIGEgZmV3IGJyb2FkIGNhdGVnb3JpZXMgd2hpY2ggd2UgY2FuIGdpdmUgc2ltaWxhciBndWlkYW5jZSB0byB0aGUgdXNlciBhYm91dC4gKi9cbmV4cG9ydCBsZXQgVm9sdW1lTG9hZEVycm9yVHlwZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoVm9sdW1lTG9hZEVycm9yVHlwZSkge1xuICBWb2x1bWVMb2FkRXJyb3JUeXBlW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xuICBWb2x1bWVMb2FkRXJyb3JUeXBlW1wiTk9UX0ZPVU5EXCJdID0gXCJub3RfZm91bmRcIjtcbiAgVm9sdW1lTG9hZEVycm9yVHlwZVtcIlRPT19MQVJHRVwiXSA9IFwidG9vX2xhcmdlXCI7XG4gIFZvbHVtZUxvYWRFcnJvclR5cGVbXCJMT0FEX0RBVEFfRkFJTEVEXCJdID0gXCJsb2FkX2RhdGFfZmFpbGVkXCI7XG4gIFZvbHVtZUxvYWRFcnJvclR5cGVbXCJJTlZBTElEX01FVEFEQVRBXCJdID0gXCJpbnZhbGlkX21ldGFkYXRhXCI7XG4gIFZvbHVtZUxvYWRFcnJvclR5cGVbXCJJTlZBTElEX01VTFRJX1NPVVJDRV9aQVJSXCJdID0gXCJpbnZhbGlkX211bHRpX3NvdXJjZV96YXJyXCI7XG4gIHJldHVybiBWb2x1bWVMb2FkRXJyb3JUeXBlO1xufSh7fSk7XG5leHBvcnQgY2xhc3MgVm9sdW1lTG9hZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgdGhpcy5uYW1lID0gXCJWb2x1bWVMb2FkRXJyb3JcIjtcbiAgICB0aGlzLnR5cGUgPSBvcHRpb25zPy50eXBlID8/IFZvbHVtZUxvYWRFcnJvclR5cGUuVU5LTk9XTjtcbiAgfVxufVxuXG4vLyBzZXJpYWxpemUtZXJyb3Igb25seSBldmVyIGNhbGxzIGFuIGVycm9yIGNvbnN0cnVjdG9yIHdpdGggemVybyBhcmd1bWVudHMuIFRoZSByZXF1aXJlZCBgRXJyb3JDb25zdHJ1Y3RvcmBcbi8vIHR5cGUgaXMgYSBiaXQgdG9vIHJlc3RyaWN0aXZlIC0gYXMgbG9uZyBhcyB0aGUgY29uc3RydWN0b3IgY2FuIGJlIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cyBpdCdzIGZpbmUuXG5lcnJvckNvbnN0cnVjdG9ycy5zZXQoXCJOb2RlTm90Rm91bmRFcnJvclwiLCBOb2RlTm90Rm91bmRFcnJvcik7XG5lcnJvckNvbnN0cnVjdG9ycy5zZXQoXCJLZXlFcnJvclwiLCBLZXlFcnJvcik7XG5lcnJvckNvbnN0cnVjdG9ycy5zZXQoXCJWb2x1bWVMb2FkRXJyb3JcIiwgVm9sdW1lTG9hZEVycm9yKTtcblxuLyoqIEN1cnJpZWQgZnVuY3Rpb24gdG8gcmUtdGhyb3cgYW4gZXJyb3Igd3JhcHBlZCBpbiBhIGBWb2x1bWVMb2FkRXJyb3JgIHdpdGggdGhlIGdpdmVuIGBtZXNzYWdlYCBhbmQgYHR5cGVgLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBWb2x1bWVMb2FkRXJyb3IobWVzc2FnZSA9IFwiVW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBsb2FkaW5nIHZvbHVtZSBkYXRhXCIsIHR5cGUgPSBWb2x1bWVMb2FkRXJyb3JUeXBlLlVOS05PV04sIGlnbm9yZSkge1xuICByZXR1cm4gZSA9PiB7XG4gICAgaWYgKGlnbm9yZSAhPT0gdW5kZWZpbmVkICYmIGUgPT09IGlnbm9yZSkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIGlmIChlIGluc3RhbmNlb2YgVm9sdW1lTG9hZEVycm9yKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVm9sdW1lTG9hZEVycm9yKG1lc3NhZ2UsIHtcbiAgICAgIHR5cGUsXG4gICAgICBjYXVzZTogZVxuICAgIH0pO1xuICB9O1xufSJdLCJuYW1lcyI6WyJlcnJvckNvbnN0cnVjdG9ycyIsIk5vZGVOb3RGb3VuZEVycm9yIiwiS2V5RXJyb3IiLCJWb2x1bWVMb2FkRXJyb3JUeXBlIiwiVm9sdW1lTG9hZEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJvcHRpb25zIiwibmFtZSIsInR5cGUiLCJVTktOT1dOIiwic2V0Iiwid3JhcFZvbHVtZUxvYWRFcnJvciIsImlnbm9yZSIsImUiLCJ1bmRlZmluZWQiLCJjYXVzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../volume-viewer/es/loaders/VolumeLoadError.js\n");

/***/ }),

/***/ "../volume-viewer/es/loaders/VolumeLoaderUtils.js":
/*!********************************************************!*\
  !*** ../volume-viewer/es/loaders/VolumeLoaderUtils.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_ATLAS_EDGE: () => (/* binding */ MAX_ATLAS_EDGE),\n/* harmony export */   buildDefaultMetadata: () => (/* binding */ buildDefaultMetadata),\n/* harmony export */   composeSubregion: () => (/* binding */ composeSubregion),\n/* harmony export */   computePackedAtlasDims: () => (/* binding */ computePackedAtlasDims),\n/* harmony export */   convertSubregionToPixels: () => (/* binding */ convertSubregionToPixels),\n/* harmony export */   estimateLevelForAtlas: () => (/* binding */ estimateLevelForAtlas),\n/* harmony export */   pickLevelToLoad: () => (/* binding */ pickLevelToLoad),\n/* harmony export */   pickLevelToLoadUnscaled: () => (/* binding */ pickLevelToLoadUnscaled),\n/* harmony export */   scaleDimsToSubregion: () => (/* binding */ scaleDimsToSubregion),\n/* harmony export */   scaleMultipleDimsToSubregion: () => (/* binding */ scaleMultipleDimsToSubregion),\n/* harmony export */   unitNameToSymbol: () => (/* binding */ unitNameToSymbol)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"../volume-viewer/node_modules/three/build/three.module.js\");\n/* harmony import */ var _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VolumeLoadError.js */ \"../volume-viewer/es/loaders/VolumeLoadError.js\");\n\n\nconst MAX_ATLAS_EDGE = 4096;\n\n// Map from units to their symbols\nconst UNIT_SYMBOLS = {\n  angstrom: \"\",\n  day: \"d\",\n  foot: \"ft\",\n  hour: \"h\",\n  inch: \"in\",\n  meter: \"m\",\n  micron: \"m\",\n  mile: \"mi\",\n  minute: \"min\",\n  parsec: \"pc\",\n  second: \"s\",\n  yard: \"yd\"\n};\n\n// Units which may take SI prefixes (e.g. micro-, tera-)\nconst SI_UNITS = [\"meter\", \"second\"];\n\n// SI prefixes which abbreviate in nonstandard ways\nconst SI_PREFIX_ABBVS = {\n  micro: \"\",\n  deca: \"da\"\n};\n\n/** Converts a full spatial or temporal unit name supported by OME-Zarr to its unit symbol */\n// (see https://ngff.openmicroscopy.org/latest/#axes-md)\nfunction unitNameToSymbol(unitName) {\n  if (unitName === undefined) {\n    return null;\n  }\n  if (UNIT_SYMBOLS[unitName]) {\n    return UNIT_SYMBOLS[unitName];\n  }\n  const prefixedSIUnit = SI_UNITS.find(siUnit => unitName.endsWith(siUnit));\n  if (prefixedSIUnit) {\n    const prefix = unitName.substring(0, unitName.length - prefixedSIUnit.length);\n    if (SI_PREFIX_ABBVS[prefix]) {\n      // \"special\" SI prefix\n      return SI_PREFIX_ABBVS[prefix] + UNIT_SYMBOLS[prefixedSIUnit];\n    }\n\n    // almost all SI prefixes are abbreviated by first letter, capitalized if prefix ends with \"a\"\n    const capitalize = prefix.endsWith(\"a\");\n    const prefixAbbr = capitalize ? prefix[0].toUpperCase() : prefix[0];\n    return prefixAbbr + UNIT_SYMBOLS[prefixedSIUnit];\n  }\n  return null;\n}\n\n// We want to find the most \"square\" packing of z tw by th tiles.\n// Compute number of rows and columns.\nfunction computePackedAtlasDims(z, tw, th) {\n  let nextrows = 1;\n  let nextcols = z;\n  let ratio = nextcols * tw / (nextrows * th);\n  let nrows = nextrows;\n  let ncols = nextcols;\n  while (ratio > 1) {\n    nrows = nextrows;\n    ncols = nextcols;\n    nextcols -= 1;\n    nextrows = Math.ceil(z / nextcols);\n    ratio = nextcols * tw / (nextrows * th);\n  }\n  return new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(nrows, ncols);\n}\nfunction doesSpatialDimensionFitInAtlas(spatialDimZYX, maxAtlasEdge = MAX_ATLAS_EDGE) {\n  // Estimate atlas size\n  const x = spatialDimZYX[2];\n  const y = spatialDimZYX[1];\n  const z = spatialDimZYX[0];\n  const xtiles = Math.floor(maxAtlasEdge / x);\n  const ytiles = Math.floor(maxAtlasEdge / y);\n  return xtiles * ytiles >= z;\n}\n\n/** Picks the largest scale level that can fit into a texture atlas with edges no longer than `maxAtlasEdge`. */\nfunction estimateLevelForAtlas(spatialDimsZYX, maxAtlasEdge = MAX_ATLAS_EDGE) {\n  if (spatialDimsZYX.length <= 1) {\n    return 0;\n  }\n  for (let i = 0; i < spatialDimsZYX.length; ++i) {\n    // estimate atlas size:\n    if (doesSpatialDimensionFitInAtlas(spatialDimsZYX[i], maxAtlasEdge)) {\n      return i;\n    }\n  }\n  return undefined;\n}\nconst maxCeil = val => Math.max(Math.ceil(val), 1);\nconst scaleDims = (size, [z, y, x]) => [maxCeil(z * size.z), maxCeil(y * size.y), maxCeil(x * size.x)];\nfunction scaleDimsToSubregion(subregion, dims) {\n  const size = subregion.getSize(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n  return scaleDims(size, dims);\n}\nfunction scaleMultipleDimsToSubregion(subregion, dims) {\n  const size = subregion.getSize(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n  return dims.map(dim => scaleDims(size, dim));\n}\n\n/**\r\n * Picks the best scale level to load based on scale level dimensions and a `LoadSpec`. This calls\r\n * `estimateLevelForAtlas`, then accounts for `LoadSpec`'s scale level picking properties:\r\n * - `multiscaleLevel` imposes a minimum scale level (or *maximum* resolution level) to load\r\n * - `maxAtlasEdge` sets the maximum size of the texture atlas that may be produced by a load\r\n * - `scaleLevelBias` offsets the scale level index after the optimal level is picked based on `maxAtlasEdge`\r\n *\r\n *  This function assumes that `spatialDimsZYX` has already been appropriately scaled to match `loadSpec`'s `subregion`.\r\n */\nfunction pickLevelToLoadUnscaled(loadSpec, spatialDimsZYX) {\n  let levelToLoad = estimateLevelForAtlas(spatialDimsZYX, loadSpec.maxAtlasEdge);\n  // Check here for whether levelToLoad is within max atlas size?\n  if (levelToLoad !== undefined) {\n    levelToLoad = Math.max(levelToLoad + (loadSpec.scaleLevelBias ?? 0), loadSpec.multiscaleLevel ?? 0);\n    levelToLoad = Math.max(0, Math.min(spatialDimsZYX.length - 1, levelToLoad));\n    if (doesSpatialDimensionFitInAtlas(spatialDimsZYX[levelToLoad], loadSpec.maxAtlasEdge)) {\n      return levelToLoad;\n    }\n  }\n\n  // Level to load could not be loaded due to atlas size constraints.\n  if (levelToLoad === undefined) {\n    // No optimal level exists so choose the smallest level to report out\n    levelToLoad = spatialDimsZYX.length - 1;\n  }\n  const smallestDims = spatialDimsZYX[levelToLoad];\n  console.error(`Volume is too large; no multiscale level found that fits in preferred memory footprint. Selected level ${levelToLoad}  has dimensions `, smallestDims, `. Max atlas edge allowed is ${loadSpec.maxAtlasEdge}.`);\n  console.log(\"All available levels: \", spatialDimsZYX);\n  throw new _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadError(`Volume is too large; multiscale level does not fit in preferred memory footprint.`, {\n    type: _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadErrorType.TOO_LARGE\n  });\n}\n\n/**\r\n * Picks the best scale level to load based on scale level dimensions and a `LoadSpec`. This calls\r\n * `estimateLevelForAtlas` and accounts for all properties of `LoadSpec` considered by\r\n * `pickLevelToLoadUnscaled`, and additionally scales the dimensions of the scale levels to account for the\r\n * `LoadSpec`'s `subregion` property.\r\n */\nfunction pickLevelToLoad(loadSpec, spatialDimsZYX) {\n  const scaledDims = scaleMultipleDimsToSubregion(loadSpec.subregion, spatialDimsZYX);\n  return pickLevelToLoadUnscaled(loadSpec, scaledDims);\n}\n\n/** Given the size of a volume in pixels, convert a `Box3` in the 0-1 range to pixels */\nfunction convertSubregionToPixels(region, size) {\n  const min = region.min.clone().multiply(size).floor();\n  const max = region.max.clone().multiply(size).ceil();\n\n  // ensure it's always valid to specify the same number at both ends and get a single slice\n  if (min.x === max.x && min.x < size.x) {\n    max.x += 1;\n  }\n  if (min.y === max.y && min.y < size.y) {\n    max.y += 1;\n  }\n  if (min.z === max.z && min.z < size.z) {\n    max.z += 1;\n  }\n  return new three__WEBPACK_IMPORTED_MODULE_1__.Box3(min, max);\n}\n\n/**\r\n * Return the subset of `container` specified by `region`, assuming that `region` contains fractional values (between 0\r\n * and 1). i.e. if `container`'s range on the X axis is 0-4 and `region`'s is 0.25-0.5, the result will have range 1-2.\r\n */\nfunction composeSubregion(region, container) {\n  const size = container.getSize(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n  const min = region.min.clone().multiply(size).add(container.min);\n  const max = region.max.clone().multiply(size).add(container.min);\n  return new three__WEBPACK_IMPORTED_MODULE_1__.Box3(min, max);\n}\nfunction isEmpty(obj) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// currently everything needed can come from the imageInfo\n// but in the future each IVolumeLoader could have a completely separate implementation.\nfunction buildDefaultMetadata(imageInfo) {\n  const physicalSize = imageInfo.volumeSize.clone().multiply(imageInfo.physicalPixelSize);\n  const metadata = {};\n  metadata[\"Dimensions\"] = {\n    ...imageInfo.subregionSize\n  };\n  metadata[\"Original dimensions\"] = {\n    ...imageInfo.originalSize\n  };\n  metadata[\"Physical size\"] = {\n    x: physicalSize.x + imageInfo.spatialUnit,\n    y: physicalSize.y + imageInfo.spatialUnit,\n    z: physicalSize.z + imageInfo.spatialUnit\n  };\n  metadata[\"Physical size per pixel\"] = {\n    x: imageInfo.physicalPixelSize.x + imageInfo.spatialUnit,\n    y: imageInfo.physicalPixelSize.y + imageInfo.spatialUnit,\n    z: imageInfo.physicalPixelSize.z + imageInfo.spatialUnit\n  };\n  metadata[\"Channels\"] = imageInfo.numChannels;\n  metadata[\"Time series frames\"] = imageInfo.times || 1;\n  // don't add User data if it's empty\n  if (imageInfo.userData && !isEmpty(imageInfo.userData)) {\n    metadata[\"User data\"] = imageInfo.userData;\n  }\n  return metadata;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL1ZvbHVtZUxvYWRlclV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0M7QUFDNkI7QUFDckUsTUFBTUssY0FBYyxHQUFHLElBQUk7O0FBRWxDO0FBQ0EsTUFBTUMsWUFBWSxHQUFHO0VBQ25CQyxRQUFRLEVBQUUsR0FBRztFQUNiQyxHQUFHLEVBQUUsR0FBRztFQUNSQyxJQUFJLEVBQUUsSUFBSTtFQUNWQyxJQUFJLEVBQUUsR0FBRztFQUNUQyxJQUFJLEVBQUUsSUFBSTtFQUNWQyxLQUFLLEVBQUUsR0FBRztFQUNWQyxNQUFNLEVBQUUsSUFBSTtFQUNaQyxJQUFJLEVBQUUsSUFBSTtFQUNWQyxNQUFNLEVBQUUsS0FBSztFQUNiQyxNQUFNLEVBQUUsSUFBSTtFQUNaQyxNQUFNLEVBQUUsR0FBRztFQUNYQyxJQUFJLEVBQUU7QUFDUixDQUFDOztBQUVEO0FBQ0EsTUFBTUMsUUFBUSxHQUFHLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQzs7QUFFcEM7QUFDQSxNQUFNQyxlQUFlLEdBQUc7RUFDdEJDLEtBQUssRUFBRSxHQUFHO0VBQ1ZDLElBQUksRUFBRTtBQUNSLENBQUM7O0FBRUQ7QUFDQTtBQUNPLFNBQVNDLGdCQUFnQkEsQ0FBQ0MsUUFBUSxFQUFFO0VBQ3pDLElBQUlBLFFBQVEsS0FBS0MsU0FBUyxFQUFFO0lBQzFCLE9BQU8sSUFBSTtFQUNiO0VBQ0EsSUFBSW5CLFlBQVksQ0FBQ2tCLFFBQVEsQ0FBQyxFQUFFO0lBQzFCLE9BQU9sQixZQUFZLENBQUNrQixRQUFRLENBQUM7RUFDL0I7RUFDQSxNQUFNRSxjQUFjLEdBQUdQLFFBQVEsQ0FBQ1EsSUFBSSxDQUFDQyxNQUFNLElBQUlKLFFBQVEsQ0FBQ0ssUUFBUSxDQUFDRCxNQUFNLENBQUMsQ0FBQztFQUN6RSxJQUFJRixjQUFjLEVBQUU7SUFDbEIsTUFBTUksTUFBTSxHQUFHTixRQUFRLENBQUNPLFNBQVMsQ0FBQyxDQUFDLEVBQUVQ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WSxDQUFDL0QsQ0FBQyxHQUFHOEQsU0FBUyxDQUFDTztFQUNoQyxDQUFDO0VBQ0RILFFBQVEsQ0FBQyx5QkFBeUIsQ0FBQyxHQUFHO0lBQ3BDckQsQ0FBQyxFQUFFaUQsU0FBUyxDQUFDRyxpQkFBaUIsQ0FBQ3BELENBQUMsR0FBR2lELFNBQVMsQ0FBQ08sV0FBVztJQUN4RHZELENBQUMsRUFBRWdELFNBQVMsQ0FBQ0csaUJBQWlCLENBQUNuRCxDQUFDLEdBQUdnRCxTQUFTLENBQUNPLFdBQVc7SUFDeERyRSxDQUFDLEVBQUU4RCxTQUFTLENBQUNHLGlCQUFpQixDQUFDakUsQ0FBQyxHQUFHOEQsU0FBUyxDQUFDTztFQUMvQyxDQUFDO0VBQ0RILFFBQVEsQ0FBQyxVQUFVLENBQUMsR0FBR0osU0FBUyxDQUFDUSxXQUFXO0VBQzVDSixRQUFRLENBQUMsb0JBQW9CLENBQUMsR0FBR0osU0FBUyxDQUFDUyxLQUFLLElBQUksQ0FBQztFQUNyRDtFQUNBLElBQUlULFNBQVMsQ0FBQ1UsUUFBUSxJQUFJLENBQUNsQixPQUFPLENBQUNRLFNBQVMsQ0FBQ1UsUUFBUSxDQUFDLEVBQUU7SUFDdEROLFFBQVEsQ0FBQyxXQUFXLENBQUMsR0FBR0osU0FBUyxDQUFDVSxRQUFRO0VBQzVDO0VBQ0EsT0FBT04sUUFBUTtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL1ZvbHVtZUxvYWRlclV0aWxzLmpzP2E4OWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQm94MywgVmVjdG9yMiwgVmVjdG9yMyB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgVm9sdW1lTG9hZEVycm9yLCBWb2x1bWVMb2FkRXJyb3JUeXBlIH0gZnJvbSBcIi4vVm9sdW1lTG9hZEVycm9yLmpzXCI7XG5leHBvcnQgY29uc3QgTUFYX0FUTEFTX0VER0UgPSA0MDk2O1xuXG4vLyBNYXAgZnJvbSB1bml0cyB0byB0aGVpciBzeW1ib2xzXG5jb25zdCBVTklUX1NZTUJPTFMgPSB7XG4gIGFuZ3N0cm9tOiBcIsOFXCIsXG4gIGRheTogXCJkXCIsXG4gIGZvb3Q6IFwiZnRcIixcbiAgaG91cjogXCJoXCIsXG4gIGluY2g6IFwiaW5cIixcbiAgbWV0ZXI6IFwibVwiLFxuICBtaWNyb246IFwizrxtXCIsXG4gIG1pbGU6IFwibWlcIixcbiAgbWludXRlOiBcIm1pblwiLFxuICBwYXJzZWM6IFwicGNcIixcbiAgc2Vjb25kOiBcInNcIixcbiAgeWFyZDogXCJ5ZFwiXG59O1xuXG4vLyBVbml0cyB3aGljaCBtYXkgdGFrZSBTSSBwcmVmaXhlcyAoZS5nLiBtaWNyby0sIHRlcmEtKVxuY29uc3QgU0lfVU5JVFMgPSBbXCJtZXRlclwiLCBcInNlY29uZFwiXTtcblxuLy8gU0kgcHJlZml4ZXMgd2hpY2ggYWJicmV2aWF0ZSBpbiBub25zdGFuZGFyZCB3YXlzXG5jb25zdCBTSV9QUkVGSVhfQUJCVlMgPSB7XG4gIG1pY3JvOiBcIs68XCIsXG4gIGRlY2E6IFwiZGFcIlxufTtcblxuLyoqIENvbnZlcnRzIGEgZnVsbCBzcGF0aWFsIG9yIHRlbXBvcmFsIHVuaXQgbmFtZSBzdXBwb3J0ZWQgYnkgT01FLVphcnIgdG8gaXRzIHVuaXQgc3ltYm9sICovXG4vLyAoc2VlIGh0dHBzOi8vbmdmZi5vcGVubWljcm9zY29weS5vcmcvbGF0ZXN0LyNheGVzLW1kKVxuZXhwb3J0IGZ1bmN0aW9uIHVuaXROYW1lVG9TeW1ib2wodW5pdE5hbWUpIHtcbiAgaWYgKHVuaXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoVU5JVF9TWU1CT0xTW3VuaXROYW1lXSkge1xuICAgIHJldHVybiBVTklUX1NZTUJPTFNbdW5pdE5hbWVdO1xuICB9XG4gIGNvbnN0IHByZWZpeGVkU0lVbml0ID0gU0lfVU5JVFMuZmluZChzaVVuaXQgPT4gdW5pdE5hbWUuZW5kc1dpdGgoc2lVbml0KSk7XG4gIGlmIChwcmVmaXhlZFNJVW5pdCkge1xuICAgIGNvbnN0IHByZWZpeCA9IHVuaXROYW1lLnN1YnN0cmluZygwLCB1bml0TmFtZS5sZW5ndGggLSBwcmVmaXhlZFNJVW5pdC5sZW5ndGgpO1xuICAgIGlmIChTSV9QUkVGSVhfQUJCVlNbcHJlZml4XSkge1xuICAgICAgLy8gXCJzcGVjaWFsXCIgU0kgcHJlZml4XG4gICAgICByZXR1cm4gU0lfUFJFRklYX0FCQlZTW3ByZWZpeF0gKyBVTklUX1NZTUJPTFNbcHJlZml4ZWRTSVVuaXRdO1xuICAgIH1cblxuICAgIC8vIGFsbW9zdCBhbGwgU0kgcHJlZml4ZXMgYXJlIGFiYnJldmlhdGVkIGJ5IGZpcnN0IGxldHRlciwgY2FwaXRhbGl6ZWQgaWYgcHJlZml4IGVuZHMgd2l0aCBcImFcIlxuICAgIGNvbnN0IGNhcGl0YWxpemUgPSBwcmVmaXguZW5kc1dpdGgoXCJhXCIpO1xuICAgIGNvbnN0IHByZWZpeEFiYnIgPSBjYXBpdGFsaXplID8gcHJlZml4WzBdLnRvVXBwZXJDYXNlKCkgOiBwcmVmaXhbMF07XG4gICAgcmV0dXJuIHByZWZpeEFiYnIgKyBVTklUX1NZTUJPTFNbcHJlZml4ZWRTSVVuaXRdO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBXZSB3YW50IHRvIGZpbmQgdGhlIG1vc3QgXCJzcXVhcmVcIiBwYWNraW5nIG9mIHogdHcgYnkgdGggdGlsZXMuXG4vLyBDb21wdXRlIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zLlxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVQYWNrZWRBdGxhc0RpbXMoeiwgdHcsIHRoKSB7XG4gIGxldCBuZXh0cm93cyA9IDE7XG4gIGxldCBuZXh0Y29scyA9IHo7XG4gIGxldCByYXRpbyA9IG5leHRjb2xzICogdHcgLyAobmV4dHJvd3MgKiB0aCk7XG4gIGxldCBucm93cyA9IG5leHRyb3dzO1xuICBsZXQgbmNvbHMgPSBuZXh0Y29scztcbiAgd2hpbGUgKHJhdGlvID4gMSkge1xuICAgIG5yb3dzID0gbmV4dHJvd3M7XG4gICAgbmNvbHMgPSBuZXh0Y29scztcbiAgICBuZXh0Y29scyAtPSAxO1xuICAgIG5leHRyb3dzID0gTWF0aC5jZWlsKHogLyBuZXh0Y29scyk7XG4gICAgcmF0aW8gPSBuZXh0Y29scyAqIHR3IC8gKG5leHRyb3dzICogdGgpO1xuICB9XG4gIHJldHVybiBuZXcgVmVjdG9yMihucm93cywgbmNvbHMpO1xufVxuZnVuY3Rpb24gZG9lc1NwYXRpYWxEaW1lbnNpb25GaXRJbkF0bGFzKHNwYXRpYWxEaW1aWVgsIG1heEF0bGFzRWRnZSA9IE1BWF9BVExBU19FREdFKSB7XG4gIC8vIEVzdGltYXRlIGF0bGFzIHNpemVcbiAgY29uc3QgeCA9IHNwYXRpYWxEaW1aWVhbMl07XG4gIGNvbnN0IHkgPSBzcGF0aWFsRGltWllYWzFdO1xuICBjb25zdCB6ID0gc3BhdGlhbERpbVpZWFswXTtcbiAgY29uc3QgeHRpbGVzID0gTWF0aC5mbG9vcihtYXhBdGxhc0VkZ2UgLyB4KTtcbiAgY29uc3QgeXRpbGVzID0gTWF0aC5mbG9vcihtYXhBdGxhc0VkZ2UgLyB5KTtcbiAgcmV0dXJuIHh0aWxlcyAqIHl0aWxlcyA+PSB6O1xufVxuXG4vKiogUGlja3MgdGhlIGxhcmdlc3Qgc2NhbGUgbGV2ZWwgdGhhdCBjYW4gZml0IGludG8gYSB0ZXh0dXJlIGF0bGFzIHdpdGggZWRnZXMgbm8gbG9uZ2VyIHRoYW4gYG1heEF0bGFzRWRnZWAuICovXG5leHBvcnQgZnVuY3Rpb24gZXN0aW1hdGVMZXZlbEZvckF0bGFzKHNwYXRpYWxEaW1zWllYLCBtYXhBdGxhc0VkZ2UgPSBNQVhfQVRMQVNfRURHRSkge1xuICBpZiAoc3BhdGlhbERpbXNaWVgubGVuZ3RoIDw9IDEpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYXRpYWxEaW1zWllYLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gZXN0aW1hdGUgYXRsYXMgc2l6ZTpcbiAgICBpZiAoZG9lc1NwYXRpYWxEaW1lbnNpb25GaXRJbkF0bGFzKHNwYXRpYWxEaW1zWllYW2ldLCBtYXhBdGxhc0VkZ2UpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNvbnN0IG1heENlaWwgPSB2YWwgPT4gTWF0aC5tYXgoTWF0aC5jZWlsKHZhbCksIDEpO1xuY29uc3Qgc2NhbGVEaW1zID0gKHNpemUsIFt6LCB5LCB4XSkgPT4gW21heENlaWwoeiAqIHNpemUueiksIG1heENlaWwoeSAqIHNpemUueSksIG1heENlaWwoeCAqIHNpemUueCldO1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlRGltc1RvU3VicmVnaW9uKHN1YnJlZ2lvbiwgZGltcykge1xuICBjb25zdCBzaXplID0gc3VicmVnaW9uLmdldFNpemUobmV3IFZlY3RvcjMoKSk7XG4gIHJldHVybiBzY2FsZURpbXMoc2l6ZSwgZGltcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2NhbGVNdWx0aXBsZURpbXNUb1N1YnJlZ2lvbihzdWJyZWdpb24sIGRpbXMpIHtcbiAgY29uc3Qgc2l6ZSA9IHN1YnJlZ2lvbi5nZXRTaXplKG5ldyBWZWN0b3IzKCkpO1xuICByZXR1cm4gZGltcy5tYXAoZGltID0+IHNjYWxlRGltcyhzaXplLCBkaW0pKTtcbn1cblxuLyoqXHJcbiAqIFBpY2tzIHRoZSBiZXN0IHNjYWxlIGxldmVsIHRvIGxvYWQgYmFzZWQgb24gc2NhbGUgbGV2ZWwgZGltZW5zaW9ucyBhbmQgYSBgTG9hZFNwZWNgLiBUaGlzIGNhbGxzXHJcbiAqIGBlc3RpbWF0ZUxldmVsRm9yQXRsYXNgLCB0aGVuIGFjY291bnRzIGZvciBgTG9hZFNwZWNgJ3Mgc2NhbGUgbGV2ZWwgcGlja2luZyBwcm9wZXJ0aWVzOlxyXG4gKiAtIGBtdWx0aXNjYWxlTGV2ZWxgIGltcG9zZXMgYSBtaW5pbXVtIHNjYWxlIGxldmVsIChvciAqbWF4aW11bSogcmVzb2x1dGlvbiBsZXZlbCkgdG8gbG9hZFxyXG4gKiAtIGBtYXhBdGxhc0VkZ2VgIHNldHMgdGhlIG1heGltdW0gc2l6ZSBvZiB0aGUgdGV4dHVyZSBhdGxhcyB0aGF0IG1heSBiZSBwcm9kdWNlZCBieSBhIGxvYWRcclxuICogLSBgc2NhbGVMZXZlbEJpYXNgIG9mZnNldHMgdGhlIHNjYWxlIGxldmVsIGluZGV4IGFmdGVyIHRoZSBvcHRpbWFsIGxldmVsIGlzIHBpY2tlZCBiYXNlZCBvbiBgbWF4QXRsYXNFZGdlYFxyXG4gKlxyXG4gKiAgVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYHNwYXRpYWxEaW1zWllYYCBoYXMgYWxyZWFkeSBiZWVuIGFwcHJvcHJpYXRlbHkgc2NhbGVkIHRvIG1hdGNoIGBsb2FkU3BlY2AncyBgc3VicmVnaW9uYC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gcGlja0xldmVsVG9Mb2FkVW5zY2FsZWQobG9hZFNwZWMsIHNwYXRpYWxEaW1zWllYKSB7XG4gIGxldCBsZXZlbFRvTG9hZCA9IGVzdGltYXRlTGV2ZWxGb3JBdGxhcyhzcGF0aWFsRGltc1pZWCwgbG9hZFNwZWMubWF4QXRsYXNFZGdlKTtcbiAgLy8gQ2hlY2sgaGVyZSBmb3Igd2hldGhlciBsZXZlbFRvTG9hZCBpcyB3aXRoaW4gbWF4IGF0bGFzIHNpemU/XG4gIGlmIChsZXZlbFRvTG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV2ZWxUb0xvYWQgPSBNYXRoLm1heChsZXZlbFRvTG9hZCArIChsb2FkU3BlYy5zY2FsZUxldmVsQmlhcyA/PyAwKSwgbG9hZFNwZWMubXVsdGlzY2FsZUxldmVsID8/IDApO1xuICAgIGxldmVsVG9Mb2FkID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc3BhdGlhbERpbXNaWVgubGVuZ3RoIC0gMSwgbGV2ZWxUb0xvYWQpKTtcbiAgICBpZiAoZG9lc1NwYXRpYWxEaW1lbnNpb25GaXRJbkF0bGFzKHNwYXRpYWxEaW1zWllYW2xldmVsVG9Mb2FkXSwgbG9hZFNwZWMubWF4QXRsYXNFZGdlKSkge1xuICAgICAgcmV0dXJuIGxldmVsVG9Mb2FkO1xuICAgIH1cbiAgfVxuXG4gIC8vIExldmVsIHRvIGxvYWQgY291bGQgbm90IGJlIGxvYWRlZCBkdWUgdG8gYXRsYXMgc2l6ZSBjb25zdHJhaW50cy5cbiAgaWYgKGxldmVsVG9Mb2FkID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBObyBvcHRpbWFsIGxldmVsIGV4aXN0cyBzbyBjaG9vc2UgdGhlIHNtYWxsZXN0IGxldmVsIHRvIHJlcG9ydCBvdXRcbiAgICBsZXZlbFRvTG9hZCA9IHNwYXRpYWxEaW1zWllYLmxlbmd0aCAtIDE7XG4gIH1cbiAgY29uc3Qgc21hbGxlc3REaW1zID0gc3BhdGlhbERpbXNaWVhbbGV2ZWxUb0xvYWRdO1xuICBjb25zb2xlLmVycm9yKGBWb2x1bWUgaXMgdG9vIGxhcmdlOyBubyBtdWx0aXNjYWxlIGxldmVsIGZvdW5kIHRoYXQgZml0cyBpbiBwcmVmZXJyZWQgbWVtb3J5IGZvb3RwcmludC4gU2VsZWN0ZWQgbGV2ZWwgJHtsZXZlbFRvTG9hZH0gIGhhcyBkaW1lbnNpb25zIGAsIHNtYWxsZXN0RGltcywgYC4gTWF4IGF0bGFzIGVkZ2UgYWxsb3dlZCBpcyAke2xvYWRTcGVjLm1heEF0bGFzRWRnZX0uYCk7XG4gIGNvbnNvbGUubG9nKFwiQWxsIGF2YWlsYWJsZSBsZXZlbHM6IFwiLCBzcGF0aWFsRGltc1pZWCk7XG4gIHRocm93IG5ldyBWb2x1bWVMb2FkRXJyb3IoYFZvbHVtZSBpcyB0b28gbGFyZ2U7IG11bHRpc2NhbGUgbGV2ZWwgZG9lcyBub3QgZml0IGluIHByZWZlcnJlZCBtZW1vcnkgZm9vdHByaW50LmAsIHtcbiAgICB0eXBlOiBWb2x1bWVMb2FkRXJyb3JUeXBlLlRPT19MQVJHRVxuICB9KTtcbn1cblxuLyoqXHJcbiAqIFBpY2tzIHRoZSBiZXN0IHNjYWxlIGxldmVsIHRvIGxvYWQgYmFzZWQgb24gc2NhbGUgbGV2ZWwgZGltZW5zaW9ucyBhbmQgYSBgTG9hZFNwZWNgLiBUaGlzIGNhbGxzXHJcbiAqIGBlc3RpbWF0ZUxldmVsRm9yQXRsYXNgIGFuZCBhY2NvdW50cyBmb3IgYWxsIHByb3BlcnRpZXMgb2YgYExvYWRTcGVjYCBjb25zaWRlcmVkIGJ5XHJcbiAqIGBwaWNrTGV2ZWxUb0xvYWRVbnNjYWxlZGAsIGFuZCBhZGRpdGlvbmFsbHkgc2NhbGVzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBzY2FsZSBsZXZlbHMgdG8gYWNjb3VudCBmb3IgdGhlXHJcbiAqIGBMb2FkU3BlY2AncyBgc3VicmVnaW9uYCBwcm9wZXJ0eS5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gcGlja0xldmVsVG9Mb2FkKGxvYWRTcGVjLCBzcGF0aWFsRGltc1pZWCkge1xuICBjb25zdCBzY2FsZWREaW1zID0gc2NhbGVNdWx0aXBsZURpbXNUb1N1YnJlZ2lvbihsb2FkU3BlYy5zdWJyZWdpb24sIHNwYXRpYWxEaW1zWllYKTtcbiAgcmV0dXJuIHBpY2tMZXZlbFRvTG9hZFVuc2NhbGVkKGxvYWRTcGVjLCBzY2FsZWREaW1zKTtcbn1cblxuLyoqIEdpdmVuIHRoZSBzaXplIG9mIGEgdm9sdW1lIGluIHBpeGVscywgY29udmVydCBhIGBCb3gzYCBpbiB0aGUgMC0xIHJhbmdlIHRvIHBpeGVscyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRTdWJyZWdpb25Ub1BpeGVscyhyZWdpb24sIHNpemUpIHtcbiAgY29uc3QgbWluID0gcmVnaW9uLm1pbi5jbG9uZSgpLm11bHRpcGx5KHNpemUpLmZsb29yKCk7XG4gIGNvbnN0IG1heCA9IHJlZ2lvbi5tYXguY2xvbmUoKS5tdWx0aXBseShzaXplKS5jZWlsKCk7XG5cbiAgLy8gZW5zdXJlIGl0J3MgYWx3YXlzIHZhbGlkIHRvIHNwZWNpZnkgdGhlIHNhbWUgbnVtYmVyIGF0IGJvdGggZW5kcyBhbmQgZ2V0IGEgc2luZ2xlIHNsaWNlXG4gIGlmIChtaW4ueCA9PT0gbWF4LnggJiYgbWluLnggPCBzaXplLngpIHtcbiAgICBtYXgueCArPSAxO1xuICB9XG4gIGlmIChtaW4ueSA9PT0gbWF4LnkgJiYgbWluLnkgPCBzaXplLnkpIHtcbiAgICBtYXgueSArPSAxO1xuICB9XG4gIGlmIChtaW4ueiA9PT0gbWF4LnogJiYgbWluLnogPCBzaXplLnopIHtcbiAgICBtYXgueiArPSAxO1xuICB9XG4gIHJldHVybiBuZXcgQm94MyhtaW4sIG1heCk7XG59XG5cbi8qKlxyXG4gKiBSZXR1cm4gdGhlIHN1YnNldCBvZiBgY29udGFpbmVyYCBzcGVjaWZpZWQgYnkgYHJlZ2lvbmAsIGFzc3VtaW5nIHRoYXQgYHJlZ2lvbmAgY29udGFpbnMgZnJhY3Rpb25hbCB2YWx1ZXMgKGJldHdlZW4gMFxyXG4gKiBhbmQgMSkuIGkuZS4gaWYgYGNvbnRhaW5lcmAncyByYW5nZSBvbiB0aGUgWCBheGlzIGlzIDAtNCBhbmQgYHJlZ2lvbmAncyBpcyAwLjI1LTAuNSwgdGhlIHJlc3VsdCB3aWxsIGhhdmUgcmFuZ2UgMS0yLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb3NlU3VicmVnaW9uKHJlZ2lvbiwgY29udGFpbmVyKSB7XG4gIGNvbnN0IHNpemUgPSBjb250YWluZXIuZ2V0U2l6ZShuZXcgVmVjdG9yMygpKTtcbiAgY29uc3QgbWluID0gcmVnaW9uLm1pbi5jbG9uZSgpLm11bHRpcGx5KHNpemUpLmFkZChjb250YWluZXIubWluKTtcbiAgY29uc3QgbWF4ID0gcmVnaW9uLm1heC5jbG9uZSgpLm11bHRpcGx5KHNpemUpLmFkZChjb250YWluZXIubWluKTtcbiAgcmV0dXJuIG5ldyBCb3gzKG1pbiwgbWF4KTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBjdXJyZW50bHkgZXZlcnl0aGluZyBuZWVkZWQgY2FuIGNvbWUgZnJvbSB0aGUgaW1hZ2VJbmZvXG4vLyBidXQgaW4gdGhlIGZ1dHVyZSBlYWNoIElWb2x1bWVMb2FkZXIgY291bGQgaGF2ZSBhIGNvbXBsZXRlbHkgc2VwYXJhdGUgaW1wbGVtZW50YXRpb24uXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREZWZhdWx0TWV0YWRhdGEoaW1hZ2VJbmZvKSB7XG4gIGNvbnN0IHBoeXNpY2FsU2l6ZSA9IGltYWdlSW5mby52b2x1bWVTaXplLmNsb25lKCkubXVsdGlwbHkoaW1hZ2VJbmZvLnBoeXNpY2FsUGl4ZWxTaXplKTtcbiAgY29uc3QgbWV0YWRhdGEgPSB7fTtcbiAgbWV0YWRhdGFbXCJEaW1lbnNpb25zXCJdID0ge1xuICAgIC4uLmltYWdlSW5mby5zdWJyZWdpb25TaXplXG4gIH07XG4gIG1ldGFkYXRhW1wiT3JpZ2luYWwgZGltZW5zaW9uc1wiXSA9IHtcbiAgICAuLi5pbWFnZUluZm8ub3JpZ2luYWxTaXplXG4gIH07XG4gIG1ldGFkYXRhW1wiUGh5c2ljYWwgc2l6ZVwiXSA9IHtcbiAgICB4OiBwaHlzaWNhbFNpemUueCArIGltYWdlSW5mby5zcGF0aWFsVW5pdCxcbiAgICB5OiBwaHlzaWNhbFNpemUueSArIGltYWdlSW5mby5zcGF0aWFsVW5pdCxcbiAgICB6OiBwaHlzaWNhbFNpemUueiArIGltYWdlSW5mby5zcGF0aWFsVW5pdFxuICB9O1xuICBtZXRhZGF0YVtcIlBoeXNpY2FsIHNpemUgcGVyIHBpeGVsXCJdID0ge1xuICAgIHg6IGltYWdlSW5mby5waHlzaWNhbFBpeGVsU2l6ZS54ICsgaW1hZ2VJbmZvLnNwYXRpYWxVbml0LFxuICAgIHk6IGltYWdlSW5mby5waHlzaWNhbFBpeGVsU2l6ZS55ICsgaW1hZ2VJbmZvLnNwYXRpYWxVbml0LFxuICAgIHo6IGltYWdlSW5mby5waHlzaWNhbFBpeGVsU2l6ZS56ICsgaW1hZ2VJbmZvLnNwYXRpYWxVbml0XG4gIH07XG4gIG1ldGFkYXRhW1wiQ2hhbm5lbHNcIl0gPSBpbWFnZUluZm8ubnVtQ2hhbm5lbHM7XG4gIG1ldGFkYXRhW1wiVGltZSBzZXJpZXMgZnJhbWVzXCJdID0gaW1hZ2VJbmZvLnRpbWVzIHx8IDE7XG4gIC8vIGRvbid0IGFkZCBVc2VyIGRhdGEgaWYgaXQncyBlbXB0eVxuICBpZiAoaW1hZ2VJbmZvLnVzZXJEYXRhICYmICFpc0VtcHR5KGltYWdlSW5mby51c2VyRGF0YSkpIHtcbiAgICBtZXRhZGF0YVtcIlVzZXIgZGF0YVwiXSA9IGltYWdlSW5mby51c2VyRGF0YTtcbiAgfVxuICByZXR1cm4gbWV0YWRhdGE7XG59Il0sIm5hbWVzIjpbIkJveDMiLCJWZWN0b3IyIiwiVmVjdG9yMyIsIlZvbHVtZUxvYWRFcnJvciIsIlZvbHVtZUxvYWRFcnJvclR5cGUiLCJNQVhfQVRMQVNfRURHRSIsIlVOSVRfU1lNQk9MUyIsImFuZ3N0cm9tIiwiZGF5IiwiZm9vdCIsImhvdXIiLCJpbmNoIiwibWV0ZXIiLCJtaWNyb24iLCJtaWxlIiwibWludXRlIiwicGFyc2VjIiwic2Vjb25kIiwieWFyZCIsIlNJX1VOSVRTIiwiU0lfUFJFRklYX0FCQlZTIiwibWljcm8iLCJkZWNhIiwidW5pdE5hbWVUb1N5bWJvbCIsInVuaXROYW1lIiwidW5kZWZpbmVkIiwicHJlZml4ZWRTSVVuaXQiLCJmaW5kIiwic2lVbml0IiwiZW5kc1dpdGgiLCJwcmVmaXgiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJjYXBpdGFsaXplIiwicHJlZml4QWJiciIsInRvVXBwZXJDYXNlIiwiY29tcHV0ZVBhY2tlZEF0bGFzRGltcyIsInoiLCJ0dyIsInRoIiwibmV4dHJvd3MiLCJuZXh0Y29scyIsInJhdGlvIiwibnJvd3MiLCJuY29scyIsIk1hdGgiLCJjZWlsIiwiZG9lc1NwYXRpYWxEaW1lbnNpb25GaXRJbkF0bGFzIiwic3BhdGlhbERpbVpZWCIsIm1heEF0bGFzRWRnZSIsIngiLCJ5IiwieHRpbGVzIiwiZmxvb3IiLCJ5dGlsZXMiLCJlc3RpbWF0ZUxldmVsRm9yQXRsYXMiLCJzcGF0aWFsRGltc1pZWCIsImkiLCJtYXhDZWlsIiwidmFsIiwibWF4Iiwic2NhbGVEaW1zIiwic2l6ZSIsInNjYWxlRGltc1RvU3VicmVnaW9uIiwic3VicmVnaW9uIiwiZGltcyIsImdldFNpemUiLCJzY2FsZU11bHRpcGxlRGltc1RvU3VicmVnaW9uIiwibWFwIiwiZGltIiwicGlja0xldmVsVG9Mb2FkVW5zY2FsZWQiLCJsb2FkU3BlYyIsImxldmVsVG9Mb2FkIiwic2NhbGVMZXZlbEJpYXMiLCJtdWx0aXNjYWxlTGV2ZWwiLCJtaW4iLCJzbWFsbGVzdERpbXMiLCJjb25zb2xlIiwiZXJyb3IiLCJsb2ciLCJ0eXBlIiwiVE9PX0xBUkdFIiwicGlja0xldmVsVG9Mb2FkIiwic2NhbGVkRGltcyIsImNvbnZlcnRTdWJyZWdpb25Ub1BpeGVscyIsInJlZ2lvbiIsImNsb25lIiwibXVsdGlwbHkiLCJjb21wb3NlU3VicmVnaW9uIiwiY29udGFpbmVyIiwiYWRkIiwiaXNFbXB0eSIsIm9iaiIsImtleSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImJ1aWxkRGVmYXVsdE1ldGFkYXRhIiwiaW1hZ2VJbmZvIiwicGh5c2ljYWxTaXplIiwidm9sdW1lU2l6ZSIsInBoeXNpY2FsUGl4ZWxTaXplIiwibWV0YWRhdGEiLCJzdWJyZWdpb25TaXplIiwib3JpZ2luYWxTaXplIiwic3BhdGlhbFVuaXQiLCJudW1DaGFubmVscyIsInRpbWVzIiwidXNlckRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../volume-viewer/es/loaders/VolumeLoaderUtils.js\n");

/***/ }),

/***/ "../volume-viewer/es/loaders/index.js":
/*!********************************************!*\
  !*** ../volume-viewer/es/loaders/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PrefetchDirection: () => (/* reexport safe */ _zarr_utils_types_js__WEBPACK_IMPORTED_MODULE_4__.PrefetchDirection),\n/* harmony export */   VolumeFileFormat: () => (/* binding */ VolumeFileFormat),\n/* harmony export */   createVolumeLoader: () => (/* binding */ createVolumeLoader),\n/* harmony export */   pathToFileType: () => (/* binding */ pathToFileType)\n/* harmony export */ });\n/* harmony import */ var _OmeZarrLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OmeZarrLoader.js */ \"../volume-viewer/es/loaders/OmeZarrLoader.js\");\n/* harmony import */ var _JsonImageInfoLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./JsonImageInfoLoader.js */ \"../volume-viewer/es/loaders/JsonImageInfoLoader.js\");\n/* harmony import */ var _RawArrayLoader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RawArrayLoader.js */ \"../volume-viewer/es/loaders/RawArrayLoader.js\");\n/* harmony import */ var _TiffLoader_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TiffLoader.js */ \"../volume-viewer/es/loaders/TiffLoader.js\");\n/* harmony import */ var _zarr_utils_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zarr_utils/types.js */ \"../volume-viewer/es/loaders/zarr_utils/types.js\");\n\n\n\n\n\nlet VolumeFileFormat = /*#__PURE__*/function (VolumeFileFormat) {\n  VolumeFileFormat[\"ZARR\"] = \"zarr\";\n  VolumeFileFormat[\"JSON\"] = \"json\";\n  VolumeFileFormat[\"TIFF\"] = \"tiff\";\n  VolumeFileFormat[\"DATA\"] = \"data\";\n  return VolumeFileFormat;\n}({});\n\n// superset of all necessary loader options\n\nfunction pathToFileType(path) {\n  if (path.endsWith(\".json\")) {\n    return VolumeFileFormat.JSON;\n  } else if (path.endsWith(\".tif\") || path.endsWith(\".tiff\")) {\n    return VolumeFileFormat.TIFF;\n  }\n  return VolumeFileFormat.ZARR;\n}\nasync function createVolumeLoader(path, options) {\n  const pathString = Array.isArray(path) ? path[0] : path;\n  const fileType = options?.fileType || pathToFileType(pathString);\n  switch (fileType) {\n    case VolumeFileFormat.ZARR:\n      return await _OmeZarrLoader_js__WEBPACK_IMPORTED_MODULE_0__.OMEZarrLoader.createLoader(path, options?.scene, options?.cache, options?.queue, options?.fetchOptions);\n    case VolumeFileFormat.JSON:\n      return new _JsonImageInfoLoader_js__WEBPACK_IMPORTED_MODULE_1__.JsonImageInfoLoader(path, options?.cache);\n    case VolumeFileFormat.TIFF:\n      return new _TiffLoader_js__WEBPACK_IMPORTED_MODULE_3__.TiffLoader(pathString);\n    case VolumeFileFormat.DATA:\n      if (!options?.rawArrayOptions) {\n        throw new Error(\"Must provide RawArrayOptions for RawArrayLoader\");\n      }\n      return new _RawArrayLoader_js__WEBPACK_IMPORTED_MODULE_2__.RawArrayLoader(options?.rawArrayOptions.data, options?.rawArrayOptions.metadata);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFtRDtBQUNZO0FBQ1Y7QUFDUjtBQUNhO0FBQ25ELElBQUlLLGdCQUFnQixHQUFHLGFBQWEsVUFBVUEsZ0JBQWdCLEVBQUU7RUFDckVBLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU07RUFDakNBLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU07RUFDakNBLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU07RUFDakNBLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU07RUFDakMsT0FBT0EsZ0JBQWdCO0FBQ3pCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7QUFFTDs7QUFFTyxTQUFTQyxjQUFjQSxDQUFDQyxJQUFJLEVBQUU7RUFDbkMsSUFBSUEsSUFBSSxDQUFDQyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDMUIsT0FBT0gsZ0JBQWdCLENBQUNJLElBQUk7RUFDOUIsQ0FBQyxNQUFNLElBQUlGLElBQUksQ0FBQ0MsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJRCxJQUFJLENBQUNDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRTtJQUMxRCxPQUFPSCxnQkFBZ0IsQ0FBQ0ssSUFBSTtFQUM5QjtFQUNBLE9BQU9MLGdCQUFnQixDQUFDTSxJQUFJO0FBQzlCO0FBQ08sZUFBZUMsa0JBQWtCQSxDQUFDTCxJQUFJLEVBQUVNLE9BQU8sRUFBRTtFQUN0RCxNQUFNQyxVQUFVLEdBQUdDLEtBQUssQ0FBQ0MsT0FBTyxDQUFDVCxJQUFJLENBQUMsR0FBR0EsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHQSxJQUFJO0VBQ3ZELE1BQU1VLFFBQVEsR0FBR0osT0FBTyxFQUFFSSxRQUFRLElBQUlYLGNBQWMsQ0FBQ1EsVUFBVSxDQUFDO0VBQ2hFLFFBQVFHLFFBQVE7SUFDZCxLQUFLWixnQkFBZ0IsQ0FBQ00sSUFBSTtNQUN4QixPQUFPLE1BQU1YLDREQUFhLENBQUNrQixZQUFZLENBQUNYLElBQUksRUFBRU0sT0FBTyxFQUFFTSxLQUFLLEVBQUVOLE9BQU8sRUFBRU8sS0FBSyxFQUFFUCxPQUFPLEVBQUVRLEtBQUssRUFBRVIsT0FBTyxFQUFFUyxZQUFZLENBQUM7SUFDdEgsS0FBS2pCLGdCQUFnQixDQUFDSSxJQUFJO01BQ3hCLE9BQU8sSUFBSVIsd0VBQW1CLENBQUNNLElBQUksRUFBRU0sT0FBTyxFQUFFTyxLQUFLLENBQUM7SUFDdEQsS0FBS2YsZ0JBQWdCLENBQUNLLElBQUk7TUFDeEIsT0FBTyxJQUFJUCxzREFBVSxDQUFDVyxVQUFVLENBQUM7SUFDbkMsS0FBS1QsZ0JBQWdCLENBQUNrQixJQUFJO01BQ3hCLElBQUksQ0FBQ1YsT0FBTyxFQUFFVyxlQUFlLEVBQUU7UUFDN0IsTUFBTSxJQUFJQyxLQUFLLENBQUMsaURBQWlELENBQUM7TUFDcEU7TUFDQSxPQUFPLElBQUl2Qiw4REFBYyxDQUFDVyxPQUFPLEVBQUVXLGVBQWUsQ0FBQ0UsSUFBSSxFQUFFYixPQUFPLEVBQUVXLGVBQWUsQ0FBQ0csUUFBUSxDQUFDO0VBQy9GO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4uL3ZvbHVtZS12aWV3ZXIvZXMvbG9hZGVycy9pbmRleC5qcz85ZTFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9NRVphcnJMb2FkZXIgfSBmcm9tIFwiLi9PbWVaYXJyTG9hZGVyLmpzXCI7XG5pbXBvcnQgeyBKc29uSW1hZ2VJbmZvTG9hZGVyIH0gZnJvbSBcIi4vSnNvbkltYWdlSW5mb0xvYWRlci5qc1wiO1xuaW1wb3J0IHsgUmF3QXJyYXlMb2FkZXIgfSBmcm9tIFwiLi9SYXdBcnJheUxvYWRlci5qc1wiO1xuaW1wb3J0IHsgVGlmZkxvYWRlciB9IGZyb20gXCIuL1RpZmZMb2FkZXIuanNcIjtcbmV4cG9ydCB7IFByZWZldGNoRGlyZWN0aW9uIH0gZnJvbSBcIi4vemFycl91dGlscy90eXBlcy5qc1wiO1xuZXhwb3J0IGxldCBWb2x1bWVGaWxlRm9ybWF0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChWb2x1bWVGaWxlRm9ybWF0KSB7XG4gIFZvbHVtZUZpbGVGb3JtYXRbXCJaQVJSXCJdID0gXCJ6YXJyXCI7XG4gIFZvbHVtZUZpbGVGb3JtYXRbXCJKU09OXCJdID0gXCJqc29uXCI7XG4gIFZvbHVtZUZpbGVGb3JtYXRbXCJUSUZGXCJdID0gXCJ0aWZmXCI7XG4gIFZvbHVtZUZpbGVGb3JtYXRbXCJEQVRBXCJdID0gXCJkYXRhXCI7XG4gIHJldHVybiBWb2x1bWVGaWxlRm9ybWF0O1xufSh7fSk7XG5cbi8vIHN1cGVyc2V0IG9mIGFsbCBuZWNlc3NhcnkgbG9hZGVyIG9wdGlvbnNcblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhUb0ZpbGVUeXBlKHBhdGgpIHtcbiAgaWYgKHBhdGguZW5kc1dpdGgoXCIuanNvblwiKSkge1xuICAgIHJldHVybiBWb2x1bWVGaWxlRm9ybWF0LkpTT047XG4gIH0gZWxzZSBpZiAocGF0aC5lbmRzV2l0aChcIi50aWZcIikgfHwgcGF0aC5lbmRzV2l0aChcIi50aWZmXCIpKSB7XG4gICAgcmV0dXJuIFZvbHVtZUZpbGVGb3JtYXQuVElGRjtcbiAgfVxuICByZXR1cm4gVm9sdW1lRmlsZUZvcm1hdC5aQVJSO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVZvbHVtZUxvYWRlcihwYXRoLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhdGhTdHJpbmcgPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aFswXSA6IHBhdGg7XG4gIGNvbnN0IGZpbGVUeXBlID0gb3B0aW9ucz8uZmlsZVR5cGUgfHwgcGF0aFRvRmlsZVR5cGUocGF0aFN0cmluZyk7XG4gIHN3aXRjaCAoZmlsZVR5cGUpIHtcbiAgICBjYXNlIFZvbHVtZUZpbGVGb3JtYXQuWkFSUjpcbiAgICAgIHJldHVybiBhd2FpdCBPTUVaYXJyTG9hZGVyLmNyZWF0ZUxvYWRlcihwYXRoLCBvcHRpb25zPy5zY2VuZSwgb3B0aW9ucz8uY2FjaGUsIG9wdGlvbnM/LnF1ZXVlLCBvcHRpb25zPy5mZXRjaE9wdGlvbnMpO1xuICAgIGNhc2UgVm9sdW1lRmlsZUZvcm1hdC5KU09OOlxuICAgICAgcmV0dXJuIG5ldyBKc29uSW1hZ2VJbmZvTG9hZGVyKHBhdGgsIG9wdGlvbnM/LmNhY2hlKTtcbiAgICBjYXNlIFZvbHVtZUZpbGVGb3JtYXQuVElGRjpcbiAgICAgIHJldHVybiBuZXcgVGlmZkxvYWRlcihwYXRoU3RyaW5nKTtcbiAgICBjYXNlIFZvbHVtZUZpbGVGb3JtYXQuREFUQTpcbiAgICAgIGlmICghb3B0aW9ucz8ucmF3QXJyYXlPcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBSYXdBcnJheU9wdGlvbnMgZm9yIFJhd0FycmF5TG9hZGVyXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYXdBcnJheUxvYWRlcihvcHRpb25zPy5yYXdBcnJheU9wdGlvbnMuZGF0YSwgb3B0aW9ucz8ucmF3QXJyYXlPcHRpb25zLm1ldGFkYXRhKTtcbiAgfVxufSJdLCJuYW1lcyI6WyJPTUVaYXJyTG9hZGVyIiwiSnNvbkltYWdlSW5mb0xvYWRlciIsIlJhd0FycmF5TG9hZGVyIiwiVGlmZkxvYWRlciIsIlByZWZldGNoRGlyZWN0aW9uIiwiVm9sdW1lRmlsZUZvcm1hdCIsInBhdGhUb0ZpbGVUeXBlIiwicGF0aCIsImVuZHNXaXRoIiwiSlNPTiIsIlRJRkYiLCJaQVJSIiwiY3JlYXRlVm9sdW1lTG9hZGVyIiwib3B0aW9ucyIsInBhdGhTdHJpbmciLCJBcnJheSIsImlzQXJyYXkiLCJmaWxlVHlwZSIsImNyZWF0ZUxvYWRlciIsInNjZW5lIiwiY2FjaGUiLCJxdWV1ZSIsImZldGNoT3B0aW9ucyIsIkRBVEEiLCJyYXdBcnJheU9wdGlvbnMiLCJFcnJvciIsImRhdGEiLCJtZXRhZGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../volume-viewer/es/loaders/index.js\n");

/***/ }),

/***/ "../volume-viewer/es/loaders/zarr_utils/ChunkPrefetchIterator.js":
/*!***********************************************************************!*\
  !*** ../volume-viewer/es/loaders/zarr_utils/ChunkPrefetchIterator.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ChunkPrefetchIterator)\n/* harmony export */ });\nconst allEqual = arr => arr.every(v => v === arr[0]);\nconst pushN = (arr, val, n) => {\n  for (let i = 0; i < n; i++) {\n    arr.push(val);\n  }\n};\nconst directionToIndex = dir => {\n  const absDir = dir >> 1; // shave off sign bit to get index in TZYX\n  return absDir + Number(absDir !== 0); // convert TZYX -> TCZYX by skipping c (index 1)\n};\nfunction updateMinMax(val, minmax) {\n  if (val < minmax[0]) {\n    minmax[0] = val;\n  }\n  if (val > minmax[1]) {\n    minmax[1] = val;\n  }\n}\n\n/**\r\n * Since the user is most likely to want nearby data (in space or time) first, we should prefetch those chunks first.\r\n *\r\n * Given a list of just-loaded chunks and some bounds, `ChunkPrefetchIterator` iterates evenly outwards in T/Z/Y/X.\r\n */\n// NOTE: Assumes `chunks` form a rectangular prism! Will create gaps otherwise! (in practice they always should)\nclass ChunkPrefetchIterator {\n  constructor(chunks, tzyxMaxPrefetchOffset, tczyxChunksPerSource, priorityDirections) {\n    // Get min and max chunk coordinates for T/Z/Y/X\n    const extrema = [[Infinity, -Infinity], [Infinity, -Infinity], [Infinity, -Infinity], [Infinity, -Infinity]];\n    for (const chunk of chunks) {\n      updateMinMax(chunk[0], extrema[0]);\n      updateMinMax(chunk[2], extrema[1]);\n      updateMinMax(chunk[3], extrema[2]);\n      updateMinMax(chunk[4], extrema[3]);\n    }\n\n    // Create `PrefetchDirectionState`s for each direction\n    this.directionStates = [];\n    this.priorityDirectionStates = [];\n    for (const [direction, start] of extrema.flat().entries()) {\n      const dimension = direction >> 1; // shave off sign bit to get index in TZYX\n      const tczyxIndex = dimension + Number(dimension !== 0); // convert TZYX -> TCZYX by skipping c (index 1)\n      let end;\n      if (direction & 1) {\n        // Positive direction - end is either the max coordinate in the fetched set plus the max offset in this\n        // dimension, or the max chunk coordinate in this dimension, whichever comes first\n        const endsPerSource = tczyxChunksPerSource.map(chunkDims => {\n          return Math.min(start + tzyxMaxPrefetchOffset[dimension], chunkDims[tczyxIndex] - 1);\n        });\n\n        // Save some time: if all sources have the same end, we can just store that\n        if (allEqual(endsPerSource)) {\n          end = endsPerSource[0];\n        } else {\n          // Otherwise, expand our ends per source array to ends per channel\n          end = [];\n          for (const [i, sourceEnd] of endsPerSource.entries()) {\n            pushN(end, sourceEnd, tczyxChunksPerSource[i][1]);\n          }\n        }\n        // end = Math.min(start + tzyxMaxPrefetchOffset[dimension], tczyxChunksPerDimension[dimension] - 1);\n      } else {\n        // Negative direction - end is either the min coordinate in the fetched set minus the max offset in this\n        // dimension, or 0, whichever comes first\n        end = Math.max(start - tzyxMaxPrefetchOffset[dimension], 0);\n      }\n      const directionState = {\n        direction,\n        start,\n        end,\n        chunks: []\n      };\n      if (priorityDirections && priorityDirections.includes(direction)) {\n        this.priorityDirectionStates.push(directionState);\n      } else {\n        this.directionStates.push(directionState);\n      }\n    }\n\n    // Fill each `PrefetchDirectionState` with chunks at the border of the fetched set\n    for (const chunk of chunks) {\n      for (const dir of this.directionStates) {\n        if (chunk[directionToIndex(dir.direction)] === dir.start) {\n          dir.chunks.push(chunk);\n        }\n      }\n      for (const dir of this.priorityDirectionStates) {\n        if (chunk[directionToIndex(dir.direction)] === dir.start) {\n          dir.chunks.push(chunk);\n        }\n      }\n    }\n  }\n  static *iterateDirections(directions) {\n    let offset = 1;\n    while (directions.length > 0) {\n      // Remove directions in which we have reached the end (or, if per-channel ends, the end for all channels)\n      directions = directions.filter(dir => {\n        const end = Array.isArray(dir.end) ? Math.max(...dir.end) : dir.end;\n        if (dir.direction & 1) {\n          return dir.start + offset <= end;\n        } else {\n          return dir.start - offset >= end;\n        }\n      });\n\n      // Yield chunks one chunk farther out in every remaining direction\n      for (const dir of directions) {\n        const offsetDir = offset * (dir.direction & 1 ? 1 : -1);\n        for (const chunk of dir.chunks) {\n          // Skip this chunk if this channel has a specific per-channel end and we've reached it\n          if (Array.isArray(dir.end) && chunk[directionToIndex(dir.direction)] + offsetDir > dir.end[chunk[1]]) {\n            continue;\n          }\n          const newChunk = chunk.slice();\n          newChunk[directionToIndex(dir.direction)] += offsetDir;\n          yield newChunk;\n        }\n      }\n      offset += 1;\n    }\n  }\n  *[Symbol.iterator]() {\n    // Yield all chunks in priority direction(s) first, if any\n    if (this.priorityDirectionStates.length > 0) {\n      for (const chunk of ChunkPrefetchIterator.iterateDirections(this.priorityDirectionStates)) {\n        yield chunk;\n      }\n    }\n\n    // Then yield all chunks in other directions\n    for (const chunk of ChunkPrefetchIterator.iterateDirections(this.directionStates)) {\n      yield chunk;\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL3phcnJfdXRpbHMvQ2h1bmtQcmVmZXRjaEl0ZXJhdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxRQUFRLEdBQUdDLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxLQUFLLENBQUNDLENBQUMsSUFBSUEsQ0FBQyxLQUFLRixHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEQsTUFBTUcsS0FBSyxHQUFHQSxDQUFDSCxHQUFHLEVBQUVJLEdBQUcsRUFBRUMsQ0FBQyxLQUFLO0VBQzdCLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHRCxDQUFDLEVBQUVDLENBQUMsRUFBRSxFQUFFO0lBQzFCTixHQUFHLENBQUNPLElBQUksQ0FBQ0gsR0FBRyxDQUFDO0VBQ2Y7QUFDRixDQUFDO0FBQ0QsTUFBTUksZ0JBQWdCLEdBQUdDLEdBQUcsSUFBSTtFQUM5QixNQUFNQyxNQUFNLEdBQUdELEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztFQUN6QixPQUFPQyxNQUFNLEdBQUdDLE1BQU0sQ0FBQ0QsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDeEMsQ0FBQztBQUNELFNBQVNFLFlBQVlBLENBQUNSLEdBQUcsRUFBRVMsTUFBTSxFQUFFO0VBQ2pDLElBQUlULEdBQUcsR0FBR1MsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFO0lBQ25CQSxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUdULEdBQUc7RUFDakI7RUFDQSxJQUFJQSxHQUFHLEdBQUdTLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRTtJQUNuQkEsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHVCxHQUFHO0VBQ2pCO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsTUFBTVUscUJBQXFCLENBQUM7RUFDekNDLFdBQVdBLENBQUNDLE1BQU0sRUFBRUMscUJBQXFCLEVBQUVDLG9CQUFvQixFQUFFQyxrQkFBa0Is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dXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL3phcnJfdXRpbHMvQ2h1bmtQcmVmZXRjaEl0ZXJhdG9yLmpzP2IwNDQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYWxsRXF1YWwgPSBhcnIgPT4gYXJyLmV2ZXJ5KHYgPT4gdiA9PT0gYXJyWzBdKTtcbmNvbnN0IHB1c2hOID0gKGFyciwgdmFsLCBuKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgYXJyLnB1c2godmFsKTtcbiAgfVxufTtcbmNvbnN0IGRpcmVjdGlvblRvSW5kZXggPSBkaXIgPT4ge1xuICBjb25zdCBhYnNEaXIgPSBkaXIgPj4gMTsgLy8gc2hhdmUgb2ZmIHNpZ24gYml0IHRvIGdldCBpbmRleCBpbiBUWllYXG4gIHJldHVybiBhYnNEaXIgKyBOdW1iZXIoYWJzRGlyICE9PSAwKTsgLy8gY29udmVydCBUWllYIC0+IFRDWllYIGJ5IHNraXBwaW5nIGMgKGluZGV4IDEpXG59O1xuZnVuY3Rpb24gdXBkYXRlTWluTWF4KHZhbCwgbWlubWF4KSB7XG4gIGlmICh2YWwgPCBtaW5tYXhbMF0pIHtcbiAgICBtaW5tYXhbMF0gPSB2YWw7XG4gIH1cbiAgaWYgKHZhbCA+IG1pbm1heFsxXSkge1xuICAgIG1pbm1heFsxXSA9IHZhbDtcbiAgfVxufVxuXG4vKipcclxuICogU2luY2UgdGhlIHVzZXIgaXMgbW9zdCBsaWtlbHkgdG8gd2FudCBuZWFyYnkgZGF0YSAoaW4gc3BhY2Ugb3IgdGltZSkgZmlyc3QsIHdlIHNob3VsZCBwcmVmZXRjaCB0aG9zZSBjaHVua3MgZmlyc3QuXHJcbiAqXHJcbiAqIEdpdmVuIGEgbGlzdCBvZiBqdXN0LWxvYWRlZCBjaHVua3MgYW5kIHNvbWUgYm91bmRzLCBgQ2h1bmtQcmVmZXRjaEl0ZXJhdG9yYCBpdGVyYXRlcyBldmVubHkgb3V0d2FyZHMgaW4gVC9aL1kvWC5cclxuICovXG4vLyBOT1RFOiBBc3N1bWVzIGBjaHVua3NgIGZvcm0gYSByZWN0YW5ndWxhciBwcmlzbSEgV2lsbCBjcmVhdGUgZ2FwcyBvdGhlcndpc2UhIChpbiBwcmFjdGljZSB0aGV5IGFsd2F5cyBzaG91bGQpXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaHVua1ByZWZldGNoSXRlcmF0b3Ige1xuICBjb25zdHJ1Y3RvcihjaHVua3MsIHR6eXhNYXhQcmVmZXRjaE9mZnNldCwgdGN6eXhDaHVua3NQZXJTb3VyY2UsIHByaW9yaXR5RGlyZWN0aW9ucykge1xuICAgIC8vIEdldCBtaW4gYW5kIG1heCBjaHVuayBjb29yZGluYXRlcyBmb3IgVC9aL1kvWFxuICAgIGNvbnN0IGV4dHJlbWEgPSBbW0luZmluaXR5LCAtSW5maW5pdHldLCBbSW5maW5pdHksIC1JbmZpbml0eV0sIFtJbmZpbml0eSwgLUluZmluaXR5XSwgW0luZmluaXR5LCAtSW5maW5pdHldXTtcbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgdXBkYXRlTWluTWF4KGNodW5rWzBdLCBleHRyZW1hWzBdKTtcbiAgICAgIHVwZGF0ZU1pbk1heChjaHVua1syXSwgZXh0cmVtYVsxXSk7XG4gICAgICB1cGRhdGVNaW5NYXgoY2h1bmtbM10sIGV4dHJlbWFbMl0pO1xuICAgICAgdXBkYXRlTWluTWF4KGNodW5rWzRdLCBleHRyZW1hWzNdKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYFByZWZldGNoRGlyZWN0aW9uU3RhdGVgcyBmb3IgZWFjaCBkaXJlY3Rpb25cbiAgICB0aGlzLmRpcmVjdGlvblN0YXRlcyA9IFtdO1xuICAgIHRoaXMucHJpb3JpdHlEaXJlY3Rpb25TdGF0ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtkaXJlY3Rpb24sIHN0YXJ0XSBvZiBleHRyZW1hLmZsYXQoKS5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IGRpcmVjdGlvbiA+PiAxOyAvLyBzaGF2ZSBvZmYgc2lnbiBiaXQgdG8gZ2V0IGluZGV4IGluIFRaWVhcbiAgICAgIGNvbnN0IHRjenl4SW5kZXggPSBkaW1lbnNpb24gKyBOdW1iZXIoZGltZW5zaW9uICE9PSAwKTsgLy8gY29udmVydCBUWllYIC0+IFRDWllYIGJ5IHNraXBwaW5nIGMgKGluZGV4IDEpXG4gICAgICBsZXQgZW5kO1xuICAgICAgaWYgKGRpcmVjdGlvbiAmIDEpIHtcbiAgICAgICAgLy8gUG9zaXRpdmUgZGlyZWN0aW9uIC0gZW5kIGlzIGVpdGhlciB0aGUgbWF4IGNvb3JkaW5hdGUgaW4gdGhlIGZldGNoZWQgc2V0IHBsdXMgdGhlIG1heCBvZmZzZXQgaW4gdGhpc1xuICAgICAgICAvLyBkaW1lbnNpb24sIG9yIHRoZSBtYXggY2h1bmsgY29vcmRpbmF0ZSBpbiB0aGlzIGRpbWVuc2lvbiwgd2hpY2hldmVyIGNvbWVzIGZpcnN0XG4gICAgICAgIGNvbnN0IGVuZHNQZXJTb3VyY2UgPSB0Y3p5eENodW5rc1BlclNvdXJjZS5tYXAoY2h1bmtEaW1zID0+IHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5taW4oc3RhcnQgKyB0enl4TWF4UHJlZmV0Y2hPZmZzZXRbZGltZW5zaW9uXSwgY2h1bmtEaW1zW3Rjenl4SW5kZXhdIC0gMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNhdmUgc29tZSB0aW1lOiBpZiBhbGwgc291cmNlcyBoYXZlIHRoZSBzYW1lIGVuZCwgd2UgY2FuIGp1c3Qgc3RvcmUgdGhhdFxuICAgICAgICBpZiAoYWxsRXF1YWwoZW5kc1BlclNvdXJjZSkpIHtcbiAgICAgICAgICBlbmQgPSBlbmRzUGVyU291cmNlWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSwgZXhwYW5kIG91ciBlbmRzIHBlciBzb3VyY2UgYXJyYXkgdG8gZW5kcyBwZXIgY2hhbm5lbFxuICAgICAgICAgIGVuZCA9IFtdO1xuICAgICAgICAgIGZvciAoY29uc3QgW2ksIHNvdXJjZUVuZF0gb2YgZW5kc1BlclNvdXJjZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHB1c2hOKGVuZCwgc291cmNlRW5kLCB0Y3p5eENodW5rc1BlclNvdXJjZVtpXVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgdHp5eE1heFByZWZldGNoT2Zmc2V0W2RpbWVuc2lvbl0sIHRjenl4Q2h1bmtzUGVyRGltZW5zaW9uW2RpbWVuc2lvbl0gLSAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5lZ2F0aXZlIGRpcmVjdGlvbiAtIGVuZCBpcyBlaXRoZXIgdGhlIG1pbiBjb29yZGluYXRlIGluIHRoZSBmZXRjaGVkIHNldCBtaW51cyB0aGUgbWF4IG9mZnNldCBpbiB0aGlzXG4gICAgICAgIC8vIGRpbWVuc2lvbiwgb3IgMCwgd2hpY2hldmVyIGNvbWVzIGZpcnN0XG4gICAgICAgIGVuZCA9IE1hdGgubWF4KHN0YXJ0IC0gdHp5eE1heFByZWZldGNoT2Zmc2V0W2RpbWVuc2lvbl0sIDApO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlyZWN0aW9uU3RhdGUgPSB7XG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgY2h1bmtzOiBbXVxuICAgICAgfTtcbiAgICAgIGlmIChwcmlvcml0eURpcmVjdGlvbnMgJiYgcHJpb3JpdHlEaXJlY3Rpb25zLmluY2x1ZGVzKGRpcmVjdGlvbikpIHtcbiAgICAgICAgdGhpcy5wcmlvcml0eURpcmVjdGlvblN0YXRlcy5wdXNoKGRpcmVjdGlvblN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uU3RhdGVzLnB1c2goZGlyZWN0aW9uU3RhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbGwgZWFjaCBgUHJlZmV0Y2hEaXJlY3Rpb25TdGF0ZWAgd2l0aCBjaHVua3MgYXQgdGhlIGJvcmRlciBvZiB0aGUgZmV0Y2hlZCBzZXRcbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgZm9yIChjb25zdCBkaXIgb2YgdGhpcy5kaXJlY3Rpb25TdGF0ZXMpIHtcbiAgICAgICAgaWYgKGNodW5rW2RpcmVjdGlvblRvSW5kZXgoZGlyLmRpcmVjdGlvbildID09PSBkaXIuc3RhcnQpIHtcbiAgICAgICAgICBkaXIuY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGRpciBvZiB0aGlzLnByaW9yaXR5RGlyZWN0aW9uU3RhdGVzKSB7XG4gICAgICAgIGlmIChjaHVua1tkaXJlY3Rpb25Ub0luZGV4KGRpci5kaXJlY3Rpb24pXSA9PT0gZGlyLnN0YXJ0KSB7XG4gICAgICAgICAgZGlyLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgKml0ZXJhdGVEaXJlY3Rpb25zKGRpcmVjdGlvbnMpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMTtcbiAgICB3aGlsZSAoZGlyZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBSZW1vdmUgZGlyZWN0aW9ucyBpbiB3aGljaCB3ZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCAob3IsIGlmIHBlci1jaGFubmVsIGVuZHMsIHRoZSBlbmQgZm9yIGFsbCBjaGFubmVscylcbiAgICAgIGRpcmVjdGlvbnMgPSBkaXJlY3Rpb25zLmZpbHRlcihkaXIgPT4ge1xuICAgICAgICBjb25zdCBlbmQgPSBBcnJheS5pc0FycmF5KGRpci5lbmQpID8gTWF0aC5tYXgoLi4uZGlyLmVuZCkgOiBkaXIuZW5kO1xuICAgICAgICBpZiAoZGlyLmRpcmVjdGlvbiAmIDEpIHtcbiAgICAgICAgICByZXR1cm4gZGlyLnN0YXJ0ICsgb2Zmc2V0IDw9IGVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGlyLnN0YXJ0IC0gb2Zmc2V0ID49IGVuZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFlpZWxkIGNodW5rcyBvbmUgY2h1bmsgZmFydGhlciBvdXQgaW4gZXZlcnkgcmVtYWluaW5nIGRpcmVjdGlvblxuICAgICAgZm9yIChjb25zdCBkaXIgb2YgZGlyZWN0aW9ucykge1xuICAgICAgICBjb25zdCBvZmZzZXREaXIgPSBvZmZzZXQgKiAoZGlyLmRpcmVjdGlvbiAmIDEgPyAxIDogLTEpO1xuICAgICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGRpci5jaHVua3MpIHtcbiAgICAgICAgICAvLyBTa2lwIHRoaXMgY2h1bmsgaWYgdGhpcyBjaGFubmVsIGhhcyBhIHNwZWNpZmljIHBlci1jaGFubmVsIGVuZCBhbmQgd2UndmUgcmVhY2hlZCBpdFxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRpci5lbmQpICYmIGNodW5rW2RpcmVjdGlvblRvSW5kZXgoZGlyLmRpcmVjdGlvbildICsgb2Zmc2V0RGlyID4gZGlyLmVuZFtjaHVua1sxXV0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuZXdDaHVuayA9IGNodW5rLnNsaWNlKCk7XG4gICAgICAgICAgbmV3Q2h1bmtbZGlyZWN0aW9uVG9JbmRleChkaXIuZGlyZWN0aW9uKV0gKz0gb2Zmc2V0RGlyO1xuICAgICAgICAgIHlpZWxkIG5ld0NodW5rO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG4gIH1cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIC8vIFlpZWxkIGFsbCBjaHVua3MgaW4gcHJpb3JpdHkgZGlyZWN0aW9uKHMpIGZpcnN0LCBpZiBhbnlcbiAgICBpZiAodGhpcy5wcmlvcml0eURpcmVjdGlvblN0YXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIENodW5rUHJlZmV0Y2hJdGVyYXRvci5pdGVyYXRlRGlyZWN0aW9ucyh0aGlzLnByaW9yaXR5RGlyZWN0aW9uU3RhdGVzKSkge1xuICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVuIHlpZWxkIGFsbCBjaHVua3MgaW4gb3RoZXIgZGlyZWN0aW9uc1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgQ2h1bmtQcmVmZXRjaEl0ZXJhdG9yLml0ZXJhdGVEaXJlY3Rpb25zKHRoaXMuZGlyZWN0aW9uU3RhdGVzKSkge1xuICAgICAgeWllbGQgY2h1bms7XG4gICAgfVxuICB9XG59Il0sIm5hbWVzIjpbImFsbEVxdWFsIiwiYXJyIiwiZXZlcnkiLCJ2IiwicHVzaE4iLCJ2YWwiLCJuIiwiaSIsInB1c2giLCJkaXJlY3Rpb25Ub0luZGV4IiwiZGlyIiwiYWJzRGlyIiwiTnVtYmVyIiwidXBkYXRlTWluTWF4IiwibWlubWF4IiwiQ2h1bmtQcmVmZXRjaEl0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJjaHVua3MiLCJ0enl4TWF4UHJlZmV0Y2hPZmZzZXQiLCJ0Y3p5eENodW5rc1BlclNvdXJjZSIsInByaW9yaXR5RGlyZWN0aW9ucyIsImV4dHJlbWEiLCJJbmZpbml0eSIsImNodW5rIiwiZGlyZWN0aW9uU3RhdGVzIiwicHJpb3JpdHlEaXJlY3Rpb25TdGF0ZXMiLCJkaXJlY3Rpb24iLCJzdGFydCIsImZsYXQiLCJlbnRyaWVzIiwiZGltZW5zaW9uIiwidGN6eXhJbmRleCIsImVuZCIsImVuZHNQZXJTb3VyY2UiLCJtYXAiLCJjaHVua0RpbXMiLCJNYXRoIiwibWluIiwic291cmNlRW5kIiwibWF4IiwiZGlyZWN0aW9uU3RhdGUiLCJpbmNsdWRlcyIsIml0ZXJhdGVEaXJlY3Rpb25zIiwiZGlyZWN0aW9ucyIsIm9mZnNldCIsImxlbmd0aCIsImZpbHRlciIsIkFycmF5IiwiaXNBcnJheSIsIm9mZnNldERpciIsIm5ld0NodW5rIiwic2xpY2UiLCJTeW1ib2wiLCJpdGVyYXRvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../volume-viewer/es/loaders/zarr_utils/ChunkPrefetchIterator.js\n");

/***/ }),

/***/ "../volume-viewer/es/loaders/zarr_utils/WrappedStore.js":
/*!**************************************************************!*\
  !*** ../volume-viewer/es/loaders/zarr_utils/WrappedStore.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\r\n * `Readable` is zarrita's minimal abstraction for any source of data.\r\n * `WrappedStore` wraps another `Readable` and adds (optional) connections to `VolumeCache` and `RequestQueue`.\r\n */\nclass WrappedStore {\n  constructor(baseStore, cache, queue) {\n    this.baseStore = baseStore;\n    this.cache = cache;\n    this.queue = queue;\n  }\n  // Dummy implementation to make this class easier to use in tests\n  set(_key, _value) {\n    return Promise.resolve();\n  }\n  async getAndCache(key, cacheKey, opts) {\n    const result = await this.baseStore.get(key, opts);\n    if (this.cache && result) {\n      this.cache.insert(cacheKey, result);\n    }\n    return result;\n  }\n  async get(key, opts) {\n    const ZARR_EXTS = [\".zarray\", \".zgroup\", \".zattrs\", \"zarr.json\"];\n    if (!this.cache || ZARR_EXTS.some(s => key.endsWith(s))) {\n      return this.baseStore.get(key, opts?.options);\n    }\n    if (opts?.reportKey) {\n      opts.reportKey(key, opts.subscriber);\n    }\n    let keyPrefix = this.baseStore.url ?? \"\";\n    if (keyPrefix !== \"\" && !(keyPrefix instanceof URL) && !keyPrefix.endsWith(\"/\")) {\n      keyPrefix += \"/\";\n    }\n    const fullKey = keyPrefix + key.slice(1);\n\n    // Check the cache\n    const cacheResult = this.cache.get(fullKey);\n    if (cacheResult) {\n      return new Uint8Array(cacheResult);\n    }\n\n    // Not in cache; load the chunk and cache it\n    if (this.queue && opts) {\n      return this.queue.addRequest(fullKey, opts.subscriber, () => this.getAndCache(key, fullKey, opts?.options), opts.isPrefetch);\n    } else {\n      // Should we ever hit this code?  We should always have a request queue.\n      return this.getAndCache(key, fullKey, opts?.options);\n    }\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WrappedStore);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL3phcnJfdXRpbHMvV3JhcHBlZFN0b3JlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1BLFlBQVksQ0FBQztFQUNqQkMsV0FBV0EsQ0FBQ0MsU0FBUyxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRTtJQUNuQyxJQUFJLENBQUNGLFNBQVMsR0FBR0EsU0FBUztJQUMxQixJQUFJLENBQUNDLEtBQUssR0FBR0EsS0FBSztJQUNsQixJQUFJLENBQUNDLEtBQUssR0FBR0EsS0FBSztFQUNwQjtFQUNBO0VBQ0FDLEdBQUdBLENBQUNDLElBQUksRUFBRUMsTUFBTSxFQUFFO0lBQ2hCLE9BQU9DLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLENBQUM7RUFDMUI7RUFDQSxNQUFNQyxXQUFXQSxDQUFDQyxHQUFHLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUFFO0lBQ3JDLE1BQU1DLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQ1osU0FBUyxDQUFDYSxHQUFHLENBQUNKLEdBQUcsRUFBRUUsSUFBSSxDQUFDO0lBQ2xELElBQUksSUFBSSxDQUFDVixLQUFLLElBQUlXLE1BQU0sRUFBRTtNQUN4QixJQUFJLENBQUNYLEtBQUssQ0FBQ2EsTUFBTSxDQUFDSixRQUFRLEVBQUVFLE1BQU0sQ0FBQztJQUNyQztJQUNBLE9BQU9BLE1BQU07RUFDZjtFQUNBLE1BQU1DLEdBQUdBLENBQUNKLEdBQUcsRUFBRUUsSUFBSSxFQUFFO0lBQ25CLE1BQU1JLFNBQVMsR0FBRyxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFdBQVcsQ0FBQztJQUNoRSxJQUFJLENBQUMsSUFBSSxDQUFDZCxLQUFLLElBQUljLFNBQVMsQ0FBQ0MsSUFBSSxDQUFDQyxDQUFDLElBQUlSLEdBQUcsQ0FBQ1MsUUFBUSxDQUFDRCxDQUFDLENBQUMsQ0FBQyxFQUFFO01BQ3ZELE9BQU8sSUFBSSxDQUFDakIsU0FBUyxDQUFDYSxHQUFHLENBQUNKLEdBQUcsRUFBRUUsSUFBSSxFQUFFUSxPQUFPLENBQUM7SUFDL0M7SUFDQSxJQUFJUixJQUFJLEVBQUVTLFNBQVMsRUFBRTtNQUNuQlQsSUFBSSxDQUFDUyxTQUFTLENBQUNYLEdBQUcsRUFBRUUsSUFBSSxDQUFDVSxVQUFVLENBQUM7SUFDdEM7SUFDQSxJQUFJQyxTQUFTLEdBQUcsSUFBSSxDQUFDdEIsU0FBUyxDQUFDdUIsR0FBRyxJQUFJLEVBQUU7SUFDeEMsSUFBSUQsU0FBUyxLQUFLLEVBQUUsSUFBSSxFQUFFQSxTQUFTLFlBQVlFLEdBQUcsQ0FBQyxJQUFJLENBQUNGLFNBQVMsQ0FBQ0osUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO01BQy9FSSxTQUFTLElBQUksR0FBRztJQUNsQjtJQUNBLE1BQU1HLE9BQU8sR0FBR0gsU0FBUyxHQUFHYixHQUFHLENBQUNpQixLQUFLLENBQUMsQ0FBQyxDQUFDOztJQUV4QztJQUNBLE1BQU1DLFdBQVcsR0FBRyxJQUFJLENBQUMxQixLQUFLLENBQUNZLEdBQUcsQ0FBQ1ksT0FBTyxDQUFDO0lBQzNDLElBQUlFLFdBQVcsRUFBRTtNQUNmLE9BQU8sSUFBSUMsVUFBVSxDQUFDRCxXQUFXLENBQUM7SUFDcEM7O0lBRUE7SUFDQSxJQUFJLElBQUksQ0FBQ3pCLEtBQUssSUFBSVMsSUFBSSxFQUFFO01BQ3RCLE9BQU8sSUFBSSxDQUFDVCxLQUFLLENBQUMyQixVQUFVLENBQUNKLE9BQU8sRUFBRWQsSUFBSSxDQUFDVSxVQUFVLEVBQUUsTUFBTSxJQUFJLENBQUNiLFdBQVcsQ0FBQ0MsR0FBRyxFQUFFZ0IsT0FBTyxFQUFFZCxJQUFJLEVBQUVRLE9BQU8sQ0FBQyxFQUFFUixJQUFJLENBQUNtQixVQUFVLENBQUM7SUFDOUgsQ0FBQyxNQUFNO01BQ0w7TUFDQSxPQUFPLElBQUksQ0FBQ3RCLFdBQVcsQ0FBQ0MsR0FBRyxFQUFFZ0IsT0FBTyxFQUFFZCxJQUFJLEVBQUVRLE9BQU8sQ0FBQztJQUN0RDtFQUNGO0FBQ0Y7QUFDQSxpRUFBZXJCLFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4uL3ZvbHVtZS12aWV3ZXIvZXMvbG9hZGVycy96YXJyX3V0aWxzL1dyYXBwZWRTdG9yZS5qcz85YzFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBgUmVhZGFibGVgIGlzIHphcnJpdGEncyBtaW5pbWFsIGFic3RyYWN0aW9uIGZvciBhbnkgc291cmNlIG9mIGRhdGEuXHJcbiAqIGBXcmFwcGVkU3RvcmVgIHdyYXBzIGFub3RoZXIgYFJlYWRhYmxlYCBhbmQgYWRkcyAob3B0aW9uYWwpIGNvbm5lY3Rpb25zIHRvIGBWb2x1bWVDYWNoZWAgYW5kIGBSZXF1ZXN0UXVldWVgLlxyXG4gKi9cbmNsYXNzIFdyYXBwZWRTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKGJhc2VTdG9yZSwgY2FjaGUsIHF1ZXVlKSB7XG4gICAgdGhpcy5iYXNlU3RvcmUgPSBiYXNlU3RvcmU7XG4gICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xuICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgfVxuICAvLyBEdW1teSBpbXBsZW1lbnRhdGlvbiB0byBtYWtlIHRoaXMgY2xhc3MgZWFzaWVyIHRvIHVzZSBpbiB0ZXN0c1xuICBzZXQoX2tleSwgX3ZhbHVlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIGFzeW5jIGdldEFuZENhY2hlKGtleSwgY2FjaGVLZXksIG9wdHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmJhc2VTdG9yZS5nZXQoa2V5LCBvcHRzKTtcbiAgICBpZiAodGhpcy5jYWNoZSAmJiByZXN1bHQpIHtcbiAgICAgIHRoaXMuY2FjaGUuaW5zZXJ0KGNhY2hlS2V5LCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGdldChrZXksIG9wdHMpIHtcbiAgICBjb25zdCBaQVJSX0VYVFMgPSBbXCIuemFycmF5XCIsIFwiLnpncm91cFwiLCBcIi56YXR0cnNcIiwgXCJ6YXJyLmpzb25cIl07XG4gICAgaWYgKCF0aGlzLmNhY2hlIHx8IFpBUlJfRVhUUy5zb21lKHMgPT4ga2V5LmVuZHNXaXRoKHMpKSkge1xuICAgICAgcmV0dXJuIHRoaXMuYmFzZVN0b3JlLmdldChrZXksIG9wdHM/Lm9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAob3B0cz8ucmVwb3J0S2V5KSB7XG4gICAgICBvcHRzLnJlcG9ydEtleShrZXksIG9wdHMuc3Vic2NyaWJlcik7XG4gICAgfVxuICAgIGxldCBrZXlQcmVmaXggPSB0aGlzLmJhc2VTdG9yZS51cmwgPz8gXCJcIjtcbiAgICBpZiAoa2V5UHJlZml4ICE9PSBcIlwiICYmICEoa2V5UHJlZml4IGluc3RhbmNlb2YgVVJMKSAmJiAha2V5UHJlZml4LmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAga2V5UHJlZml4ICs9IFwiL1wiO1xuICAgIH1cbiAgICBjb25zdCBmdWxsS2V5ID0ga2V5UHJlZml4ICsga2V5LnNsaWNlKDEpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGNhY2hlXG4gICAgY29uc3QgY2FjaGVSZXN1bHQgPSB0aGlzLmNhY2hlLmdldChmdWxsS2V5KTtcbiAgICBpZiAoY2FjaGVSZXN1bHQpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShjYWNoZVJlc3VsdCk7XG4gICAgfVxuXG4gICAgLy8gTm90IGluIGNhY2hlOyBsb2FkIHRoZSBjaHVuayBhbmQgY2FjaGUgaXRcbiAgICBpZiAodGhpcy5xdWV1ZSAmJiBvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWV1ZS5hZGRSZXF1ZXN0KGZ1bGxLZXksIG9wdHMuc3Vic2NyaWJlciwgKCkgPT4gdGhpcy5nZXRBbmRDYWNoZShrZXksIGZ1bGxLZXksIG9wdHM/Lm9wdGlvbnMpLCBvcHRzLmlzUHJlZmV0Y2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTaG91bGQgd2UgZXZlciBoaXQgdGhpcyBjb2RlPyAgV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgcmVxdWVzdCBxdWV1ZS5cbiAgICAgIHJldHVybiB0aGlzLmdldEFuZENhY2hlKGtleSwgZnVsbEtleSwgb3B0cz8ub3B0aW9ucyk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkU3RvcmU7Il0sIm5hbWVzIjpbIldyYXBwZWRTdG9yZSIsImNvbnN0cnVjdG9yIiwiYmFzZVN0b3JlIiwiY2FjaGUiLCJxdWV1ZSIsInNldCIsIl9rZXkiLCJfdmFsdWUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImdldEFuZENhY2hlIiwia2V5IiwiY2FjaGVLZXkiLCJvcHRzIiwicmVzdWx0IiwiZ2V0IiwiaW5zZXJ0IiwiWkFSUl9FWFRTIiwic29tZSIsInMiLCJlbmRzV2l0aCIsIm9wdGlvbnMiLCJyZXBvcnRLZXkiLCJzdWJzY3JpYmVyIiwia2V5UHJlZml4IiwidXJsIiwiVVJMIiwiZnVsbEtleSIsInNsaWNlIiwiY2FjaGVSZXN1bHQiLCJVaW50OEFycmF5IiwiYWRkUmVxdWVzdCIsImlzUHJlZmV0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../volume-viewer/es/loaders/zarr_utils/WrappedStore.js\n");

/***/ }),

/***/ "../volume-viewer/es/loaders/zarr_utils/types.js":
/*!*******************************************************!*\
  !*** ../volume-viewer/es/loaders/zarr_utils/types.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PrefetchDirection: () => (/* binding */ PrefetchDirection)\n/* harmony export */ });\n/**\r\n * Directions in which to move outward from the loaded set of chunks while prefetching.\r\n *\r\n * Ordered in pairs of opposite directions both because that's a sensible order in which to prefetch for our purposes,\r\n * and because it lets us treat the least significant bit as the sign. So `direction >> 1` gives the index of the\r\n * direction in TZYX-ordered arrays, and `direction & 1` gives the sign of the direction (e.g. positive vs negative Z).\r\n */\nlet PrefetchDirection = /*#__PURE__*/function (PrefetchDirection) {\n  PrefetchDirection[PrefetchDirection[\"T_MINUS\"] = 0] = \"T_MINUS\";\n  PrefetchDirection[PrefetchDirection[\"T_PLUS\"] = 1] = \"T_PLUS\";\n  PrefetchDirection[PrefetchDirection[\"Z_MINUS\"] = 2] = \"Z_MINUS\";\n  PrefetchDirection[PrefetchDirection[\"Z_PLUS\"] = 3] = \"Z_PLUS\";\n  PrefetchDirection[PrefetchDirection[\"Y_MINUS\"] = 4] = \"Y_MINUS\";\n  PrefetchDirection[PrefetchDirection[\"Y_PLUS\"] = 5] = \"Y_PLUS\";\n  PrefetchDirection[PrefetchDirection[\"X_MINUS\"] = 6] = \"X_MINUS\";\n  PrefetchDirection[PrefetchDirection[\"X_PLUS\"] = 7] = \"X_PLUS\";\n  return PrefetchDirection;\n}({});\n\n/** https://ngff.openmicroscopy.org/latest/#multiscale-md */\n\n/** https://ngff.openmicroscopy.org/latest/#omero-md */\n\n/** A record with everything we need to access and use a single remote source of multiscale OME-Zarr data. *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL3phcnJfdXRpbHMvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBSUEsaUJBQWlCLEdBQUcsYUFBYSxVQUFVQSxpQkFBaUIsRUFBRTtFQUN2RUEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFNBQVM7RUFDL0RBLGlCQUFpQixDQUFDQSxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxRQUFRO0VBQzdEQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsU0FBUztFQUMvREEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFFBQVE7RUFDN0RBLGlCQUFpQixDQUFDQSxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTO0VBQy9EQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsUUFBUTtFQUM3REEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFNBQVM7RUFDL0RBLGlCQUFpQixDQUFDQSxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxRQUFRO0VBQzdELE9BQU9BLGlCQUFpQjtBQUMxQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7O0FBRUw7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4uL3ZvbHVtZS12aWV3ZXIvZXMvbG9hZGVycy96YXJyX3V0aWxzL3R5cGVzLmpzPzNkMmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERpcmVjdGlvbnMgaW4gd2hpY2ggdG8gbW92ZSBvdXR3YXJkIGZyb20gdGhlIGxvYWRlZCBzZXQgb2YgY2h1bmtzIHdoaWxlIHByZWZldGNoaW5nLlxyXG4gKlxyXG4gKiBPcmRlcmVkIGluIHBhaXJzIG9mIG9wcG9zaXRlIGRpcmVjdGlvbnMgYm90aCBiZWNhdXNlIHRoYXQncyBhIHNlbnNpYmxlIG9yZGVyIGluIHdoaWNoIHRvIHByZWZldGNoIGZvciBvdXIgcHVycG9zZXMsXHJcbiAqIGFuZCBiZWNhdXNlIGl0IGxldHMgdXMgdHJlYXQgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBhcyB0aGUgc2lnbi4gU28gYGRpcmVjdGlvbiA+PiAxYCBnaXZlcyB0aGUgaW5kZXggb2YgdGhlXHJcbiAqIGRpcmVjdGlvbiBpbiBUWllYLW9yZGVyZWQgYXJyYXlzLCBhbmQgYGRpcmVjdGlvbiAmIDFgIGdpdmVzIHRoZSBzaWduIG9mIHRoZSBkaXJlY3Rpb24gKGUuZy4gcG9zaXRpdmUgdnMgbmVnYXRpdmUgWikuXHJcbiAqL1xuZXhwb3J0IGxldCBQcmVmZXRjaERpcmVjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoUHJlZmV0Y2hEaXJlY3Rpb24pIHtcbiAgUHJlZmV0Y2hEaXJlY3Rpb25bUHJlZmV0Y2hEaXJlY3Rpb25bXCJUX01JTlVTXCJdID0gMF0gPSBcIlRfTUlOVVNcIjtcbiAgUHJlZmV0Y2hEaXJlY3Rpb25bUHJlZmV0Y2hEaXJlY3Rpb25bXCJUX1BMVVNcIl0gPSAxXSA9IFwiVF9QTFVTXCI7XG4gIFByZWZldGNoRGlyZWN0aW9uW1ByZWZldGNoRGlyZWN0aW9uW1wiWl9NSU5VU1wiXSA9IDJdID0gXCJaX01JTlVTXCI7XG4gIFByZWZldGNoRGlyZWN0aW9uW1ByZWZldGNoRGlyZWN0aW9uW1wiWl9QTFVTXCJdID0gM10gPSBcIlpfUExVU1wiO1xuICBQcmVmZXRjaERpcmVjdGlvbltQcmVmZXRjaERpcmVjdGlvbltcIllfTUlOVVNcIl0gPSA0XSA9IFwiWV9NSU5VU1wiO1xuICBQcmVmZXRjaERpcmVjdGlvbltQcmVmZXRjaERpcmVjdGlvbltcIllfUExVU1wiXSA9IDVdID0gXCJZX1BMVVNcIjtcbiAgUHJlZmV0Y2hEaXJlY3Rpb25bUHJlZmV0Y2hEaXJlY3Rpb25bXCJYX01JTlVTXCJdID0gNl0gPSBcIlhfTUlOVVNcIjtcbiAgUHJlZmV0Y2hEaXJlY3Rpb25bUHJlZmV0Y2hEaXJlY3Rpb25bXCJYX1BMVVNcIl0gPSA3XSA9IFwiWF9QTFVTXCI7XG4gIHJldHVybiBQcmVmZXRjaERpcmVjdGlvbjtcbn0oe30pO1xuXG4vKiogaHR0cHM6Ly9uZ2ZmLm9wZW5taWNyb3Njb3B5Lm9yZy9sYXRlc3QvI211bHRpc2NhbGUtbWQgKi9cblxuLyoqIGh0dHBzOi8vbmdmZi5vcGVubWljcm9zY29weS5vcmcvbGF0ZXN0LyNvbWVyby1tZCAqL1xuXG4vKiogQSByZWNvcmQgd2l0aCBldmVyeXRoaW5nIHdlIG5lZWQgdG8gYWNjZXNzIGFuZCB1c2UgYSBzaW5nbGUgcmVtb3RlIHNvdXJjZSBvZiBtdWx0aXNjYWxlIE9NRS1aYXJyIGRhdGEuICovIl0sIm5hbWVzIjpbIlByZWZldGNoRGlyZWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../volume-viewer/es/loaders/zarr_utils/types.js\n");

/***/ }),

/***/ "../volume-viewer/es/loaders/zarr_utils/utils.js":
/*!*******************************************************!*\
  !*** ../volume-viewer/es/loaders/zarr_utils/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDimensionCount: () => (/* binding */ getDimensionCount),\n/* harmony export */   getScale: () => (/* binding */ getScale),\n/* harmony export */   getSourceChannelNames: () => (/* binding */ getSourceChannelNames),\n/* harmony export */   matchSourceScaleLevels: () => (/* binding */ matchSourceScaleLevels),\n/* harmony export */   orderByDimension: () => (/* binding */ orderByDimension),\n/* harmony export */   orderByTCZYX: () => (/* binding */ orderByTCZYX),\n/* harmony export */   remapAxesToTCZYX: () => (/* binding */ remapAxesToTCZYX)\n/* harmony export */ });\n/* harmony import */ var _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VolumeLoadError.js */ \"../volume-viewer/es/loaders/VolumeLoadError.js\");\n\n/** Extracts channel names from a `ZarrSource`. Handles missing `omeroMetadata`. Does *not* resolve name collisions. */\nfunction getSourceChannelNames(src) {\n  if (src.omeroMetadata?.channels) {\n    return src.omeroMetadata.channels.map(({\n      label\n    }, idx) => label ?? `Channel ${idx + src.channelOffset}`);\n  }\n  const length = src.scaleLevels[0].shape[src.axesTCZYX[1]];\n  return Array.from({\n    length\n  }, (_, idx) => `Channel ${idx + src.channelOffset}`);\n}\n\n/** Turns `axesTCZYX` into the number of dimensions in the array */\nconst getDimensionCount = ([t, c, z]) => 2 + Number(t > -1) + Number(c > -1) + Number(z > -1);\nfunction remapAxesToTCZYX(axes) {\n  const axesTCZYX = [-1, -1, -1, -1, -1];\n  const axisNames = [\"t\", \"c\", \"z\", \"y\", \"x\"];\n  axes.forEach((axis, idx) => {\n    const axisIdx = axisNames.indexOf(axis.name);\n    if (axisIdx > -1) {\n      axesTCZYX[axisIdx] = idx;\n    } else {\n      throw new _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadError(`Unrecognized axis in zarr: ${axis.name}`, {\n        type: _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadErrorType.INVALID_METADATA\n      });\n    }\n  });\n\n  // it is possible that Z might not exist but we require X and Y at least.\n  const noXAxis = axesTCZYX[4] === -1;\n  if (noXAxis || axesTCZYX[3] === -1) {\n    throw new _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadError(`Did not find ${noXAxis ? \"an X\" : \"a Y\"} axis in zarr`, {\n      type: _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadErrorType.INVALID_METADATA\n    });\n  }\n  return axesTCZYX;\n}\n\n/** Reorder an array of values [T, C, Z, Y, X] to the given dimension order */\nfunction orderByDimension(valsTCZYX, orderTCZYX) {\n  const specLen = getDimensionCount(orderTCZYX);\n  const result = Array(specLen);\n  orderTCZYX.forEach((val, idx) => {\n    if (val >= 0) {\n      if (val >= specLen) {\n        throw new _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadError(`Unexpected axis index in zarr: ${val}`, {\n          type: _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadErrorType.INVALID_METADATA\n        });\n      }\n      result[val] = valsTCZYX[idx];\n    }\n  });\n  return result;\n}\n\n/** Reorder an array of values in the given dimension order to [T, C, Z, Y, X] */\nfunction orderByTCZYX(valsDimension, orderTCZYX, defaultValue) {\n  const result = [defaultValue, defaultValue, defaultValue, defaultValue, defaultValue];\n  orderTCZYX.forEach((val, idx) => {\n    if (val >= 0) {\n      if (val >= valsDimension.length) {\n        throw new _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadError(`Unexpected axis index in zarr: ${val}`, {\n          type: _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadErrorType.INVALID_METADATA\n        });\n      }\n      result[idx] = valsDimension[val];\n    }\n  });\n  return result;\n}\n\n/** Select the scale transform from an OME metadata object with coordinate transforms, and return it in TCZYX order */\nfunction getScale(dataset, orderTCZYX) {\n  const transforms = dataset.coordinateTransformations;\n  if (transforms === undefined) {\n    console.warn(\"WARNING: OMEZarrLoader: no coordinate transformations for scale level.\");\n    return [1, 1, 1, 1, 1];\n  }\n\n  // this assumes we'll never encounter the \"path\" variant\n  const isScaleTransform = t => t.type === \"scale\";\n\n  // there can be any number of coordinateTransformations\n  // but there must be only one of type \"scale\".\n  const scaleTransform = transforms.find(isScaleTransform);\n  if (!scaleTransform) {\n    console.warn(`WARNING: OMEZarrLoader: no coordinate transformation of type \"scale\" for scale level.`);\n    return [1, 1, 1, 1, 1];\n  }\n  const scale = scaleTransform.scale.slice();\n  return orderByTCZYX(scale, orderTCZYX, 1);\n}\n\n/**\r\n * Defines a partial order of zarr arrays based on their size. Specifically:\r\n * - If array size x, y, z are all equal, the arrays are equal\r\n * - otherwise, if all xyz of `a` are less than or equal to those of `b`, `a` is less than `b` (and vice versa)\r\n * - if some xyz is less and some is greater, the arrays are uncomparable\r\n */\nfunction compareZarrArraySize(aArr, aTCZYX, bArr, bTCZYX) {\n  const aZ = aTCZYX[2] > -1 ? aArr.shape[aTCZYX[2]] : 1;\n  const bZ = bTCZYX[2] > -1 ? bArr.shape[bTCZYX[2]] : 1;\n  const diffZ = aZ - bZ;\n  const diffY = aArr.shape[aTCZYX[3]] - bArr.shape[bTCZYX[3]];\n  const diffX = aArr.shape[aTCZYX[4]] - bArr.shape[bTCZYX[4]];\n  if (diffZ === 0 && diffY === 0 && diffX === 0) {\n    return 0;\n  } else if (diffZ <= 0 && diffY <= 0 && diffX <= 0) {\n    return -1;\n  } else if (diffZ >= 0 && diffY >= 0 && diffX >= 0) {\n    return 1;\n  } else {\n    return undefined;\n  }\n}\nconst EPSILON = 0.00001;\nconst aboutEquals = (a, b) => Math.abs(a - b) < EPSILON;\nfunction scaleTransformsAreEqual(aSrc, aLevel, bSrc, bLevel) {\n  const aScale = getScale(aSrc.multiscaleMetadata.datasets[aLevel], aSrc.axesTCZYX);\n  const bScale = getScale(bSrc.multiscaleMetadata.datasets[bLevel], bSrc.axesTCZYX);\n  return aboutEquals(aScale[2], bScale[2]) && aboutEquals(aScale[3], bScale[3]) && aboutEquals(aScale[4], bScale[4]);\n}\n\n/**\r\n * Ensures that all scale levels in `sources` are matched up by size. More precisely: enforces that, for any scale\r\n * level `i`, the size of zarr array `s[i]` is equal for every source `s`. We accomplish this by removing any arrays\r\n * (and their associated OME dataset metadata) which don't match up in all sources.\r\n *\r\n * Note that this function modifies the input `sources` array rather than returning a new value.\r\n *\r\n * Assumes all sources have scale levels ordered by size from largest to smallest. (This should always be true for\r\n * compliant OME-Zarr data.)\r\n */\nfunction matchSourceScaleLevels(sources) {\n  if (sources.length < 2) {\n    return;\n  }\n\n  // Save matching scale levels and metadata here\n  const matchedLevels = Array.from({\n    length: sources.length\n  }, () => []);\n  const matchedMetas = Array.from({\n    length: sources.length\n  }, () => []);\n\n  // Start as many index counters as we have sources\n  const scaleIndexes = new Array(sources.length).fill(0);\n  while (scaleIndexes.every((val, idx) => val < sources[idx].scaleLevels.length)) {\n    // First pass: find the smallest source / determine if all sources are equal\n    let allEqual = true;\n    let smallestIdx = 0;\n    let smallestSrc = sources[0];\n    let smallestArr = smallestSrc.scaleLevels[scaleIndexes[0]];\n    for (let currentIdx = 1; currentIdx < sources.length; currentIdx++) {\n      const currentSrc = sources[currentIdx];\n      const currentArr = currentSrc.scaleLevels[scaleIndexes[currentIdx]];\n      const ordering = compareZarrArraySize(smallestArr, smallestSrc.axesTCZYX, currentArr, currentSrc.axesTCZYX);\n      if (!ordering) {\n        // Arrays are equal, or they are uncomparable\n        if (ordering === undefined) {\n          throw new _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadError(\"Incompatible zarr arrays: pixel dimensions are mismatched\", {\n            type: _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadErrorType.INVALID_MULTI_SOURCE_ZARR\n          });\n        }\n\n        // Now we know the arrays are equal, but they may still be invalid to match up because...\n        // ...they have different scale transformations\n        if (!scaleTransformsAreEqual(smallestSrc, scaleIndexes[smallestIdx], currentSrc, scaleIndexes[currentIdx])) {\n          // today we are going to treat this as a warning.\n          // For our implementation it is enough that the xyz pixel ranges are the same.\n          // Ideally scale*arraysize=physical size is really the quantity that should be equal, for combining two volume data sets as channels.\n          console.warn(\"Incompatible zarr arrays: scale levels of equal size have different scale transformations\");\n        }\n\n        // ...they have different numbers of timesteps\n        const largestT = smallestSrc.axesTCZYX[0] > -1 ? smallestArr.shape[smallestSrc.axesTCZYX[0]] : 1;\n        const currentT = currentSrc.axesTCZYX[0] > -1 ? currentArr.shape[currentSrc.axesTCZYX[0]] : 1;\n        if (largestT !== currentT) {\n          // we also treat this as a warning.\n          // In OmeZarrLoader we will take the minimum T size of all sources\n          console.warn(`Incompatible zarr arrays: different numbers of timesteps: ${largestT} vs ${currentT}`);\n        }\n      } else {\n        allEqual = false;\n        if (ordering > 0) {\n          smallestIdx = currentIdx;\n          smallestSrc = currentSrc;\n          smallestArr = currentArr;\n        }\n      }\n    }\n    if (allEqual) {\n      // We've found a matching set of scale levels! Save it and increment all indexes\n      for (let i = 0; i < scaleIndexes.length; i++) {\n        const currentSrc = sources[i];\n        const matchedScaleLevel = scaleIndexes[i];\n        matchedLevels[i].push(currentSrc.scaleLevels[matchedScaleLevel]);\n        matchedMetas[i].push(currentSrc.multiscaleMetadata.datasets[matchedScaleLevel]);\n        scaleIndexes[i] += 1;\n      }\n    } else {\n      // Increment the indexes of the sources which are larger than the smallest\n      for (const [idx, srcIdx] of scaleIndexes.entries()) {\n        const currentSrc = sources[idx];\n        const currentArr = currentSrc.scaleLevels[srcIdx];\n        const ordering = compareZarrArraySize(smallestArr, smallestSrc.axesTCZYX, currentArr, currentSrc.axesTCZYX);\n        if (ordering !== 0) {\n          scaleIndexes[idx] += 1;\n        }\n      }\n    }\n  }\n  if (sources[0].scaleLevels.length === 0) {\n    throw new _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadError(\"Incompatible zarr arrays: no sets of scale levels found that matched in all sources\", {\n      type: _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadErrorType.INVALID_MULTI_SOURCE_ZARR\n    });\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].scaleLevels = matchedLevels[i];\n    sources[i].multiscaleMetadata.datasets = matchedMetas[i];\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL3phcnJfdXRpbHMvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBNkU7QUFDN0U7QUFDTyxTQUFTRSxxQkFBcUJBLENBQUNDLEdBQUcsRUFBRTtFQUN6QyxJQUFJQSxHQUFHLENBQUNDLGFBQWEsRUFBRUMsUUFBUSxFQUFFO0lBQy9CLE9BQU9GLEdBQUcsQ0FBQ0MsYUFBYSxDQUFDQyxRQUFRLENBQUNDLEdBQUcsQ0FBQyxDQUFDO01BQ3JDQztJQUNGLENBQUMsRUFBRUMsR0FBRyxLQUFLRCxLQUFLLElBQUssV0FBVUMsR0FBRyxHQUFHTCxHQUFHLENBQUNNLGFBQWMsRUFBQyxDQUFDO0VBQzNEO0VBQ0EsTUFBTUMsTUFBTSxHQUFHUCxHQUFHLENBQUNRLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQ0MsS0FBSyxDQUFDVCxHQUFHLENBQUNVLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUN6RCxPQUFPQyxLQUFLLENBQUNDLElBQUksQ0FBQztJQUNoQkw7RUFDRixDQUFDLEVBQUUsQ0FBQ00sQ0FBQyxFQUFFUixHQUFHLEtBQU0sV0FBVUEsR0FBRyxHQUFHTCxHQUFHLENBQUNNLGFBQWMsRUFBQyxDQUFDO0FBQ3REOztBQUVBO0FBQ08sTUFBTVEsaUJBQWlCLEdBQUdBLENBQUMsQ0FBQ0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBR0MsTUFBTSxDQUFDSCxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBR0csTUFBTSxDQUFDRixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBR0UsTUFBTSxDQUFDRCxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDN0YsU0FBU0UsZ0JBQWdCQSxDQUFDQyxJQUFJLEVBQUU7RUFDckMsTUFBTVYsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFD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LXZpZXdlci8uLi92b2x1bWUtdmlld2VyL2VzL2xvYWRlcnMvemFycl91dGlscy91dGlscy5qcz84Zjg2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZvbHVtZUxvYWRFcnJvclR5cGUsIFZvbHVtZUxvYWRFcnJvciB9IGZyb20gXCIuLi9Wb2x1bWVMb2FkRXJyb3IuanNcIjtcbi8qKiBFeHRyYWN0cyBjaGFubmVsIG5hbWVzIGZyb20gYSBgWmFyclNvdXJjZWAuIEhhbmRsZXMgbWlzc2luZyBgb21lcm9NZXRhZGF0YWAuIERvZXMgKm5vdCogcmVzb2x2ZSBuYW1lIGNvbGxpc2lvbnMuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U291cmNlQ2hhbm5lbE5hbWVzKHNyYykge1xuICBpZiAoc3JjLm9tZXJvTWV0YWRhdGE/LmNoYW5uZWxzKSB7XG4gICAgcmV0dXJuIHNyYy5vbWVyb01ldGFkYXRhLmNoYW5uZWxzLm1hcCgoe1xuICAgICAgbGFiZWxcbiAgICB9LCBpZHgpID0+IGxhYmVsID8/IGBDaGFubmVsICR7aWR4ICsgc3JjLmNoYW5uZWxPZmZzZXR9YCk7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gc3JjLnNjYWxlTGV2ZWxzWzBdLnNoYXBlW3NyYy5heGVzVENaWVhbMV1dO1xuICByZXR1cm4gQXJyYXkuZnJvbSh7XG4gICAgbGVuZ3RoXG4gIH0sIChfLCBpZHgpID0+IGBDaGFubmVsICR7aWR4ICsgc3JjLmNoYW5uZWxPZmZzZXR9YCk7XG59XG5cbi8qKiBUdXJucyBgYXhlc1RDWllYYCBpbnRvIHRoZSBudW1iZXIgb2YgZGltZW5zaW9ucyBpbiB0aGUgYXJyYXkgKi9cbmV4cG9ydCBjb25zdCBnZXREaW1lbnNpb25Db3VudCA9IChbdCwgYywgel0pID0+IDIgKyBOdW1iZXIodCA+IC0xKSArIE51bWJlcihjID4gLTEpICsgTnVtYmVyKHogPiAtMSk7XG5leHBvcnQgZnVuY3Rpb24gcmVtYXBBeGVzVG9UQ1pZWChheGVzKSB7XG4gIGNvbnN0IGF4ZXNUQ1pZWCA9IFstMSwgLTEsIC0xLCAtMSwgLTFdO1xuICBjb25zdCBheGlzTmFtZXMgPSBbXCJ0XCIsIFwiY1wiLCBcInpcIiwgXCJ5XCIsIFwieFwiXTtcbiAgYXhlcy5mb3JFYWNoKChheGlzLCBpZHgpID0+IHtcbiAgICBjb25zdCBheGlzSWR4ID0gYXhpc05hbWVzLmluZGV4T2YoYXhpcy5uYW1lKTtcbiAgICBpZiAoYXhpc0lkeCA+IC0xKSB7XG4gICAgICBheGVzVENaWVhbYXhpc0lkeF0gPSBpZHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBWb2x1bWVMb2FkRXJyb3IoYFVucmVjb2duaXplZCBheGlzIGluIHphcnI6ICR7YXhpcy5uYW1lfWAsIHtcbiAgICAgICAgdHlwZTogVm9sdW1lTG9hZEVycm9yVHlwZS5JTlZBTElEX01FVEFEQVRBXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGl0IGlzIHBvc3NpYmxlIHRoYXQgWiBtaWdodCBub3QgZXhpc3QgYnV0IHdlIHJlcXVpcmUgWCBhbmQgWSBhdCBsZWFzdC5cbiAgY29uc3Qgbm9YQXhpcyA9IGF4ZXNUQ1pZWFs0XSA9PT0gLTE7XG4gIGlmIChub1hBeGlzIHx8IGF4ZXNUQ1pZWFszXSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgVm9sdW1lTG9hZEVycm9yKGBEaWQgbm90IGZpbmQgJHtub1hBeGlzID8gXCJhbiBYXCIgOiBcImEgWVwifSBheGlzIGluIHphcnJgLCB7XG4gICAgICB0eXBlOiBWb2x1bWVMb2FkRXJyb3JUeXBlLklOVkFMSURfTUVUQURBVEFcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYXhlc1RDWllYO1xufVxuXG4vKiogUmVvcmRlciBhbiBhcnJheSBvZiB2YWx1ZXMgW1QsIEMsIFosIFksIFhdIHRvIHRoZSBnaXZlbiBkaW1lbnNpb24gb3JkZXIgKi9cbmV4cG9ydCBmdW5jdGlvbiBvcmRlckJ5RGltZW5zaW9uKHZhbHNUQ1pZWCwgb3JkZXJUQ1pZWCkge1xuICBjb25zdCBzcGVjTGVuID0gZ2V0RGltZW5zaW9uQ291bnQob3JkZXJUQ1pZWCk7XG4gIGNvbnN0IHJlc3VsdCA9IEFycmF5KHNwZWNMZW4pO1xuICBvcmRlclRDWllYLmZvckVhY2goKHZhbCwgaWR4KSA9PiB7XG4gICAgaWYgKHZhbCA+PSAwKSB7XG4gICAgICBpZiAodmFsID49IHNwZWNMZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFZvbHVtZUxvYWRFcnJvcihgVW5leHBlY3RlZCBheGlzIGluZGV4IGluIHphcnI6ICR7dmFsfWAsIHtcbiAgICAgICAgICB0eXBlOiBWb2x1bWVMb2FkRXJyb3JUeXBlLklOVkFMSURfTUVUQURBVEFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXN1bHRbdmFsXSA9IHZhbHNUQ1pZWFtpZHhdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBSZW9yZGVyIGFuIGFycmF5IG9mIHZhbHVlcyBpbiB0aGUgZ2l2ZW4gZGltZW5zaW9uIG9yZGVyIHRvIFtULCBDLCBaLCBZLCBYXSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yZGVyQnlUQ1pZWCh2YWxzRGltZW5zaW9uLCBvcmRlclRDWllYLCBkZWZhdWx0VmFsdWUpIHtcbiAgY29uc3QgcmVzdWx0ID0gW2RlZmF1bHRWYWx1ZSwgZGVmYXVsdFZhbHVlLCBkZWZhdWx0VmFsdWUsIGRlZmF1bHRWYWx1ZSwgZGVmYXVsdFZhbHVlXTtcbiAgb3JkZXJUQ1pZWC5mb3JFYWNoKCh2YWwsIGlkeCkgPT4ge1xuICAgIGlmICh2YWwgPj0gMCkge1xuICAgICAgaWYgKHZhbCA+PSB2YWxzRGltZW5zaW9uLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgVm9sdW1lTG9hZEVycm9yKGBVbmV4cGVjdGVkIGF4aXMgaW5kZXggaW4gemFycjogJHt2YWx9YCwge1xuICAgICAgICAgIHR5cGU6IFZvbHVtZUxvYWRFcnJvclR5cGUuSU5WQUxJRF9NRVRBREFUQVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdFtpZHhdID0gdmFsc0RpbWVuc2lvblt2YWxdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBTZWxlY3QgdGhlIHNjYWxlIHRyYW5zZm9ybSBmcm9tIGFuIE9NRSBtZXRhZGF0YSBvYmplY3Qgd2l0aCBjb29yZGluYXRlIHRyYW5zZm9ybXMsIGFuZCByZXR1cm4gaXQgaW4gVENaWVggb3JkZXIgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2FsZShkYXRhc2V0LCBvcmRlclRDWllYKSB7XG4gIGNvbnN0IHRyYW5zZm9ybXMgPSBkYXRhc2V0LmNvb3JkaW5hdGVUcmFuc2Zvcm1hdGlvbnM7XG4gIGlmICh0cmFuc2Zvcm1zID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oXCJXQVJOSU5HOiBPTUVaYXJyTG9hZGVyOiBubyBjb29yZGluYXRlIHRyYW5zZm9ybWF0aW9ucyBmb3Igc2NhbGUgbGV2ZWwuXCIpO1xuICAgIHJldHVybiBbMSwgMSwgMSwgMSwgMV07XG4gIH1cblxuICAvLyB0aGlzIGFzc3VtZXMgd2UnbGwgbmV2ZXIgZW5jb3VudGVyIHRoZSBcInBhdGhcIiB2YXJpYW50XG4gIGNvbnN0IGlzU2NhbGVUcmFuc2Zvcm0gPSB0ID0+IHQudHlwZSA9PT0gXCJzY2FsZVwiO1xuXG4gIC8vIHRoZXJlIGNhbiBiZSBhbnkgbnVtYmVyIG9mIGNvb3JkaW5hdGVUcmFuc2Zvcm1hdGlvbnNcbiAgLy8gYnV0IHRoZXJlIG11c3QgYmUgb25seSBvbmUgb2YgdHlwZSBcInNjYWxlXCIuXG4gIGNvbnN0IHNjYWxlVHJhbnNmb3JtID0gdHJhbnNmb3Jtcy5maW5kKGlzU2NhbGVUcmFuc2Zvcm0pO1xuICBpZiAoIXNjYWxlVHJhbnNmb3JtKSB7XG4gICAgY29uc29sZS53YXJuKGBXQVJOSU5HOiBPTUVaYXJyTG9hZGVyOiBubyBjb29yZGluYXRlIHRyYW5zZm9ybWF0aW9uIG9mIHR5cGUgXCJzY2FsZVwiIGZvciBzY2FsZSBsZXZlbC5gKTtcbiAgICByZXR1cm4gWzEsIDEsIDEsIDEsIDFdO1xuICB9XG4gIGNvbnN0IHNjYWxlID0gc2NhbGVUcmFuc2Zvcm0uc2NhbGUuc2xpY2UoKTtcbiAgcmV0dXJuIG9yZGVyQnlUQ1pZWChzY2FsZSwgb3JkZXJUQ1pZWCwgMSk7XG59XG5cbi8qKlxyXG4gKiBEZWZpbmVzIGEgcGFydGlhbCBvcmRlciBvZiB6YXJyIGFycmF5cyBiYXNlZCBvbiB0aGVpciBzaXplLiBTcGVjaWZpY2FsbHk6XHJcbiAqIC0gSWYgYXJyYXkgc2l6ZSB4LCB5LCB6IGFyZSBhbGwgZXF1YWwsIHRoZSBhcnJheXMgYXJlIGVxdWFsXHJcbiAqIC0gb3RoZXJ3aXNlLCBpZiBhbGwgeHl6IG9mIGBhYCBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRob3NlIG9mIGBiYCwgYGFgIGlzIGxlc3MgdGhhbiBgYmAgKGFuZCB2aWNlIHZlcnNhKVxyXG4gKiAtIGlmIHNvbWUgeHl6IGlzIGxlc3MgYW5kIHNvbWUgaXMgZ3JlYXRlciwgdGhlIGFycmF5cyBhcmUgdW5jb21wYXJhYmxlXHJcbiAqL1xuZnVuY3Rpb24gY29tcGFyZVphcnJBcnJheVNpemUoYUFyciwgYVRDWllYLCBiQXJyLCBiVENaWVgpIHtcbiAgY29uc3QgYVogPSBhVENaWVhbMl0gPiAtMSA/IGFBcnIuc2hhcGVbYVRDWllYWzJdXSA6IDE7XG4gIGNvbnN0IGJaID0gYlRDWllYWzJdID4gLTEgPyBiQXJyLnNoYXBlW2JUQ1pZWFsyXV0gOiAxO1xuICBjb25zdCBkaWZmWiA9IGFaIC0gYlo7XG4gIGNvbnN0IGRpZmZZID0gYUFyci5zaGFwZVthVENaWVhbM11dIC0gYkFyci5zaGFwZVtiVENaWVhbM11dO1xuICBjb25zdCBkaWZmWCA9IGFBcnIuc2hhcGVbYVRDWllYWzRdXSAtIGJBcnIuc2hhcGVbYlRDWllYWzRdXTtcbiAgaWYgKGRpZmZaID09PSAwICYmIGRpZmZZID09PSAwICYmIGRpZmZYID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoZGlmZlogPD0gMCAmJiBkaWZmWSA8PSAwICYmIGRpZmZYIDw9IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoZGlmZlogPj0gMCAmJiBkaWZmWSA+PSAwICYmIGRpZmZYID49IDApIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5jb25zdCBFUFNJTE9OID0gMC4wMDAwMTtcbmNvbnN0IGFib3V0RXF1YWxzID0gKGEsIGIpID0+IE1hdGguYWJzKGEgLSBiKSA8IEVQU0lMT047XG5mdW5jdGlvbiBzY2FsZVRyYW5zZm9ybXNBcmVFcXVhbChhU3JjLCBhTGV2ZWwsIGJTcmMsIGJMZXZlbCkge1xuICBjb25zdCBhU2NhbGUgPSBnZXRTY2FsZShhU3JjLm11bHRpc2NhbGVNZXRhZGF0YS5kYXRhc2V0c1thTGV2ZWxdLCBhU3JjLmF4ZXNUQ1pZWCk7XG4gIGNvbnN0IGJTY2FsZSA9IGdldFNjYWxlKGJTcmMubXVsdGlzY2FsZU1ldGFkYXRhLmRhdGFzZXRzW2JMZXZlbF0sIGJTcmMuYXhlc1RDWllYKTtcbiAgcmV0dXJuIGFib3V0RXF1YWxzKGFTY2FsZVsyXSwgYlNjYWxlWzJdKSAmJiBhYm91dEVxdWFscyhhU2NhbGVbM10sIGJTY2FsZVszXSkgJiYgYWJvdXRFcXVhbHMoYVNjYWxlWzRdLCBiU2NhbGVbNF0pO1xufVxuXG4vKipcclxuICogRW5zdXJlcyB0aGF0IGFsbCBzY2FsZSBsZXZlbHMgaW4gYHNvdXJjZXNgIGFyZSBtYXRjaGVkIHVwIGJ5IHNpemUuIE1vcmUgcHJlY2lzZWx5OiBlbmZvcmNlcyB0aGF0LCBmb3IgYW55IHNjYWxlXHJcbiAqIGxldmVsIGBpYCwgdGhlIHNpemUgb2YgemFyciBhcnJheSBgc1tpXWAgaXMgZXF1YWwgZm9yIGV2ZXJ5IHNvdXJjZSBgc2AuIFdlIGFjY29tcGxpc2ggdGhpcyBieSByZW1vdmluZyBhbnkgYXJyYXlzXHJcbiAqIChhbmQgdGhlaXIgYXNzb2NpYXRlZCBPTUUgZGF0YXNldCBtZXRhZGF0YSkgd2hpY2ggZG9uJ3QgbWF0Y2ggdXAgaW4gYWxsIHNvdXJjZXMuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG1vZGlmaWVzIHRoZSBpbnB1dCBgc291cmNlc2AgYXJyYXkgcmF0aGVyIHRoYW4gcmV0dXJuaW5nIGEgbmV3IHZhbHVlLlxyXG4gKlxyXG4gKiBBc3N1bWVzIGFsbCBzb3VyY2VzIGhhdmUgc2NhbGUgbGV2ZWxzIG9yZGVyZWQgYnkgc2l6ZSBmcm9tIGxhcmdlc3QgdG8gc21hbGxlc3QuIChUaGlzIHNob3VsZCBhbHdheXMgYmUgdHJ1ZSBmb3JcclxuICogY29tcGxpYW50IE9NRS1aYXJyIGRhdGEuKVxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFNvdXJjZVNjYWxlTGV2ZWxzKHNvdXJjZXMpIHtcbiAgaWYgKHNvdXJjZXMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFNhdmUgbWF0Y2hpbmcgc2NhbGUgbGV2ZWxzIGFuZCBtZXRhZGF0YSBoZXJlXG4gIGNvbnN0IG1hdGNoZWRMZXZlbHMgPSBBcnJheS5mcm9tKHtcbiAgICBsZW5ndGg6IHNvdXJjZXMubGVuZ3RoXG4gIH0sICgpID0+IFtdKTtcbiAgY29uc3QgbWF0Y2hlZE1ldGFzID0gQXJyYXkuZnJvbSh7XG4gICAgbGVuZ3RoOiBzb3VyY2VzLmxlbmd0aFxuICB9LCAoKSA9PiBbXSk7XG5cbiAgLy8gU3RhcnQgYXMgbWFueSBpbmRleCBjb3VudGVycyBhcyB3ZSBoYXZlIHNvdXJjZXNcbiAgY29uc3Qgc2NhbGVJbmRleGVzID0gbmV3IEFycmF5KHNvdXJjZXMubGVuZ3RoKS5maWxsKDApO1xuICB3aGlsZSAoc2NhbGVJbmRleGVzLmV2ZXJ5KCh2YWwsIGlkeCkgPT4gdmFsIDwgc291cmNlc1tpZHhdLnNjYWxlTGV2ZWxzLmxlbmd0aCkpIHtcbiAgICAvLyBGaXJzdCBwYXNzOiBmaW5kIHRoZSBzbWFsbGVzdCBzb3VyY2UgLyBkZXRlcm1pbmUgaWYgYWxsIHNvdXJjZXMgYXJlIGVxdWFsXG4gICAgbGV0IGFsbEVxdWFsID0gdHJ1ZTtcbiAgICBsZXQgc21hbGxlc3RJZHggPSAwO1xuICAgIGxldCBzbWFsbGVzdFNyYyA9IHNvdXJjZXNbMF07XG4gICAgbGV0IHNtYWxsZXN0QXJyID0gc21hbGxlc3RTcmMuc2NhbGVMZXZlbHNbc2NhbGVJbmRleGVzWzBdXTtcbiAgICBmb3IgKGxldCBjdXJyZW50SWR4ID0gMTsgY3VycmVudElkeCA8IHNvdXJjZXMubGVuZ3RoOyBjdXJyZW50SWR4KyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTcmMgPSBzb3VyY2VzW2N1cnJlbnRJZHhdO1xuICAgICAgY29uc3QgY3VycmVudEFyciA9IGN1cnJlbnRTcmMuc2NhbGVMZXZlbHNbc2NhbGVJbmRleGVzW2N1cnJlbnRJZHhdXTtcbiAgICAgIGNvbnN0IG9yZGVyaW5nID0gY29tcGFyZVphcnJBcnJheVNpemUoc21hbGxlc3RBcnIsIHNtYWxsZXN0U3JjLmF4ZXNUQ1pZWCwgY3VycmVudEFyciwgY3VycmVudFNyYy5heGVzVENaWVgpO1xuICAgICAgaWYgKCFvcmRlcmluZykge1xuICAgICAgICAvLyBBcnJheXMgYXJlIGVxdWFsLCBvciB0aGV5IGFyZSB1bmNvbXBhcmFibGVcbiAgICAgICAgaWYgKG9yZGVyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVm9sdW1lTG9hZEVycm9yKFwiSW5jb21wYXRpYmxlIHphcnIgYXJyYXlzOiBwaXhlbCBkaW1lbnNpb25zIGFyZSBtaXNtYXRjaGVkXCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFZvbHVtZUxvYWRFcnJvclR5cGUuSU5WQUxJRF9NVUxUSV9TT1VSQ0VfWkFSUlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IHdlIGtub3cgdGhlIGFycmF5cyBhcmUgZXF1YWwsIGJ1dCB0aGV5IG1heSBzdGlsbCBiZSBpbnZhbGlkIHRvIG1hdGNoIHVwIGJlY2F1c2UuLi5cbiAgICAgICAgLy8gLi4udGhleSBoYXZlIGRpZmZlcmVudCBzY2FsZSB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgaWYgKCFzY2FsZVRyYW5zZm9ybXNBcmVFcXVhbChzbWFsbGVzdFNyYywgc2NhbGVJbmRleGVzW3NtYWxsZXN0SWR4XSwgY3VycmVudFNyYywgc2NhbGVJbmRleGVzW2N1cnJlbnRJZHhdKSkge1xuICAgICAgICAgIC8vIHRvZGF5IHdlIGFyZSBnb2luZyB0byB0cmVhdCB0aGlzIGFzIGEgd2FybmluZy5cbiAgICAgICAgICAvLyBGb3Igb3VyIGltcGxlbWVudGF0aW9uIGl0IGlzIGVub3VnaCB0aGF0IHRoZSB4eXogcGl4ZWwgcmFuZ2VzIGFyZSB0aGUgc2FtZS5cbiAgICAgICAgICAvLyBJZGVhbGx5IHNjYWxlKmFycmF5c2l6ZT1waHlzaWNhbCBzaXplIGlzIHJlYWxseSB0aGUgcXVhbnRpdHkgdGhhdCBzaG91bGQgYmUgZXF1YWwsIGZvciBjb21iaW5pbmcgdHdvIHZvbHVtZSBkYXRhIHNldHMgYXMgY2hhbm5lbHMuXG4gICAgICAgICAgY29uc29sZS53YXJuKFwiSW5jb21wYXRpYmxlIHphcnIgYXJyYXlzOiBzY2FsZSBsZXZlbHMgb2YgZXF1YWwgc2l6ZSBoYXZlIGRpZmZlcmVudCBzY2FsZSB0cmFuc2Zvcm1hdGlvbnNcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAuLi50aGV5IGhhdmUgZGlmZmVyZW50IG51bWJlcnMgb2YgdGltZXN0ZXBzXG4gICAgICAgIGNvbnN0IGxhcmdlc3RUID0gc21hbGxlc3RTcmMuYXhlc1RDWllYWzBdID4gLTEgPyBzbWFsbGVzdEFyci5zaGFwZVtzbWFsbGVzdFNyYy5heGVzVENaWVhbMF1dIDogMTtcbiAgICAgICAgY29uc3QgY3VycmVudFQgPSBjdXJyZW50U3JjLmF4ZXNUQ1pZWFswXSA+IC0xID8gY3VycmVudEFyci5zaGFwZVtjdXJyZW50U3JjLmF4ZXNUQ1pZWFswXV0gOiAxO1xuICAgICAgICBpZiAobGFyZ2VzdFQgIT09IGN1cnJlbnRUKSB7XG4gICAgICAgICAgLy8gd2UgYWxzbyB0cmVhdCB0aGlzIGFzIGEgd2FybmluZy5cbiAgICAgICAgICAvLyBJbiBPbWVaYXJyTG9hZGVyIHdlIHdpbGwgdGFrZSB0aGUgbWluaW11bSBUIHNpemUgb2YgYWxsIHNvdXJjZXNcbiAgICAgICAgICBjb25zb2xlLndhcm4oYEluY29tcGF0aWJsZSB6YXJyIGFycmF5czogZGlmZmVyZW50IG51bWJlcnMgb2YgdGltZXN0ZXBzOiAke2xhcmdlc3RUfSB2cyAke2N1cnJlbnRUfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxFcXVhbCA9IGZhbHNlO1xuICAgICAgICBpZiAob3JkZXJpbmcgPiAwKSB7XG4gICAgICAgICAgc21hbGxlc3RJZHggPSBjdXJyZW50SWR4O1xuICAgICAgICAgIHNtYWxsZXN0U3JjID0gY3VycmVudFNyYztcbiAgICAgICAgICBzbWFsbGVzdEFyciA9IGN1cnJlbnRBcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsbEVxdWFsKSB7XG4gICAgICAvLyBXZSd2ZSBmb3VuZCBhIG1hdGNoaW5nIHNldCBvZiBzY2FsZSBsZXZlbHMhIFNhdmUgaXQgYW5kIGluY3JlbWVudCBhbGwgaW5kZXhlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2FsZUluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY3VycmVudFNyYyA9IHNvdXJjZXNbaV07XG4gICAgICAgIGNvbnN0IG1hdGNoZWRTY2FsZUxldmVsID0gc2NhbGVJbmRleGVzW2ldO1xuICAgICAgICBtYXRjaGVkTGV2ZWxzW2ldLnB1c2goY3VycmVudFNyYy5zY2FsZUxldmVsc1ttYXRjaGVkU2NhbGVMZXZlbF0pO1xuICAgICAgICBtYXRjaGVkTWV0YXNbaV0ucHVzaChjdXJyZW50U3JjLm11bHRpc2NhbGVNZXRhZGF0YS5kYXRhc2V0c1ttYXRjaGVkU2NhbGVMZXZlbF0pO1xuICAgICAgICBzY2FsZUluZGV4ZXNbaV0gKz0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW5jcmVtZW50IHRoZSBpbmRleGVzIG9mIHRoZSBzb3VyY2VzIHdoaWNoIGFyZSBsYXJnZXIgdGhhbiB0aGUgc21hbGxlc3RcbiAgICAgIGZvciAoY29uc3QgW2lkeCwgc3JjSWR4XSBvZiBzY2FsZUluZGV4ZXMuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTcmMgPSBzb3VyY2VzW2lkeF07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBcnIgPSBjdXJyZW50U3JjLnNjYWxlTGV2ZWxzW3NyY0lkeF07XG4gICAgICAgIGNvbnN0IG9yZGVyaW5nID0gY29tcGFyZVphcnJBcnJheVNpemUoc21hbGxlc3RBcnIsIHNtYWxsZXN0U3JjLmF4ZXNUQ1pZWCwgY3VycmVudEFyciwgY3VycmVudFNyYy5heGVzVENaWVgpO1xuICAgICAgICBpZiAob3JkZXJpbmcgIT09IDApIHtcbiAgICAgICAgICBzY2FsZUluZGV4ZXNbaWR4XSArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChzb3VyY2VzWzBdLnNjYWxlTGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBWb2x1bWVMb2FkRXJyb3IoXCJJbmNvbXBhdGlibGUgemFyciBhcnJheXM6IG5vIHNldHMgb2Ygc2NhbGUgbGV2ZWxzIGZvdW5kIHRoYXQgbWF0Y2hlZCBpbiBhbGwgc291cmNlc1wiLCB7XG4gICAgICB0eXBlOiBWb2x1bWVMb2FkRXJyb3JUeXBlLklOVkFMSURfTVVMVElfU09VUkNFX1pBUlJcbiAgICB9KTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICBzb3VyY2VzW2ldLnNjYWxlTGV2ZWxzID0gbWF0Y2hlZExldmVsc1tpXTtcbiAgICBzb3VyY2VzW2ldLm11bHRpc2NhbGVNZXRhZGF0YS5kYXRhc2V0cyA9IG1hdGNoZWRNZXRhc1tpXTtcbiAgfVxufSJdLCJuYW1lcyI6WyJWb2x1bWVMb2FkRXJyb3JUeXBlIiwiVm9sdW1lTG9hZEVycm9yIiwiZ2V0U291cmNlQ2hhbm5lbE5hbWVzIiwic3JjIiwib21lcm9NZXRhZGF0YSIsImNoYW5uZWxzIiwibWFwIiwibGFiZWwiLCJpZHgiLCJjaGFubmVsT2Zmc2V0IiwibGVuZ3RoIiwic2NhbGVMZXZlbHMiLCJzaGFwZSIsImF4ZXNUQ1pZWCIsIkFycmF5IiwiZnJvbSIsIl8iLCJnZXREaW1lbnNpb25Db3VudCIsInQiLCJjIiwieiIsIk51bWJlciIsInJlbWFwQXhlc1RvVENaWVgiLCJheGVzIiwiYXhpc05hbWVzIiwiZm9yRWFjaCIsImF4aXMiLCJheGlzSWR4IiwiaW5kZXhPZiIsIm5hbWUiLCJ0eXBlIiwiSU5WQUxJRF9NRVRBREFUQSIsIm5vWEF4aXMiLCJvcmRlckJ5RGltZW5zaW9uIiwidmFsc1RDWllYIiwib3JkZXJUQ1pZWCIsInNwZWNMZW4iLCJyZXN1bHQiLCJ2YWwiLCJvcmRlckJ5VENaWVgiLCJ2YWxzRGltZW5zaW9uIiwiZGVmYXVsdFZhbHVlIiwiZ2V0U2NhbGUiLCJkYXRhc2V0IiwidHJhbnNmb3JtcyIsImNvb3JkaW5hdGVUcmFuc2Zvcm1hdGlvbnMiLCJ1bmRlZmluZWQiLCJjb25zb2xlIiwid2FybiIsImlzU2NhbGVUcmFuc2Zvcm0iLCJzY2FsZVRyYW5zZm9ybSIsImZpbmQiLCJzY2FsZSIsInNsaWNlIiwiY29tcGFyZVphcnJBcnJheVNpemUiLCJhQXJyIiwiYVRDWllYIiwiYkFyciIsImJUQ1pZWCIsImFaIiwiYloiLCJkaWZmWiIsImRpZmZZIiwiZGlmZlgiLCJFUFNJTE9OIiwiYWJvdXRFcXVhbHMiLCJhIiwiYiIsIk1hdGgiLCJhYnMiLCJzY2FsZVRyYW5zZm9ybXNBcmVFcXVhbCIsImFTcmMiLCJhTGV2ZWwiLCJiU3JjIiwiYkxldmVsIiwiYVNjYWxlIiwibXVsdGlzY2FsZU1ldGFkYXRhIiwiZGF0YXNldHMiLCJiU2NhbGUiLCJtYXRjaFNvdXJjZVNjYWxlTGV2ZWxzIiwic291cmNlcyIsIm1hdGNoZWRMZXZlbHMiLCJtYXRjaGVkTWV0YXMiLCJzY2FsZUluZGV4ZXMiLCJmaWxsIiwiZXZlcnkiLCJhbGxFcXVhbCIsInNtYWxsZXN0SWR4Iiwic21hbGxlc3RTcmMiLCJzbWFsbGVzdEFyciIsImN1cnJlbnRJZHgiLCJjdXJyZW50U3JjIiwiY3VycmVudEFyciIsIm9yZGVyaW5nIiwiSU5WQUxJRF9NVUxUSV9TT1VSQ0VfWkFSUiIsImxhcmdlc3RUIiwiY3VycmVudFQiLCJpIiwibWF0Y2hlZFNjYWxlTGV2ZWwiLCJwdXNoIiwic3JjSWR4IiwiZW50cmllcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../volume-viewer/es/loaders/zarr_utils/utils.js\n");

/***/ }),

/***/ "../volume-viewer/es/loaders/zarr_utils/validation.js":
/*!************************************************************!*\
  !*** ../volume-viewer/es/loaders/zarr_utils/validation.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateOMEZarrMetadata: () => (/* binding */ validateOMEZarrMetadata)\n/* harmony export */ });\n/* harmony import */ var _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VolumeLoadError.js */ \"../volume-viewer/es/loaders/VolumeLoadError.js\");\n\nfunction isObjectWithProp(obj, prop) {\n  return typeof obj === \"object\" && obj !== null && prop in obj;\n}\nfunction assertMetadataHasProp(obj, prop, name = \"zarr\") {\n  if (!isObjectWithProp(obj, prop)) {\n    throw new _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadError(`${name} metadata is missing required entry \"${prop}\"`, {\n      type: _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadErrorType.INVALID_METADATA\n    });\n  }\n}\nfunction assertPropIsArray(obj, prop, name = \"zarr\") {\n  if (!Array.isArray(obj[prop])) {\n    throw new _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadError(`${name} metadata entry \"${prop}\" is not an array`, {\n      type: _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadErrorType.INVALID_METADATA\n    });\n  }\n}\n\n/**\r\n * Validates that the `OMEZarrMetadata` record `data` has the minimal amount of data required to open a volume. Since\r\n * we only ever open one multiscale, we only validate the multiscale metadata record at index `multiscaleIdx` here.\r\n * `name` is used in error messages to identify the source of the metadata.\r\n */\nfunction validateOMEZarrMetadata(data, multiscaleIdx = 0, name = \"zarr\") {\n  // data is an object with a key \"multiscales\", which is an array\n  assertMetadataHasProp(data, \"multiscales\", name);\n  assertPropIsArray(data, \"multiscales\", name);\n\n  // check that a multiscale metadata entry exists at `multiscaleIdx`\n  const multiscaleMeta = data.multiscales[multiscaleIdx];\n  if (!multiscaleMeta) {\n    throw new _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadError(`${name} metadata does not have requested multiscale level ${multiscaleIdx}`, {\n      type: _VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_0__.VolumeLoadErrorType.INVALID_METADATA\n    });\n  }\n  const multiscaleMetaName = isObjectWithProp(multiscaleMeta, \"name\") ? ` (\"${multiscaleMeta.name})` : \"\";\n  const multiscaleName = `${name} multiscale ${multiscaleIdx}${multiscaleMetaName}`;\n\n  // multiscale has a key \"axes\", which is an array. Each axis has a \"name\".\n  assertMetadataHasProp(multiscaleMeta, \"axes\", multiscaleName);\n  assertPropIsArray(multiscaleMeta, \"axes\", multiscaleName);\n  multiscaleMeta.axes.forEach((axis, i) => assertMetadataHasProp(axis, \"name\", `${multiscaleName} axis ${i}`));\n\n  // multiscale has a key \"datasets\", which is an array. Each dataset has a \"path\".\n  assertMetadataHasProp(multiscaleMeta, \"datasets\", name);\n  assertPropIsArray(multiscaleMeta, \"datasets\", name);\n  multiscaleMeta.datasets.forEach((data, i) => assertMetadataHasProp(data, \"path\", `${multiscaleName} dataset ${i}`));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL3phcnJfdXRpbHMvdmFsaWRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2RTtBQUM3RSxTQUFTRSxnQkFBZ0JBLENBQUNDLEdBQUcsRUFBRUMsSUFBSSxFQUFFO0VBQ25DLE9BQU8sT0FBT0QsR0FBRyxLQUFLLFFBQVEsSUFBSUEsR0FBRyxLQUFLLElBQUksSUFBSUMsSUFBSSxJQUFJRCxHQUFHO0FBQy9EO0FBQ0EsU0FBU0UscUJBQXFCQSxDQUFDRixHQUFHLEVBQUVDLElBQUksRUFBRUUsSUFBSSxHQUFHLE1BQU0sRUFBRTtFQUN2RCxJQUFJLENBQUNKLGdCQUFnQixDQUFDQyxHQUFHLEVBQUVDLElBQUksQ0FBQyxFQUFFO0lBQ2hDLE1BQU0sSUFBSUosZ0VBQWUsQ0FBRSxHQUFFTSxJQUFLLHdDQUF1Q0YsSUFBSyxHQUFFLEVBQUU7TUFDaEZHLElBQUksRUFBRU4sb0VBQW1CLENBQUNPO0lBQzVCLENBQUMsQ0FBQztFQUNKO0FBQ0Y7QUFDQSxTQUFTQyxpQkFBaUJBLENBQUNOLEdBQUcsRUFBRUMsSUFBSSxFQUFFRSxJQUFJLEdBQUcsTUFBTSxFQUFFO0VBQ25ELElBQUksQ0FBQ0ksS0FBSyxDQUFDQyxPQUFPLENBQUNSLEdBQUcsQ0FBQ0MsSUFBSSxDQUFDLENBQUMsRUFBRTtJQUM3QixNQUFNLElBQUlKLGdFQUFlLENBQUUsR0FBRU0sSUFBSyxvQkFBbUJGLElBQUssbUJBQWtCLEVBQUU7TUFDNUVHLElBQUksRUFBRU4sb0VBQW1CLENBQUNPO0lBQzVCLENBQUMsQ0FBQztFQUNKO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNJLHVCQUF1QkEsQ0FBQ0MsSUFBSSxFQUFFQyxhQUFhLEdBQUcsQ0FBQyxFQUFFUixJQUFJLEdBQUcsTUFBTSxFQUFFO0VBQzlFO0VBQ0FELHFCQUFxQixDQUFDUSxJQUFJLEVBQUUsYUFBYSxFQUFFUCxJQUFJLENBQUM7RUFDaERHLGlCQUFpQixDQUFDSSxJQUFJLEVBQUUsYUFBYSxFQUFFUCxJQUFJLENBQUM7O0VBRTVDO0VBQ0EsTUFBTVMsY0FBYyxHQUFHRixJQUFJLENBQUNHLFdBQVcsQ0FBQ0YsYUFBYSxDQUFDO0VBQ3RELElBQUksQ0FBQ0MsY0FBYyxFQUFFO0lBQ25CLE1BQU0sSUFBSWYsZ0VBQWUsQ0FBRSxHQUFFTSxJQUFLLHNEQUFxRFEsYUFBYyxFQUFDLEVBQUU7TUFDdEdQLElBQUksRUFBRU4sb0VBQW1CLENBQUNPO0lBQzVCLENBQUMsQ0FBQztFQUNKO0VBQ0EsTUFBTVMsa0JBQWtCLEdBQUdmLGdCQUFnQixDQUFDYSxjQUFjLEVBQUUsTUFBTSxDQUFDLEdBQUksTUFBS0EsY0FBYyxDQUFDVCxJQUFLLEdBQUUsR0FBRyxFQUFFO0VBQ3ZHLE1BQU1ZLGNBQWMsR0FBSSxHQUFFWixJQUFLLGVBQWNRLGFBQWMsR0FBRUcsa0JBQW1CLEVBQUM7O0VBRWpGO0VBQ0FaLHFCQUFxQixDQUFDVSxjQUFjLEVBQUUsTUFBTSxFQUFFRyxjQUFjLENBQUM7RUFDN0RULGlCQUFpQixDQUFDTSxjQUFjLEVBQUUsTUFBTSxFQUFFRyxjQUFjLENBQUM7RUFDekRILGNBQWMsQ0FBQ0ksSUFBSSxDQUFDQyxPQUFPLENBQUMsQ0FBQ0MsSUFBSSxFQUFFQyxDQUFDLEtBQUtqQixxQkFBcUIsQ0FBQ2dCLElBQUksRUFBRSxNQUFNLEVBQUcsR0FBRUgsY0FBZSxTQUFRSSxDQUFFLEVBQUMsQ0FBQyxDQUFDOztFQUU1RztFQUNBakIscUJBQXFCLENBQUNVLGNBQWMsRUFBRSxVQUFVLEVBQUVULElBQUksQ0FBQztFQUN2REcsaUJBQWlCLENBQUNNLGNBQWMsRUFBRSxVQUFVLEVBQUVULElBQUksQ0FBQztFQUNuRFMsY0FBYyxDQUFDUSxRQUFRLENBQUNILE9BQU8sQ0FBQyxDQUFDUCxJQUFJLEVBQUVTLENBQUMsS0FBS2pCLHFCQUFxQixDQUFDUSxJQUFJLEVBQUUsTUFBTSxFQUFHLEdBQUVLLGNBQWUsWUFBV0ksQ0FBRSxFQUFDLENBQUMsQ0FBQztBQUNySCIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi4vdm9sdW1lLXZpZXdlci9lcy9sb2FkZXJzL3phcnJfdXRpbHMvdmFsaWRhdGlvbi5qcz9iOGFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZvbHVtZUxvYWRFcnJvciwgVm9sdW1lTG9hZEVycm9yVHlwZSB9IGZyb20gXCIuLi9Wb2x1bWVMb2FkRXJyb3IuanNcIjtcbmZ1bmN0aW9uIGlzT2JqZWN0V2l0aFByb3Aob2JqLCBwcm9wKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIG9iaiAhPT0gbnVsbCAmJiBwcm9wIGluIG9iajtcbn1cbmZ1bmN0aW9uIGFzc2VydE1ldGFkYXRhSGFzUHJvcChvYmosIHByb3AsIG5hbWUgPSBcInphcnJcIikge1xuICBpZiAoIWlzT2JqZWN0V2l0aFByb3Aob2JqLCBwcm9wKSkge1xuICAgIHRocm93IG5ldyBWb2x1bWVMb2FkRXJyb3IoYCR7bmFtZX0gbWV0YWRhdGEgaXMgbWlzc2luZyByZXF1aXJlZCBlbnRyeSBcIiR7cHJvcH1cImAsIHtcbiAgICAgIHR5cGU6IFZvbHVtZUxvYWRFcnJvclR5cGUuSU5WQUxJRF9NRVRBREFUQVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRQcm9wSXNBcnJheShvYmosIHByb3AsIG5hbWUgPSBcInphcnJcIikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkob2JqW3Byb3BdKSkge1xuICAgIHRocm93IG5ldyBWb2x1bWVMb2FkRXJyb3IoYCR7bmFtZX0gbWV0YWRhdGEgZW50cnkgXCIke3Byb3B9XCIgaXMgbm90IGFuIGFycmF5YCwge1xuICAgICAgdHlwZTogVm9sdW1lTG9hZEVycm9yVHlwZS5JTlZBTElEX01FVEFEQVRBXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGF0IHRoZSBgT01FWmFyck1ldGFkYXRhYCByZWNvcmQgYGRhdGFgIGhhcyB0aGUgbWluaW1hbCBhbW91bnQgb2YgZGF0YSByZXF1aXJlZCB0byBvcGVuIGEgdm9sdW1lLiBTaW5jZVxyXG4gKiB3ZSBvbmx5IGV2ZXIgb3BlbiBvbmUgbXVsdGlzY2FsZSwgd2Ugb25seSB2YWxpZGF0ZSB0aGUgbXVsdGlzY2FsZSBtZXRhZGF0YSByZWNvcmQgYXQgaW5kZXggYG11bHRpc2NhbGVJZHhgIGhlcmUuXHJcbiAqIGBuYW1lYCBpcyB1c2VkIGluIGVycm9yIG1lc3NhZ2VzIHRvIGlkZW50aWZ5IHRoZSBzb3VyY2Ugb2YgdGhlIG1ldGFkYXRhLlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9NRVphcnJNZXRhZGF0YShkYXRhLCBtdWx0aXNjYWxlSWR4ID0gMCwgbmFtZSA9IFwiemFyclwiKSB7XG4gIC8vIGRhdGEgaXMgYW4gb2JqZWN0IHdpdGggYSBrZXkgXCJtdWx0aXNjYWxlc1wiLCB3aGljaCBpcyBhbiBhcnJheVxuICBhc3NlcnRNZXRhZGF0YUhhc1Byb3AoZGF0YSwgXCJtdWx0aXNjYWxlc1wiLCBuYW1lKTtcbiAgYXNzZXJ0UHJvcElzQXJyYXkoZGF0YSwgXCJtdWx0aXNjYWxlc1wiLCBuYW1lKTtcblxuICAvLyBjaGVjayB0aGF0IGEgbXVsdGlzY2FsZSBtZXRhZGF0YSBlbnRyeSBleGlzdHMgYXQgYG11bHRpc2NhbGVJZHhgXG4gIGNvbnN0IG11bHRpc2NhbGVNZXRhID0gZGF0YS5tdWx0aXNjYWxlc1ttdWx0aXNjYWxlSWR4XTtcbiAgaWYgKCFtdWx0aXNjYWxlTWV0YSkge1xuICAgIHRocm93IG5ldyBWb2x1bWVMb2FkRXJyb3IoYCR7bmFtZX0gbWV0YWRhdGEgZG9lcyBub3QgaGF2ZSByZXF1ZXN0ZWQgbXVsdGlzY2FsZSBsZXZlbCAke211bHRpc2NhbGVJZHh9YCwge1xuICAgICAgdHlwZTogVm9sdW1lTG9hZEVycm9yVHlwZS5JTlZBTElEX01FVEFEQVRBXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbXVsdGlzY2FsZU1ldGFOYW1lID0gaXNPYmplY3RXaXRoUHJvcChtdWx0aXNjYWxlTWV0YSwgXCJuYW1lXCIpID8gYCAoXCIke211bHRpc2NhbGVNZXRhLm5hbWV9KWAgOiBcIlwiO1xuICBjb25zdCBtdWx0aXNjYWxlTmFtZSA9IGAke25hbWV9IG11bHRpc2NhbGUgJHttdWx0aXNjYWxlSWR4fSR7bXVsdGlzY2FsZU1ldGFOYW1lfWA7XG5cbiAgLy8gbXVsdGlzY2FsZSBoYXMgYSBrZXkgXCJheGVzXCIsIHdoaWNoIGlzIGFuIGFycmF5LiBFYWNoIGF4aXMgaGFzIGEgXCJuYW1lXCIuXG4gIGFzc2VydE1ldGFkYXRhSGFzUHJvcChtdWx0aXNjYWxlTWV0YSwgXCJheGVzXCIsIG11bHRpc2NhbGVOYW1lKTtcbiAgYXNzZXJ0UHJvcElzQXJyYXkobXVsdGlzY2FsZU1ldGEsIFwiYXhlc1wiLCBtdWx0aXNjYWxlTmFtZSk7XG4gIG11bHRpc2NhbGVNZXRhLmF4ZXMuZm9yRWFjaCgoYXhpcywgaSkgPT4gYXNzZXJ0TWV0YWRhdGFIYXNQcm9wKGF4aXMsIFwibmFtZVwiLCBgJHttdWx0aXNjYWxlTmFtZX0gYXhpcyAke2l9YCkpO1xuXG4gIC8vIG11bHRpc2NhbGUgaGFzIGEga2V5IFwiZGF0YXNldHNcIiwgd2hpY2ggaXMgYW4gYXJyYXkuIEVhY2ggZGF0YXNldCBoYXMgYSBcInBhdGhcIi5cbiAgYXNzZXJ0TWV0YWRhdGFIYXNQcm9wKG11bHRpc2NhbGVNZXRhLCBcImRhdGFzZXRzXCIsIG5hbWUpO1xuICBhc3NlcnRQcm9wSXNBcnJheShtdWx0aXNjYWxlTWV0YSwgXCJkYXRhc2V0c1wiLCBuYW1lKTtcbiAgbXVsdGlzY2FsZU1ldGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YSwgaSkgPT4gYXNzZXJ0TWV0YWRhdGFIYXNQcm9wKGRhdGEsIFwicGF0aFwiLCBgJHttdWx0aXNjYWxlTmFtZX0gZGF0YXNldCAke2l9YCkpO1xufSJdLCJuYW1lcyI6WyJWb2x1bWVMb2FkRXJyb3IiLCJWb2x1bWVMb2FkRXJyb3JUeXBlIiwiaXNPYmplY3RXaXRoUHJvcCIsIm9iaiIsInByb3AiLCJhc3NlcnRNZXRhZGF0YUhhc1Byb3AiLCJuYW1lIiwidHlwZSIsIklOVkFMSURfTUVUQURBVEEiLCJhc3NlcnRQcm9wSXNBcnJheSIsIkFycmF5IiwiaXNBcnJheSIsInZhbGlkYXRlT01FWmFyck1ldGFkYXRhIiwiZGF0YSIsIm11bHRpc2NhbGVJZHgiLCJtdWx0aXNjYWxlTWV0YSIsIm11bHRpc2NhbGVzIiwibXVsdGlzY2FsZU1ldGFOYW1lIiwibXVsdGlzY2FsZU5hbWUiLCJheGVzIiwiZm9yRWFjaCIsImF4aXMiLCJpIiwiZGF0YXNldHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../volume-viewer/es/loaders/zarr_utils/validation.js\n");

/***/ }),

/***/ "../volume-viewer/es/types.js":
/*!************************************!*\
  !*** ../volume-viewer/es/types.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DATARANGE_UINT8: () => (/* binding */ DATARANGE_UINT8),\n/* harmony export */   FUSE_DISABLED_RGB_COLOR: () => (/* binding */ FUSE_DISABLED_RGB_COLOR),\n/* harmony export */   RenderMode: () => (/* binding */ RenderMode),\n/* harmony export */   ViewportCorner: () => (/* binding */ ViewportCorner),\n/* harmony export */   isOrthographicCamera: () => (/* binding */ isOrthographicCamera),\n/* harmony export */   isRight: () => (/* binding */ isRight),\n/* harmony export */   isTop: () => (/* binding */ isTop)\n/* harmony export */ });\n/** If `FuseChannel.rgbColor` is this value, it is disabled from fusion. */\nconst FUSE_DISABLED_RGB_COLOR = 0;\n\n/**\r\n * Provide options to control the visual appearance of a Volume\r\n * @typedef {Object} VolumeChannelDisplayOptions\r\n * @property {boolean} enabled array of boolean per channel\r\n * @property {Array.<number>} color array of rgb per channel\r\n * @property {Array.<number>} specularColor array of rgb per channel\r\n * @property {Array.<number>} emissiveColor array of rgb per channel\r\n * @property {number} glossiness array of float per channel\r\n * @property {boolean} isosurfaceEnabled array of boolean per channel\r\n * @property {number} isovalue array of number per channel\r\n * @property {number} isosurfaceOpacity array of number per channel\r\n * @example let options = {\r\n   };\r\n */\n\nlet RenderMode = /*#__PURE__*/function (RenderMode) {\n  RenderMode[RenderMode[\"RAYMARCH\"] = 0] = \"RAYMARCH\";\n  RenderMode[RenderMode[\"PATHTRACE\"] = 1] = \"PATHTRACE\";\n  RenderMode[RenderMode[\"SLICE\"] = 2] = \"SLICE\";\n  return RenderMode;\n}({});\n\n/**\r\n * Provide options to control the visual appearance of a Volume\r\n * @typedef {Object} VolumeDisplayOptions\r\n * @property {Array.<VolumeChannelDisplayOptions>} channels array of channel display options\r\n * @property {number} density\r\n * @property {Array.<number>} translation xyz\r\n * @property {Array.<number>} rotation xyz angles in radians\r\n * @property {number} maskChannelIndex\r\n * @property {number} maskAlpha\r\n * @property {Array.<number>} clipBounds [xmin, xmax, ymin, ymax, zmin, zmax] all range from 0 to 1 as a percentage of the volume on that axis\r\n * @property {Array.<number>} scale xyz voxel size scaling\r\n * @property {boolean} maxProjection true or false (ray marching)\r\n * @property {number} renderMode 0 for raymarch, 1 for pathtrace\r\n * @property {number} shadingMethod 0 for phase, 1 for brdf, 2 for hybrid (path tracer)\r\n * @property {Array.<number>} gamma [min, max, scale]\r\n * @property {number} primaryRayStepSize in voxels\r\n * @property {number} secondaryRayStepSize in voxels\r\n * @property {boolean} showBoundingBox true or false\r\n * @property {Array.<number>} boundingBoxColor r,g,b for bounding box lines\r\n * @example let options = {\r\n   };\r\n */\n\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\nlet ViewportCorner = /*#__PURE__*/function (ViewportCorner) {\n  ViewportCorner[\"TOP_LEFT\"] = \"top_left\";\n  ViewportCorner[\"TOP_RIGHT\"] = \"top_right\";\n  ViewportCorner[\"BOTTOM_LEFT\"] = \"bottom_left\";\n  ViewportCorner[\"BOTTOM_RIGHT\"] = \"bottom_right\";\n  return ViewportCorner;\n}({});\nconst isTop = corner => corner === ViewportCorner.TOP_LEFT || corner === ViewportCorner.TOP_RIGHT;\nconst isRight = corner => corner === ViewportCorner.TOP_RIGHT || corner === ViewportCorner.BOTTOM_RIGHT;\nconst DATARANGE_UINT8 = [0, 255];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy90eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDTyxNQUFNQSx1QkFBdUIsR0FBRyxDQUFDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLElBQUlDLFVBQVUsR0FBRyxhQUFhLFVBQVVBLFVBQVUsRUFBRTtFQUN6REEsVUFBVSxDQUFDQSxVQUFVLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsVUFBVTtFQUNuREEsVUFBVSxDQUFDQSxVQUFVLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsV0FBVztFQUNyREEsVUFBVSxDQUFDQSxVQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsT0FBTztFQUM3QyxPQUFPQSxVQUFVO0FBQ25CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxNQUFNQyxvQkFBb0IsR0FBR0MsR0FBRyxJQUFJQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0Qsb0JBQW9CO0FBQ25FLElBQUlFLGNBQWMsR0FBRyxhQUFhLFVBQVVBLGNBQWMsRUFBRTtFQUNqRUEsY0FBYyxDQUFDLFVBQVUsQ0FBQyxHQUFHLFVBQVU7RUFDdkNBLGNBQWMsQ0FBQyxXQUFXLENBQUMsR0FBRyxXQUFXO0VBQ3pDQSxjQUFjLENBQUMsYUFBYSxDQUFDLEdBQUcsYUFBYTtFQUM3Q0EsY0FBYyxDQUFDLGNBQWMsQ0FBQyxHQUFHLGNBQWM7RUFDL0MsT0FBT0EsY0FBYztBQUN2QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDRSxNQUFNQyxLQUFLLEdBQUdDLE1BQU0sSUFBSUEsTUFBTSxLQUFLRixjQUFjLENBQUNHLFFBQVEsSUFBSUQsTUFBTSxLQUFLRixjQUFjLENBQUNJLFNBQVM7QUFDakcsTUFBTUMsT0FBTyxHQUFHSCxNQUFNLElBQUlBLE1BQU0sS0FBS0YsY0FBYyxDQUFDSSxTQUFTLElBQUlGLE1BQU0sS0FBS0YsY0FBYyxDQUFDTSxZQUFZO0FBQ3ZHLE1BQU1DLGVBQWUsR0FBRyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWljcy93ZWItM2Qtdmlld2VyLy4uL3ZvbHVtZS12aWV3ZXIvZXMvdHlwZXMuanM/NDE1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogSWYgYEZ1c2VDaGFubmVsLnJnYkNvbG9yYCBpcyB0aGlzIHZhbHVlLCBpdCBpcyBkaXNhYmxlZCBmcm9tIGZ1c2lvbi4gKi9cbmV4cG9ydCBjb25zdCBGVVNFX0RJU0FCTEVEX1JHQl9DT0xPUiA9IDA7XG5cbi8qKlxyXG4gKiBQcm92aWRlIG9wdGlvbnMgdG8gY29udHJvbCB0aGUgdmlzdWFsIGFwcGVhcmFuY2Ugb2YgYSBWb2x1bWVcclxuICogQHR5cGVkZWYge09iamVjdH0gVm9sdW1lQ2hhbm5lbERpc3BsYXlPcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZW5hYmxlZCBhcnJheSBvZiBib29sZWFuIHBlciBjaGFubmVsXHJcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj59IGNvbG9yIGFycmF5IG9mIHJnYiBwZXIgY2hhbm5lbFxyXG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fSBzcGVjdWxhckNvbG9yIGFycmF5IG9mIHJnYiBwZXIgY2hhbm5lbFxyXG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fSBlbWlzc2l2ZUNvbG9yIGFycmF5IG9mIHJnYiBwZXIgY2hhbm5lbFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZ2xvc3NpbmVzcyBhcnJheSBvZiBmbG9hdCBwZXIgY2hhbm5lbFxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzb3N1cmZhY2VFbmFibGVkIGFycmF5IG9mIGJvb2xlYW4gcGVyIGNoYW5uZWxcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGlzb3ZhbHVlIGFycmF5IG9mIG51bWJlciBwZXIgY2hhbm5lbFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gaXNvc3VyZmFjZU9wYWNpdHkgYXJyYXkgb2YgbnVtYmVyIHBlciBjaGFubmVsXHJcbiAqIEBleGFtcGxlIGxldCBvcHRpb25zID0ge1xyXG4gICB9O1xyXG4gKi9cblxuZXhwb3J0IGxldCBSZW5kZXJNb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChSZW5kZXJNb2RlKSB7XG4gIFJlbmRlck1vZGVbUmVuZGVyTW9kZVtcIlJBWU1BUkNIXCJdID0gMF0gPSBcIlJBWU1BUkNIXCI7XG4gIFJlbmRlck1vZGVbUmVuZGVyTW9kZVtcIlBBVEhUUkFDRVwiXSA9IDFdID0gXCJQQVRIVFJBQ0VcIjtcbiAgUmVuZGVyTW9kZVtSZW5kZXJNb2RlW1wiU0xJQ0VcIl0gPSAyXSA9IFwiU0xJQ0VcIjtcbiAgcmV0dXJuIFJlbmRlck1vZGU7XG59KHt9KTtcblxuLyoqXHJcbiAqIFByb3ZpZGUgb3B0aW9ucyB0byBjb250cm9sIHRoZSB2aXN1YWwgYXBwZWFyYW5jZSBvZiBhIFZvbHVtZVxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWb2x1bWVEaXNwbGF5T3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge0FycmF5LjxWb2x1bWVDaGFubmVsRGlzcGxheU9wdGlvbnM+fSBjaGFubmVscyBhcnJheSBvZiBjaGFubmVsIGRpc3BsYXkgb3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVuc2l0eVxyXG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fSB0cmFuc2xhdGlvbiB4eXpcclxuICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPn0gcm90YXRpb24geHl6IGFuZ2xlcyBpbiByYWRpYW5zXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXNrQ2hhbm5lbEluZGV4XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXNrQWxwaGFcclxuICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPn0gY2xpcEJvdW5kcyBbeG1pbiwgeG1heCwgeW1pbiwgeW1heCwgem1pbiwgem1heF0gYWxsIHJhbmdlIGZyb20gMCB0byAxIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgdm9sdW1lIG9uIHRoYXQgYXhpc1xyXG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fSBzY2FsZSB4eXogdm94ZWwgc2l6ZSBzY2FsaW5nXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWF4UHJvamVjdGlvbiB0cnVlIG9yIGZhbHNlIChyYXkgbWFyY2hpbmcpXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZW5kZXJNb2RlIDAgZm9yIHJheW1hcmNoLCAxIGZvciBwYXRodHJhY2VcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNoYWRpbmdNZXRob2QgMCBmb3IgcGhhc2UsIDEgZm9yIGJyZGYsIDIgZm9yIGh5YnJpZCAocGF0aCB0cmFjZXIpXHJcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj59IGdhbW1hIFttaW4sIG1heCwgc2NhbGVdXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcmltYXJ5UmF5U3RlcFNpemUgaW4gdm94ZWxzXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZWNvbmRhcnlSYXlTdGVwU2l6ZSBpbiB2b3hlbHNcclxuICogQHByb3BlcnR5IHtib29sZWFufSBzaG93Qm91bmRpbmdCb3ggdHJ1ZSBvciBmYWxzZVxyXG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fSBib3VuZGluZ0JveENvbG9yIHIsZyxiIGZvciBib3VuZGluZyBib3ggbGluZXNcclxuICogQGV4YW1wbGUgbGV0IG9wdGlvbnMgPSB7XHJcbiAgIH07XHJcbiAqL1xuXG5leHBvcnQgY29uc3QgaXNPcnRob2dyYXBoaWNDYW1lcmEgPSBkZWYgPT4gZGVmICYmIGRlZi5pc09ydGhvZ3JhcGhpY0NhbWVyYTtcbmV4cG9ydCBsZXQgVmlld3BvcnRDb3JuZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFZpZXdwb3J0Q29ybmVyKSB7XG4gIFZpZXdwb3J0Q29ybmVyW1wiVE9QX0xFRlRcIl0gPSBcInRvcF9sZWZ0XCI7XG4gIFZpZXdwb3J0Q29ybmVyW1wiVE9QX1JJR0hUXCJdID0gXCJ0b3BfcmlnaHRcIjtcbiAgVmlld3BvcnRDb3JuZXJbXCJCT1RUT01fTEVGVFwiXSA9IFwiYm90dG9tX2xlZnRcIjtcbiAgVmlld3BvcnRDb3JuZXJbXCJCT1RUT01fUklHSFRcIl0gPSBcImJvdHRvbV9yaWdodFwiO1xuICByZXR1cm4gVmlld3BvcnRDb3JuZXI7XG59KHt9KTtcbmV4cG9ydCBjb25zdCBpc1RvcCA9IGNvcm5lciA9PiBjb3JuZXIgPT09IFZpZXdwb3J0Q29ybmVyLlRPUF9MRUZUIHx8IGNvcm5lciA9PT0gVmlld3BvcnRDb3JuZXIuVE9QX1JJR0hUO1xuZXhwb3J0IGNvbnN0IGlzUmlnaHQgPSBjb3JuZXIgPT4gY29ybmVyID09PSBWaWV3cG9ydENvcm5lci5UT1BfUklHSFQgfHwgY29ybmVyID09PSBWaWV3cG9ydENvcm5lci5CT1RUT01fUklHSFQ7XG5leHBvcnQgY29uc3QgREFUQVJBTkdFX1VJTlQ4ID0gWzAsIDI1NV07Il0sIm5hbWVzIjpbIkZVU0VfRElTQUJMRURfUkdCX0NPTE9SIiwiUmVuZGVyTW9kZSIsImlzT3J0aG9ncmFwaGljQ2FtZXJhIiwiZGVmIiwiVmlld3BvcnRDb3JuZXIiLCJpc1RvcCIsImNvcm5lciIsIlRPUF9MRUZUIiwiVE9QX1JJR0hUIiwiaXNSaWdodCIsIkJPVFRPTV9SSUdIVCIsIkRBVEFSQU5HRV9VSU5UOCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../volume-viewer/es/types.js\n");

/***/ }),

/***/ "../volume-viewer/es/utils/RequestQueue.js":
/*!*************************************************!*\
  !*** ../volume-viewer/es/utils/RequestQueue.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_REQUEST_CANCEL_REASON: () => (/* binding */ DEFAULT_REQUEST_CANCEL_REASON),\n/* harmony export */   \"default\": () => (/* binding */ RequestQueue)\n/* harmony export */ });\n/** Object format used when passing multiple requests to RequestQueue at once. */\n\nconst DEFAULT_REQUEST_CANCEL_REASON = \"request cancelled\";\n\n/**\r\n * Internal object interface used by RequestQueue to store request metadata and callbacks.\r\n */\n\n/**\r\n * Manages a queue of asynchronous requests with unique string keys, which can be added to or cancelled.\r\n * If redundant requests with the same key are issued, the request action will only be run once per key\r\n * while the original request is still in the queue.\r\n */\nclass RequestQueue {\n  /**\r\n   * The maximum number of requests that can be handled concurrently.\r\n   * Once reached, additional requests will be queued up to run once a running request completes.\r\n   */\n\n  /**\r\n   * The maximum number of requests that can be handled concurrently if only low-priority requests are waiting. Set\r\n   * lower than `concurrencyLimit` to always leave space for high-priority requests. Cannot be set higher than\r\n   * `concurrencyLimit`.\r\n   */\n\n  /** A queue of requests that are ready to be executed, in order of request time. */\n\n  /** A queue of low-priority tasks that are ready to be executed. `queue` must be empty before any of these tasks run. */\n\n  /** Stores all requests, even those that are currently active. */\n\n  /** Stores requests whose actions are currently being run. */\n\n  /**\r\n   * Creates a new RequestQueue.\r\n   * @param maxActiveRequests The maximum number of requests that will be handled concurrently. This is 10 by default.\r\n   * @param maxLowPriorityRequests The maximum number of low-priority requests that will be handled concurrently. Equal\r\n   *    to `maxActiveRequests` by default, but may be set lower to always leave space for new high-priority requests.\r\n   */\n  constructor(maxActiveRequests = 10, maxLowPriorityRequests = 5) {\n    this.allRequests = new Map();\n    this.activeRequests = new Set();\n    this.queue = [];\n    this.queueLowPriority = [];\n    this.maxActiveRequests = maxActiveRequests;\n    this.maxLowPriorityRequests = Math.min(maxActiveRequests, maxLowPriorityRequests);\n  }\n\n  /**\r\n   * Stores request metadata to the internal map of all pending requests.\r\n   * @param key string identifier of the request.\r\n   * @param requestAction callable function action of the request.\r\n   * @returns a reference to the new, registered RequestItem.\r\n   */\n  registerRequest(key, requestAction) {\n    // Create a new promise and store the resolve and reject callbacks for later.\n    // This lets us perform the actual action at a later point, when the request is at the\n    // front of the processing queue.\n    let promiseResolve, promiseReject;\n    const promise = new Promise((resolve, reject) => {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n    // Store the request data.\n    const requestItem = {\n      key: key,\n      action: requestAction,\n      resolve: promiseResolve,\n      reject: promiseReject,\n      promise\n    };\n    this.allRequests.set(key, requestItem);\n    return requestItem;\n  }\n\n  /**\r\n   * Moves a registered request into the processing queue, clearing any timeouts on the request.\r\n   * @param key string identifier of the request.\r\n   * @param lowPriority Whether this request should be added with low priority. False by default.\r\n   */\n  addRequestToQueue(key, lowPriority) {\n    // Check that this request is not cancelled.\n    if (this.allRequests.has(key)) {\n      // Clear the request timeout, if it has one, since it is being added to the queue.\n      const requestItem = this.allRequests.get(key);\n      if (requestItem && requestItem.timeoutId) {\n        clearTimeout(requestItem.timeoutId);\n        requestItem.timeoutId = undefined;\n      }\n      if (!this.queue.includes(key) && !this.queueLowPriority.includes(key)) {\n        // Add to queue and check if the request can be processed right away.\n        if (lowPriority) {\n          this.queueLowPriority.push(key);\n        } else {\n          this.queue.push(key);\n        }\n        this.dequeue();\n      }\n    }\n  }\n\n  /**\r\n   * Adds a request with a unique key to the queue, if it doesn't already exist.\r\n   * @param key The key used to track the request.\r\n   * @param requestAction Function that will be called to complete the request. The function\r\n   *  will be run only once per unique key while the request exists, and may be deferred by the\r\n   *  queue at any time.\r\n   * @param lowPriority Whether this request should be added with low priority. False by default.\r\n   * @param delayMs Minimum delay, in milliseconds, before this request should be executed.\r\n   *\r\n   * NOTE: Cancelling a request while the action is running WILL NOT stop the action. If this behavior is desired,\r\n   * actions must be responsible for checking the RequestQueue, determining if the request is still valid (e.g.\r\n   * using `.hasRequest()`), and stopping or returning early.\r\n   *\r\n   * @returns A promise that will resolve on completion of the request, or reject if the request is cancelled.\r\n   *  If multiple requests are issued with the same key, a promise for the first request will be returned\r\n   *  until the request is resolved or cancelled.\r\n   *  Note that the return type of the promise will match that of the first request's instance.\r\n   */\n  addRequest(key, requestAction, lowPriority = false, delayMs = 0) {\n    if (!this.allRequests.has(key)) {\n      // New request!\n      const requestItem = this.registerRequest(key, requestAction);\n      // If a delay is set, wait to add this to the queue.\n      if (delayMs > 0) {\n        const timeoutId = setTimeout(() => this.addRequestToQueue(key, lowPriority), delayMs);\n        // Save timeout information to request metadata\n        requestItem.timeoutId = timeoutId;\n      } else {\n        // No delay, add immediately\n        this.addRequestToQueue(key, lowPriority);\n      }\n    } else {\n      const lowPriorityIndex = this.queueLowPriority.indexOf(key);\n      if (lowPriorityIndex > -1 && !lowPriority) {\n        // This request is registered and queued, but is now being requested with high priority.\n        // Promote it to high priority.\n        this.queueLowPriority.splice(lowPriorityIndex, 1);\n        this.addRequestToQueue(key);\n      } else if (delayMs <= 0) {\n        // This request is registered, but is now being requested without a delay.\n        // Move into queue immediately if it's not already added, and clear any timeouts it may have.\n        this.addRequestToQueue(key, lowPriority);\n      }\n    }\n    const promise = this.allRequests.get(key)?.promise;\n    if (!promise) {\n      throw new Error(\"Found no promise to return when getting stored request data.\");\n    }\n    return promise;\n  }\n\n  /**\r\n   * Adds multiple requests to the queue, with an optional delay between each.\r\n   * @param requests An array of RequestItems, which include a key and a request action.\r\n   * @param lowPriority Whether these requests should be added with low priority. False by default.\r\n   * @param delayMs An optional minimum delay in milliseconds to be added between each request.\r\n   *  For example, a delay of 10 ms will cause the second request to be added to the processing queue\r\n   *  after 10 ms, the third to added after 20 ms, and so on. Set to 10 ms by default.\r\n   * @returns An array of promises corresponding to the provided requests. (i.e., the `i`th value\r\n   * of the returned array will be a Promise for the resolution of `requests[i]`). If a request\r\n   *  with a matching key is already pending, returns the promise for the initial request.\r\n   */\n  addRequests(requests, lowPriority = false, delayMs = 10) {\n    const promises = [];\n    for (let i = 0; i < requests.length; i++) {\n      const item = requests[i];\n      const promise = this.addRequest(item.key, item.requestAction, lowPriority, delayMs * i);\n      promises.push(promise);\n    }\n    return promises;\n  }\n\n  /**\r\n   * Attempts to remove and run the next queued request item, if resources are available.\r\n   * @returns true if a request was started, or false if there are too many\r\n   * requests already active.\r\n   */\n  async dequeue() {\n    const numRequests = this.activeRequests.size;\n    if (numRequests >= this.maxActiveRequests || this.queue.length === 0 && (numRequests >= this.maxLowPriorityRequests || this.queueLowPriority.length === 0)) {\n      return;\n    }\n    const requestKey = this.queue.shift() ?? this.queueLowPriority.shift();\n    if (!requestKey) {\n      return;\n    }\n    if (this.activeRequests.has(requestKey)) {\n      // This request is already active, try the next one instead. (this shouldn't happen)\n      this.dequeue();\n      return;\n    }\n    const requestItem = this.allRequests.get(requestKey);\n    if (!requestItem) {\n      return;\n    }\n    const key = requestItem.key;\n    // Mark that this request is active\n    this.activeRequests.add(key);\n    await requestItem.action().then(requestItem.resolve, requestItem.reject);\n    this.activeRequests.delete(key);\n    this.allRequests.delete(key);\n    this.dequeue();\n  }\n\n  /**\r\n   * Removes any request matching the provided key from the queue and rejects its promise.\r\n   * @param key The key that should be matched against.\r\n   * @param cancelReason A message or object that will be used as the promise rejection.\r\n   */\n  cancelRequest(key, cancelReason = DEFAULT_REQUEST_CANCEL_REASON) {\n    if (!this.allRequests.has(key)) {\n      return;\n    }\n    const requestItem = this.allRequests.get(key);\n    if (requestItem) {\n      if (requestItem.timeoutId) {\n        // Cancel requests that have not been queued yet.\n        clearTimeout(requestItem.timeoutId);\n      }\n      // Reject the request, then clear from the queue and known requests.\n      requestItem.reject(cancelReason);\n    }\n    const queueIndex = this.queue.indexOf(key);\n    if (queueIndex > -1) {\n      this.queue.splice(queueIndex, 1);\n    } else {\n      const lowPriorityIndex = this.queueLowPriority.indexOf(key);\n      if (lowPriorityIndex > -1) {\n        this.queueLowPriority.splice(lowPriorityIndex, 1);\n      }\n    }\n    this.allRequests.delete(key);\n    this.activeRequests.delete(key);\n  }\n\n  /**\r\n   * Rejects all request promises and clears the queue.\r\n   * @param cancelReason A message or object that will be used as the promise rejection.\r\n   */\n  cancelAllRequests(cancelReason = DEFAULT_REQUEST_CANCEL_REASON) {\n    // Clear the queue so we don't do extra work while filtering it\n    this.queue = [];\n    this.queueLowPriority = [];\n    for (const key of this.allRequests.keys()) {\n      this.cancelRequest(key, cancelReason);\n    }\n  }\n\n  /**\r\n   * Returns whether a request with the given key exists in the RequestQueue and is not cancelled.\r\n   * @param key the key to search for.\r\n   * @returns true if the request is in the RequestQueue.\r\n   */\n  hasRequest(key) {\n    return this.allRequests.has(key);\n  }\n\n  /**\r\n   * Returns whether the request with the given key is currently running (not waiting in the queue).\r\n   * @param key the key to search for.\r\n   * @returns true if the request is actively running.\r\n   */\n  requestRunning(key) {\n    return this.activeRequests.has(key);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy91dGlscy9SZXF1ZXN0UXVldWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7QUFFTyxNQUFNQSw2QkFBNkIsR0FBRyxtQkFBbUI7O0FBRWhFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsTUFBTUMsWUFBWSxDQUFDO0VBQ2hDO0FBQ0Y7QUFDQTtBQUNBOztFQUVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0VBRUU7O0VBRUE7O0VBRUE7O0VBRUE7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VDLFdBQVdBLENBQUNDLGlCQUFpQixHQUFHLEVBQUUsRUFBRUMsc0JBQXNCLEdBQUcsQ0FBQyxFQUFFO0lBQzlELElBQUksQ0FBQ0MsV0FBVyxHQUFHLElBQUlDLEdBQUcsQ0FBQyxDQUFDO0lBQzVCLElBQUksQ0FBQ0MsY0FBYyxHQUFHLElBQUlDLEdBQUcsQ0FBQyxDQUFDO0lBQy9CLElBQUksQ0FBQ0MsS0FBSyxHQUFHLEVBQUU7SUFDZixJQUFJLENBQUNDLGdCQUFnQixHQUFHLEVBQUU7SUFDMUIsSUFBSSxDQUFDUCxpQkFBaUIsR0FBR0EsaUJBQWlCO0lBQzFDLElBQUksQ0FBQ0Msc0JBQXNCLEdBQUdPLElBQUksQ0FBQ0MsR0FBRyxDQUFDVCxpQkFBaUIsRUFBRUMsc0JBQXNCLENBQUM7RUFDbkY7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VTLGVBQWVBLENBQUNDLEdBQUcsRUFBRUMsYUFBYSxFQUFFO0lBQ2xDO0lBQ0E7SUFDQTtJQUNBLElBQUlDLGNBQWMsRUFBRUMsYUFBYTtJQUNqQyxNQUFNQyxPQUFPLEdBQUcsSUFBSUMsT0FBTyxDQUFDLENBQUNDLE9BQU8sRUFBRUMsTUFBTSxLQUFLO01BQy9DTCxjQUFjLEdBQUdJLE9BQU87TUFDeEJILGFBQWEsR0FBR0ksTUFBTTtJQUN4QixDQUFDLENBQUM7SUFDRjtJQUNBLE1BQU1DLFdBQVcsR0FBRztNQUNsQlIs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QyxZQUFZLENBQUM7SUFDdkM7RUFDRjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0VJLFVBQVVBLENBQUM5QyxHQUFHLEVBQUU7SUFDZCxPQUFPLElBQUksQ0FBQ1QsV0FBVyxDQUFDc0IsR0FBRyxDQUFDYixHQUFHLENBQUM7RUFDbEM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFK0MsY0FBY0EsQ0FBQy9DLEdBQUcsRUFBRTtJQUNsQixPQUFPLElBQUksQ0FBQ1AsY0FBYyxDQUFDb0IsR0FBRyxDQUFDYixHQUFHLENBQUM7RUFDckM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi4vdm9sdW1lLXZpZXdlci9lcy91dGlscy9SZXF1ZXN0UXVldWUuanM/ODUyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogT2JqZWN0IGZvcm1hdCB1c2VkIHdoZW4gcGFzc2luZyBtdWx0aXBsZSByZXF1ZXN0cyB0byBSZXF1ZXN0UXVldWUgYXQgb25jZS4gKi9cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVRVUVTVF9DQU5DRUxfUkVBU09OID0gXCJyZXF1ZXN0IGNhbmNlbGxlZFwiO1xuXG4vKipcclxuICogSW50ZXJuYWwgb2JqZWN0IGludGVyZmFjZSB1c2VkIGJ5IFJlcXVlc3RRdWV1ZSB0byBzdG9yZSByZXF1ZXN0IG1ldGFkYXRhIGFuZCBjYWxsYmFja3MuXHJcbiAqL1xuXG4vKipcclxuICogTWFuYWdlcyBhIHF1ZXVlIG9mIGFzeW5jaHJvbm91cyByZXF1ZXN0cyB3aXRoIHVuaXF1ZSBzdHJpbmcga2V5cywgd2hpY2ggY2FuIGJlIGFkZGVkIHRvIG9yIGNhbmNlbGxlZC5cclxuICogSWYgcmVkdW5kYW50IHJlcXVlc3RzIHdpdGggdGhlIHNhbWUga2V5IGFyZSBpc3N1ZWQsIHRoZSByZXF1ZXN0IGFjdGlvbiB3aWxsIG9ubHkgYmUgcnVuIG9uY2UgcGVyIGtleVxyXG4gKiB3aGlsZSB0aGUgb3JpZ2luYWwgcmVxdWVzdCBpcyBzdGlsbCBpbiB0aGUgcXVldWUuXHJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVxdWVzdFF1ZXVlIHtcbiAgLyoqXHJcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlcXVlc3RzIHRoYXQgY2FuIGJlIGhhbmRsZWQgY29uY3VycmVudGx5LlxyXG4gICAqIE9uY2UgcmVhY2hlZCwgYWRkaXRpb25hbCByZXF1ZXN0cyB3aWxsIGJlIHF1ZXVlZCB1cCB0byBydW4gb25jZSBhIHJ1bm5pbmcgcmVxdWVzdCBjb21wbGV0ZXMuXHJcbiAgICovXG5cbiAgLyoqXHJcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlcXVlc3RzIHRoYXQgY2FuIGJlIGhhbmRsZWQgY29uY3VycmVudGx5IGlmIG9ubHkgbG93LXByaW9yaXR5IHJlcXVlc3RzIGFyZSB3YWl0aW5nLiBTZXRcclxuICAgKiBsb3dlciB0aGFuIGBjb25jdXJyZW5jeUxpbWl0YCB0byBhbHdheXMgbGVhdmUgc3BhY2UgZm9yIGhpZ2gtcHJpb3JpdHkgcmVxdWVzdHMuIENhbm5vdCBiZSBzZXQgaGlnaGVyIHRoYW5cclxuICAgKiBgY29uY3VycmVuY3lMaW1pdGAuXHJcbiAgICovXG5cbiAgLyoqIEEgcXVldWUgb2YgcmVxdWVzdHMgdGhhdCBhcmUgcmVhZHkgdG8gYmUgZXhlY3V0ZWQsIGluIG9yZGVyIG9mIHJlcXVlc3QgdGltZS4gKi9cblxuICAvKiogQSBxdWV1ZSBvZiBsb3ctcHJpb3JpdHkgdGFza3MgdGhhdCBhcmUgcmVhZHkgdG8gYmUgZXhlY3V0ZWQuIGBxdWV1ZWAgbXVzdCBiZSBlbXB0eSBiZWZvcmUgYW55IG9mIHRoZXNlIHRhc2tzIHJ1bi4gKi9cblxuICAvKiogU3RvcmVzIGFsbCByZXF1ZXN0cywgZXZlbiB0aG9zZSB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlLiAqL1xuXG4gIC8qKiBTdG9yZXMgcmVxdWVzdHMgd2hvc2UgYWN0aW9ucyBhcmUgY3VycmVudGx5IGJlaW5nIHJ1bi4gKi9cblxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IFJlcXVlc3RRdWV1ZS5cclxuICAgKiBAcGFyYW0gbWF4QWN0aXZlUmVxdWVzdHMgVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlcXVlc3RzIHRoYXQgd2lsbCBiZSBoYW5kbGVkIGNvbmN1cnJlbnRseS4gVGhpcyBpcyAxMCBieSBkZWZhdWx0LlxyXG4gICAqIEBwYXJhbSBtYXhMb3dQcmlvcml0eVJlcXVlc3RzIFRoZSBtYXhpbXVtIG51bWJlciBvZiBsb3ctcHJpb3JpdHkgcmVxdWVzdHMgdGhhdCB3aWxsIGJlIGhhbmRsZWQgY29uY3VycmVudGx5LiBFcXVhbFxyXG4gICAqICAgIHRvIGBtYXhBY3RpdmVSZXF1ZXN0c2AgYnkgZGVmYXVsdCwgYnV0IG1heSBiZSBzZXQgbG93ZXIgdG8gYWx3YXlzIGxlYXZlIHNwYWNlIGZvciBuZXcgaGlnaC1wcmlvcml0eSByZXF1ZXN0cy5cclxuICAgKi9cbiAgY29uc3RydWN0b3IobWF4QWN0aXZlUmVxdWVzdHMgPSAxMCwgbWF4TG93UHJpb3JpdHlSZXF1ZXN0cyA9IDUpIHtcbiAgICB0aGlzLmFsbFJlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYWN0aXZlUmVxdWVzdHMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMucXVldWVMb3dQcmlvcml0eSA9IFtdO1xuICAgIHRoaXMubWF4QWN0aXZlUmVxdWVzdHMgPSBtYXhBY3RpdmVSZXF1ZXN0cztcbiAgICB0aGlzLm1heExvd1ByaW9yaXR5UmVxdWVzdHMgPSBNYXRoLm1pbihtYXhBY3RpdmVSZXF1ZXN0cywgbWF4TG93UHJpb3JpdHlSZXF1ZXN0cyk7XG4gIH1cblxuICAvKipcclxuICAgKiBTdG9yZXMgcmVxdWVzdCBtZXRhZGF0YSB0byB0aGUgaW50ZXJuYWwgbWFwIG9mIGFsbCBwZW5kaW5nIHJlcXVlc3RzLlxyXG4gICAqIEBwYXJhbSBrZXkgc3RyaW5nIGlkZW50aWZpZXIgb2YgdGhlIHJlcXVlc3QuXHJcbiAgICogQHBhcmFtIHJlcXVlc3RBY3Rpb24gY2FsbGFibGUgZnVuY3Rpb24gYWN0aW9uIG9mIHRoZSByZXF1ZXN0LlxyXG4gICAqIEByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBuZXcsIHJlZ2lzdGVyZWQgUmVxdWVzdEl0ZW0uXHJcbiAgICovXG4gIHJlZ2lzdGVyUmVxdWVzdChrZXksIHJlcXVlc3RBY3Rpb24pIHtcbiAgICAvLyBDcmVhdGUgYSBuZXcgcHJvbWlzZSBhbmQgc3RvcmUgdGhlIHJlc29sdmUgYW5kIHJlamVjdCBjYWxsYmFja3MgZm9yIGxhdGVyLlxuICAgIC8vIFRoaXMgbGV0cyB1cyBwZXJmb3JtIHRoZSBhY3R1YWwgYWN0aW9uIGF0IGEgbGF0ZXIgcG9pbnQsIHdoZW4gdGhlIHJlcXVlc3QgaXMgYXQgdGhlXG4gICAgLy8gZnJvbnQgb2YgdGhlIHByb2Nlc3NpbmcgcXVldWUuXG4gICAgbGV0IHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIC8vIFN0b3JlIHRoZSByZXF1ZXN0IGRhdGEuXG4gICAgY29uc3QgcmVxdWVzdEl0ZW0gPSB7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIGFjdGlvbjogcmVxdWVzdEFjdGlvbixcbiAgICAgIHJlc29sdmU6IHByb21pc2VSZXNvbHZlLFxuICAgICAgcmVqZWN0OiBwcm9taXNlUmVqZWN0LFxuICAgICAgcHJvbWlzZVxuICAgIH07XG4gICAgdGhpcy5hbGxSZXF1ZXN0cy5zZXQoa2V5LCByZXF1ZXN0SXRlbSk7XG4gICAgcmV0dXJuIHJlcXVlc3RJdGVtO1xuICB9XG5cbiAgLyoqXHJcbiAgICogTW92ZXMgYSByZWdpc3RlcmVkIHJlcXVlc3QgaW50byB0aGUgcHJvY2Vzc2luZyBxdWV1ZSwgY2xlYXJpbmcgYW55IHRpbWVvdXRzIG9uIHRoZSByZXF1ZXN0LlxyXG4gICAqIEBwYXJhbSBrZXkgc3RyaW5nIGlkZW50aWZpZXIgb2YgdGhlIHJlcXVlc3QuXHJcbiAgICogQHBhcmFtIGxvd1ByaW9yaXR5IFdoZXRoZXIgdGhpcyByZXF1ZXN0IHNob3VsZCBiZSBhZGRlZCB3aXRoIGxvdyBwcmlvcml0eS4gRmFsc2UgYnkgZGVmYXVsdC5cclxuICAgKi9cbiAgYWRkUmVxdWVzdFRvUXVldWUoa2V5LCBsb3dQcmlvcml0eSkge1xuICAgIC8vIENoZWNrIHRoYXQgdGhpcyByZXF1ZXN0IGlzIG5vdCBjYW5jZWxsZWQuXG4gICAgaWYgKHRoaXMuYWxsUmVxdWVzdHMuaGFzKGtleSkpIHtcbiAgICAgIC8vIENsZWFyIHRoZSByZXF1ZXN0IHRpbWVvdXQsIGlmIGl0IGhhcyBvbmUsIHNpbmNlIGl0IGlzIGJlaW5nIGFkZGVkIHRvIHRoZSBxdWV1ZS5cbiAgICAgIGNvbnN0IHJlcXVlc3RJdGVtID0gdGhpcy5hbGxSZXF1ZXN0cy5nZXQoa2V5KTtcbiAgICAgIGlmIChyZXF1ZXN0SXRlbSAmJiByZXF1ZXN0SXRlbS50aW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlcXVlc3RJdGVtLnRpbWVvdXRJZCk7XG4gICAgICAgIHJlcXVlc3RJdGVtLnRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5xdWV1ZS5pbmNsdWRlcyhrZXkpICYmICF0aGlzLnF1ZXVlTG93UHJpb3JpdHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAvLyBBZGQgdG8gcXVldWUgYW5kIGNoZWNrIGlmIHRoZSByZXF1ZXN0IGNhbiBiZSBwcm9jZXNzZWQgcmlnaHQgYXdheS5cbiAgICAgICAgaWYgKGxvd1ByaW9yaXR5KSB7XG4gICAgICAgICAgdGhpcy5xdWV1ZUxvd1ByaW9yaXR5LnB1c2goa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcclxuICAgKiBBZGRzIGEgcmVxdWVzdCB3aXRoIGEgdW5pcXVlIGtleSB0byB0aGUgcXVldWUsIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdC5cclxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdXNlZCB0byB0cmFjayB0aGUgcmVxdWVzdC5cclxuICAgKiBAcGFyYW0gcmVxdWVzdEFjdGlvbiBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHRvIGNvbXBsZXRlIHRoZSByZXF1ZXN0LiBUaGUgZnVuY3Rpb25cclxuICAgKiAgd2lsbCBiZSBydW4gb25seSBvbmNlIHBlciB1bmlxdWUga2V5IHdoaWxlIHRoZSByZXF1ZXN0IGV4aXN0cywgYW5kIG1heSBiZSBkZWZlcnJlZCBieSB0aGVcclxuICAgKiAgcXVldWUgYXQgYW55IHRpbWUuXHJcbiAgICogQHBhcmFtIGxvd1ByaW9yaXR5IFdoZXRoZXIgdGhpcyByZXF1ZXN0IHNob3VsZCBiZSBhZGRlZCB3aXRoIGxvdyBwcmlvcml0eS4gRmFsc2UgYnkgZGVmYXVsdC5cclxuICAgKiBAcGFyYW0gZGVsYXlNcyBNaW5pbXVtIGRlbGF5LCBpbiBtaWxsaXNlY29uZHMsIGJlZm9yZSB0aGlzIHJlcXVlc3Qgc2hvdWxkIGJlIGV4ZWN1dGVkLlxyXG4gICAqXHJcbiAgICogTk9URTogQ2FuY2VsbGluZyBhIHJlcXVlc3Qgd2hpbGUgdGhlIGFjdGlvbiBpcyBydW5uaW5nIFdJTEwgTk9UIHN0b3AgdGhlIGFjdGlvbi4gSWYgdGhpcyBiZWhhdmlvciBpcyBkZXNpcmVkLFxyXG4gICAqIGFjdGlvbnMgbXVzdCBiZSByZXNwb25zaWJsZSBmb3IgY2hlY2tpbmcgdGhlIFJlcXVlc3RRdWV1ZSwgZGV0ZXJtaW5pbmcgaWYgdGhlIHJlcXVlc3QgaXMgc3RpbGwgdmFsaWQgKGUuZy5cclxuICAgKiB1c2luZyBgLmhhc1JlcXVlc3QoKWApLCBhbmQgc3RvcHBpbmcgb3IgcmV0dXJuaW5nIGVhcmx5LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9uIGNvbXBsZXRpb24gb2YgdGhlIHJlcXVlc3QsIG9yIHJlamVjdCBpZiB0aGUgcmVxdWVzdCBpcyBjYW5jZWxsZWQuXHJcbiAgICogIElmIG11bHRpcGxlIHJlcXVlc3RzIGFyZSBpc3N1ZWQgd2l0aCB0aGUgc2FtZSBrZXksIGEgcHJvbWlzZSBmb3IgdGhlIGZpcnN0IHJlcXVlc3Qgd2lsbCBiZSByZXR1cm5lZFxyXG4gICAqICB1bnRpbCB0aGUgcmVxdWVzdCBpcyByZXNvbHZlZCBvciBjYW5jZWxsZWQuXHJcbiAgICogIE5vdGUgdGhhdCB0aGUgcmV0dXJuIHR5cGUgb2YgdGhlIHByb21pc2Ugd2lsbCBtYXRjaCB0aGF0IG9mIHRoZSBmaXJzdCByZXF1ZXN0J3MgaW5zdGFuY2UuXHJcbiAgICovXG4gIGFkZFJlcXVlc3Qoa2V5LCByZXF1ZXN0QWN0aW9uLCBsb3dQcmlvcml0eSA9IGZhbHNlLCBkZWxheU1zID0gMCkge1xuICAgIGlmICghdGhpcy5hbGxSZXF1ZXN0cy5oYXMoa2V5KSkge1xuICAgICAgLy8gTmV3IHJlcXVlc3QhXG4gICAgICBjb25zdCByZXF1ZXN0SXRlbSA9IHRoaXMucmVnaXN0ZXJSZXF1ZXN0KGtleSwgcmVxdWVzdEFjdGlvbik7XG4gICAgICAvLyBJZiBhIGRlbGF5IGlzIHNldCwgd2FpdCB0byBhZGQgdGhpcyB0byB0aGUgcXVldWUuXG4gICAgICBpZiAoZGVsYXlNcyA+IDApIHtcbiAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmFkZFJlcXVlc3RUb1F1ZXVlKGtleSwgbG93UHJpb3JpdHkpLCBkZWxheU1zKTtcbiAgICAgICAgLy8gU2F2ZSB0aW1lb3V0IGluZm9ybWF0aW9uIHRvIHJlcXVlc3QgbWV0YWRhdGFcbiAgICAgICAgcmVxdWVzdEl0ZW0udGltZW91dElkID0gdGltZW91dElkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gZGVsYXksIGFkZCBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLmFkZFJlcXVlc3RUb1F1ZXVlKGtleSwgbG93UHJpb3JpdHkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsb3dQcmlvcml0eUluZGV4ID0gdGhpcy5xdWV1ZUxvd1ByaW9yaXR5LmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmIChsb3dQcmlvcml0eUluZGV4ID4gLTEgJiYgIWxvd1ByaW9yaXR5KSB7XG4gICAgICAgIC8vIFRoaXMgcmVxdWVzdCBpcyByZWdpc3RlcmVkIGFuZCBxdWV1ZWQsIGJ1dCBpcyBub3cgYmVpbmcgcmVxdWVzdGVkIHdpdGggaGlnaCBwcmlvcml0eS5cbiAgICAgICAgLy8gUHJvbW90ZSBpdCB0byBoaWdoIHByaW9yaXR5LlxuICAgICAgICB0aGlzLnF1ZXVlTG93UHJpb3JpdHkuc3BsaWNlKGxvd1ByaW9yaXR5SW5kZXgsIDEpO1xuICAgICAgICB0aGlzLmFkZFJlcXVlc3RUb1F1ZXVlKGtleSk7XG4gICAgICB9IGVsc2UgaWYgKGRlbGF5TXMgPD0gMCkge1xuICAgICAgICAvLyBUaGlzIHJlcXVlc3QgaXMgcmVnaXN0ZXJlZCwgYnV0IGlzIG5vdyBiZWluZyByZXF1ZXN0ZWQgd2l0aG91dCBhIGRlbGF5LlxuICAgICAgICAvLyBNb3ZlIGludG8gcXVldWUgaW1tZWRpYXRlbHkgaWYgaXQncyBub3QgYWxyZWFkeSBhZGRlZCwgYW5kIGNsZWFyIGFueSB0aW1lb3V0cyBpdCBtYXkgaGF2ZS5cbiAgICAgICAgdGhpcy5hZGRSZXF1ZXN0VG9RdWV1ZShrZXksIGxvd1ByaW9yaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuYWxsUmVxdWVzdHMuZ2V0KGtleSk/LnByb21pc2U7XG4gICAgaWYgKCFwcm9taXNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb3VuZCBubyBwcm9taXNlIHRvIHJldHVybiB3aGVuIGdldHRpbmcgc3RvcmVkIHJlcXVlc3QgZGF0YS5cIik7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgLyoqXHJcbiAgICogQWRkcyBtdWx0aXBsZSByZXF1ZXN0cyB0byB0aGUgcXVldWUsIHdpdGggYW4gb3B0aW9uYWwgZGVsYXkgYmV0d2VlbiBlYWNoLlxyXG4gICAqIEBwYXJhbSByZXF1ZXN0cyBBbiBhcnJheSBvZiBSZXF1ZXN0SXRlbXMsIHdoaWNoIGluY2x1ZGUgYSBrZXkgYW5kIGEgcmVxdWVzdCBhY3Rpb24uXHJcbiAgICogQHBhcmFtIGxvd1ByaW9yaXR5IFdoZXRoZXIgdGhlc2UgcmVxdWVzdHMgc2hvdWxkIGJlIGFkZGVkIHdpdGggbG93IHByaW9yaXR5LiBGYWxzZSBieSBkZWZhdWx0LlxyXG4gICAqIEBwYXJhbSBkZWxheU1zIEFuIG9wdGlvbmFsIG1pbmltdW0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzIHRvIGJlIGFkZGVkIGJldHdlZW4gZWFjaCByZXF1ZXN0LlxyXG4gICAqICBGb3IgZXhhbXBsZSwgYSBkZWxheSBvZiAxMCBtcyB3aWxsIGNhdXNlIHRoZSBzZWNvbmQgcmVxdWVzdCB0byBiZSBhZGRlZCB0byB0aGUgcHJvY2Vzc2luZyBxdWV1ZVxyXG4gICAqICBhZnRlciAxMCBtcywgdGhlIHRoaXJkIHRvIGFkZGVkIGFmdGVyIDIwIG1zLCBhbmQgc28gb24uIFNldCB0byAxMCBtcyBieSBkZWZhdWx0LlxyXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHByb21pc2VzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3ZpZGVkIHJlcXVlc3RzLiAoaS5lLiwgdGhlIGBpYHRoIHZhbHVlXHJcbiAgICogb2YgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgYmUgYSBQcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiBgcmVxdWVzdHNbaV1gKS4gSWYgYSByZXF1ZXN0XHJcbiAgICogIHdpdGggYSBtYXRjaGluZyBrZXkgaXMgYWxyZWFkeSBwZW5kaW5nLCByZXR1cm5zIHRoZSBwcm9taXNlIGZvciB0aGUgaW5pdGlhbCByZXF1ZXN0LlxyXG4gICAqL1xuICBhZGRSZXF1ZXN0cyhyZXF1ZXN0cywgbG93UHJpb3JpdHkgPSBmYWxzZSwgZGVsYXlNcyA9IDEwKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gcmVxdWVzdHNbaV07XG4gICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5hZGRSZXF1ZXN0KGl0ZW0ua2V5LCBpdGVtLnJlcXVlc3RBY3Rpb24sIGxvd1ByaW9yaXR5LCBkZWxheU1zICogaSk7XG4gICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZXM7XG4gIH1cblxuICAvKipcclxuICAgKiBBdHRlbXB0cyB0byByZW1vdmUgYW5kIHJ1biB0aGUgbmV4dCBxdWV1ZWQgcmVxdWVzdCBpdGVtLCBpZiByZXNvdXJjZXMgYXJlIGF2YWlsYWJsZS5cclxuICAgKiBAcmV0dXJucyB0cnVlIGlmIGEgcmVxdWVzdCB3YXMgc3RhcnRlZCwgb3IgZmFsc2UgaWYgdGhlcmUgYXJlIHRvbyBtYW55XHJcbiAgICogcmVxdWVzdHMgYWxyZWFkeSBhY3RpdmUuXHJcbiAgICovXG4gIGFzeW5jIGRlcXVldWUoKSB7XG4gICAgY29uc3QgbnVtUmVxdWVzdHMgPSB0aGlzLmFjdGl2ZVJlcXVlc3RzLnNpemU7XG4gICAgaWYgKG51bVJlcXVlc3RzID49IHRoaXMubWF4QWN0aXZlUmVxdWVzdHMgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDAgJiYgKG51bVJlcXVlc3RzID49IHRoaXMubWF4TG93UHJpb3JpdHlSZXF1ZXN0cyB8fCB0aGlzLnF1ZXVlTG93UHJpb3JpdHkubGVuZ3RoID09PSAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0S2V5ID0gdGhpcy5xdWV1ZS5zaGlmdCgpID8/IHRoaXMucXVldWVMb3dQcmlvcml0eS5zaGlmdCgpO1xuICAgIGlmICghcmVxdWVzdEtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5hY3RpdmVSZXF1ZXN0cy5oYXMocmVxdWVzdEtleSkpIHtcbiAgICAgIC8vIFRoaXMgcmVxdWVzdCBpcyBhbHJlYWR5IGFjdGl2ZSwgdHJ5IHRoZSBuZXh0IG9uZSBpbnN0ZWFkLiAodGhpcyBzaG91bGRuJ3QgaGFwcGVuKVxuICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RJdGVtID0gdGhpcy5hbGxSZXF1ZXN0cy5nZXQocmVxdWVzdEtleSk7XG4gICAgaWYgKCFyZXF1ZXN0SXRlbSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSByZXF1ZXN0SXRlbS5rZXk7XG4gICAgLy8gTWFyayB0aGF0IHRoaXMgcmVxdWVzdCBpcyBhY3RpdmVcbiAgICB0aGlzLmFjdGl2ZVJlcXVlc3RzLmFkZChrZXkpO1xuICAgIGF3YWl0IHJlcXVlc3RJdGVtLmFjdGlvbigpLnRoZW4ocmVxdWVzdEl0ZW0ucmVzb2x2ZSwgcmVxdWVzdEl0ZW0ucmVqZWN0KTtcbiAgICB0aGlzLmFjdGl2ZVJlcXVlc3RzLmRlbGV0ZShrZXkpO1xuICAgIHRoaXMuYWxsUmVxdWVzdHMuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5kZXF1ZXVlKCk7XG4gIH1cblxuICAvKipcclxuICAgKiBSZW1vdmVzIGFueSByZXF1ZXN0IG1hdGNoaW5nIHRoZSBwcm92aWRlZCBrZXkgZnJvbSB0aGUgcXVldWUgYW5kIHJlamVjdHMgaXRzIHByb21pc2UuXHJcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IHRoYXQgc2hvdWxkIGJlIG1hdGNoZWQgYWdhaW5zdC5cclxuICAgKiBAcGFyYW0gY2FuY2VsUmVhc29uIEEgbWVzc2FnZSBvciBvYmplY3QgdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIHByb21pc2UgcmVqZWN0aW9uLlxyXG4gICAqL1xuICBjYW5jZWxSZXF1ZXN0KGtleSwgY2FuY2VsUmVhc29uID0gREVGQVVMVF9SRVFVRVNUX0NBTkNFTF9SRUFTT04pIHtcbiAgICBpZiAoIXRoaXMuYWxsUmVxdWVzdHMuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdEl0ZW0gPSB0aGlzLmFsbFJlcXVlc3RzLmdldChrZXkpO1xuICAgIGlmIChyZXF1ZXN0SXRlbSkge1xuICAgICAgaWYgKHJlcXVlc3RJdGVtLnRpbWVvdXRJZCkge1xuICAgICAgICAvLyBDYW5jZWwgcmVxdWVzdHMgdGhhdCBoYXZlIG5vdCBiZWVuIHF1ZXVlZCB5ZXQuXG4gICAgICAgIGNsZWFyVGltZW91dChyZXF1ZXN0SXRlbS50aW1lb3V0SWQpO1xuICAgICAgfVxuICAgICAgLy8gUmVqZWN0IHRoZSByZXF1ZXN0LCB0aGVuIGNsZWFyIGZyb20gdGhlIHF1ZXVlIGFuZCBrbm93biByZXF1ZXN0cy5cbiAgICAgIHJlcXVlc3RJdGVtLnJlamVjdChjYW5jZWxSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBxdWV1ZUluZGV4ID0gdGhpcy5xdWV1ZS5pbmRleE9mKGtleSk7XG4gICAgaWYgKHF1ZXVlSW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5xdWV1ZS5zcGxpY2UocXVldWVJbmRleCwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxvd1ByaW9yaXR5SW5kZXggPSB0aGlzLnF1ZXVlTG93UHJpb3JpdHkuaW5kZXhPZihrZXkpO1xuICAgICAgaWYgKGxvd1ByaW9yaXR5SW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLnF1ZXVlTG93UHJpb3JpdHkuc3BsaWNlKGxvd1ByaW9yaXR5SW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFsbFJlcXVlc3RzLmRlbGV0ZShrZXkpO1xuICAgIHRoaXMuYWN0aXZlUmVxdWVzdHMuZGVsZXRlKGtleSk7XG4gIH1cblxuICAvKipcclxuICAgKiBSZWplY3RzIGFsbCByZXF1ZXN0IHByb21pc2VzIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLlxyXG4gICAqIEBwYXJhbSBjYW5jZWxSZWFzb24gQSBtZXNzYWdlIG9yIG9iamVjdCB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGUgcHJvbWlzZSByZWplY3Rpb24uXHJcbiAgICovXG4gIGNhbmNlbEFsbFJlcXVlc3RzKGNhbmNlbFJlYXNvbiA9IERFRkFVTFRfUkVRVUVTVF9DQU5DRUxfUkVBU09OKSB7XG4gICAgLy8gQ2xlYXIgdGhlIHF1ZXVlIHNvIHdlIGRvbid0IGRvIGV4dHJhIHdvcmsgd2hpbGUgZmlsdGVyaW5nIGl0XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMucXVldWVMb3dQcmlvcml0eSA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuYWxsUmVxdWVzdHMua2V5cygpKSB7XG4gICAgICB0aGlzLmNhbmNlbFJlcXVlc3Qoa2V5LCBjYW5jZWxSZWFzb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxyXG4gICAqIFJldHVybnMgd2hldGhlciBhIHJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4ga2V5IGV4aXN0cyBpbiB0aGUgUmVxdWVzdFF1ZXVlIGFuZCBpcyBub3QgY2FuY2VsbGVkLlxyXG4gICAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byBzZWFyY2ggZm9yLlxyXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHJlcXVlc3QgaXMgaW4gdGhlIFJlcXVlc3RRdWV1ZS5cclxuICAgKi9cbiAgaGFzUmVxdWVzdChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxSZXF1ZXN0cy5oYXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcmVxdWVzdCB3aXRoIHRoZSBnaXZlbiBrZXkgaXMgY3VycmVudGx5IHJ1bm5pbmcgKG5vdCB3YWl0aW5nIGluIHRoZSBxdWV1ZSkuXHJcbiAgICogQHBhcmFtIGtleSB0aGUga2V5IHRvIHNlYXJjaCBmb3IuXHJcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBpcyBhY3RpdmVseSBydW5uaW5nLlxyXG4gICAqL1xuICByZXF1ZXN0UnVubmluZyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVSZXF1ZXN0cy5oYXMoa2V5KTtcbiAgfVxufSJdLCJuYW1lcyI6WyJERUZBVUxUX1JFUVVFU1RfQ0FOQ0VMX1JFQVNPTiIsIlJlcXVlc3RRdWV1ZSIsImNvbnN0cnVjdG9yIiwibWF4QWN0aXZlUmVxdWVzdHMiLCJtYXhMb3dQcmlvcml0eVJlcXVlc3RzIiwiYWxsUmVxdWVzdHMiLCJNYXAiLCJhY3RpdmVSZXF1ZXN0cyIsIlNldCIsInF1ZXVlIiwicXVldWVMb3dQcmlvcml0eSIsIk1hdGgiLCJtaW4iLCJyZWdpc3RlclJlcXVlc3QiLCJrZXkiLCJyZXF1ZXN0QWN0aW9uIiwicHJvbWlzZVJlc29sdmUiLCJwcm9taXNlUmVqZWN0IiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVxdWVzdEl0ZW0iLCJhY3Rpb24iLCJzZXQiLCJhZGRSZXF1ZXN0VG9RdWV1ZSIsImxvd1ByaW9yaXR5IiwiaGFzIiwiZ2V0IiwidGltZW91dElkIiwiY2xlYXJUaW1lb3V0IiwidW5kZWZpbmVkIiwiaW5jbHVkZXMiLCJwdXNoIiwiZGVxdWV1ZSIsImFkZFJlcXVlc3QiLCJkZWxheU1zIiwic2V0VGltZW91dCIsImxvd1ByaW9yaXR5SW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiRXJyb3IiLCJhZGRSZXF1ZXN0cyIsInJlcXVlc3RzIiwicHJvbWlzZXMiLCJpIiwibGVuZ3RoIiwiaXRlbSIsIm51bVJlcXVlc3RzIiwic2l6ZSIsInJlcXVlc3RLZXkiLCJzaGlmdCIsImFkZCIsInRoZW4iLCJkZWxldGUiLCJjYW5jZWxSZXF1ZXN0IiwiY2FuY2VsUmVhc29uIiwicXVldWVJbmRleCIsImNhbmNlbEFsbFJlcXVlc3RzIiwia2V5cyIsImhhc1JlcXVlc3QiLCJyZXF1ZXN0UnVubmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../volume-viewer/es/utils/RequestQueue.js\n");

/***/ }),

/***/ "../volume-viewer/es/utils/SubscribableRequestQueue.js":
/*!*************************************************************!*\
  !*** ../volume-viewer/es/utils/SubscribableRequestQueue.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SubscribableRequestQueue)\n/* harmony export */ });\n/* harmony import */ var _RequestQueue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RequestQueue.js */ \"../volume-viewer/es/utils/RequestQueue.js\");\n\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\r\n * An extension of `RequestQueue` that adds a concept of \"subscribers,\" which may share references to a single request\r\n * or cancel their subscription without disrupting the request for other subscribers.\r\n */\nclass SubscribableRequestQueue {\n  /** The next unused subscriber ID. Increments whenever a subscriber is added. */\n\n  /**\r\n   * Map of subscribers keyed by ID. Subscribers store a map to all their subscriptions by request key.\r\n   * Subscribers are only useful as handles to cancel subscriptions early, so we only need to store rejecters here.\r\n   */\n\n  /** Map from \"inner\" request (managed by `queue`) to \"outer\" promises generated per-subscriber. */\n\n  /**\r\n   * Since `SubscribableRequestQueue` wraps `RequestQueue`, its constructor may either take the same arguments as the\r\n   * `RequestQueue` constructor and create a new `RequestQueue`, or it may take an existing `RequestQueue` to wrap.\r\n   */\n\n  constructor(maxActiveRequests, maxLowPriorityRequests) {\n    if (typeof maxActiveRequests === \"number\" || maxActiveRequests === undefined) {\n      this.queue = new _RequestQueue_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](maxActiveRequests, maxLowPriorityRequests);\n    } else {\n      this.queue = maxActiveRequests;\n    }\n    this.nextSubscriberId = 0;\n    this.subscribers = new Map();\n    this.requests = new Map();\n  }\n\n  /** Resolves all subscriptions to request `key` with `value` */\n  resolveAll(key, value) {\n    const requests = this.requests.get(key);\n    if (requests) {\n      for (const {\n        resolve,\n        subscriberId\n      } of requests) {\n        resolve(value);\n        this.subscribers.get(subscriberId)?.delete(key);\n      }\n      this.requests.delete(key);\n    }\n  }\n\n  /** Rejects all subscriptions to request `key` with `reason` */\n  rejectAll(key, reason) {\n    const requests = this.requests.get(key);\n    if (requests) {\n      for (const {\n        reject,\n        subscriberId\n      } of requests) {\n        reject(reason);\n        this.subscribers.get(subscriberId)?.delete(key);\n      }\n      this.requests.delete(key);\n    }\n  }\n\n  /** Adds a new request subscriber. Returns a unique ID to identify this subscriber. */\n  addSubscriber() {\n    const subscriberId = this.nextSubscriberId;\n    this.nextSubscriberId++;\n    this.subscribers.set(subscriberId, new Map());\n    return subscriberId;\n  }\n\n  /**\r\n   * Queues a new request, or adds a subscription if the request is already queued/running.\r\n   *\r\n   * If `subscriberId` is already subscribed to the request, this rejects the existing promise and returns a new one.\r\n   */\n  addRequest(key, subscriberId, requestAction, lowPriority, delayMs) {\n    // Create single underlying request if it does not yet exist\n    this.queue.addRequest(key, requestAction, lowPriority, delayMs).then(value => this.resolveAll(key, value)).catch(reason => this.rejectAll(key, reason));\n    if (!this.requests.has(key)) {\n      this.requests.set(key, []);\n    }\n\n    // Validate subscriber\n    if (subscriberId >= this.nextSubscriberId || subscriberId < 0) {\n      throw new Error(`SubscribableRequestQueue: subscriber id ${subscriberId} has not been registered`);\n    }\n    const subscriber = this.subscribers.get(subscriberId);\n    if (!subscriber) {\n      throw new Error(`SubscribableRequestQueue: subscriber id ${subscriberId} has been removed`);\n    }\n    const existingRequest = subscriber.get(key);\n    if (existingRequest) {\n      this.rejectSubscription(key, existingRequest, \"SubscribableRequestQueue: request re-queued while running\");\n    }\n\n    // Create promise and add to list of requests\n    return new Promise((resolve, reject) => {\n      this.requests.get(key)?.push({\n        resolve,\n        reject,\n        subscriberId\n      });\n      this.subscribers.get(subscriberId)?.set(key, reject);\n    });\n  }\n\n  /**\r\n   * Rejects a subscription and removes it from the list of subscriptions for a request, then cancels the underlying\r\n   * request if it is no longer subscribed and is not running already.\r\n   */\n  rejectSubscription(key, reject, cancelReason) {\n    // Reject the outer \"subscription\" promise\n    reject(cancelReason);\n\n    // Get the list of subscriptions for this request\n    const subscriptions = this.requests.get(key);\n    if (!subscriptions) {\n      // This should never happen\n      return;\n    }\n    // Remove this request subscription by ref equality to `reject`\n    const idx = subscriptions.findIndex(sub => sub.reject === reject);\n    if (idx >= 0) {\n      subscriptions.splice(idx, 1);\n    }\n\n    // Remove the underlying request if there are no more subscribers and the request is not already running\n    if (subscriptions.length < 1 && !this.queue.requestRunning(key)) {\n      this.queue.cancelRequest(key, cancelReason);\n      this.requests.delete(key);\n    }\n  }\n\n  /** Cancels a request subscription, and cancels the underlying request if it is no longer subscribed or running. */\n  cancelRequest(key, subscriberId, cancelReason) {\n    const subscriber = this.subscribers.get(subscriberId);\n    if (!subscriber) {\n      return false;\n    }\n    const reject = subscriber.get(key);\n    if (!reject) {\n      return false;\n    }\n    this.rejectSubscription(key, reject, cancelReason);\n    subscriber.delete(key);\n    return true;\n  }\n\n  /** Removes a subscriber and cancels its remaining subscriptions. */\n  removeSubscriber(subscriberId, cancelReason) {\n    const subscriptions = this.subscribers.get(subscriberId);\n    if (subscriptions) {\n      for (const [key, reject] of subscriptions.entries()) {\n        this.rejectSubscription(key, reject, cancelReason);\n      }\n      this.subscribers.delete(subscriberId);\n    }\n  }\n\n  /** Returns whether a request with the given `key` is running or waiting in the queue */\n  hasRequest(key) {\n    return this.queue.hasRequest(key);\n  }\n\n  /** Returns whether a request with the given `key` is running */\n  requestRunning(key) {\n    return this.queue.requestRunning(key);\n  }\n\n  /** Returns whether a subscriber with the given `subscriberId` exists */\n  hasSubscriber(subscriberId) {\n    return this.subscribers.has(subscriberId);\n  }\n\n  /** Returns whether a subscriber with the given `subscriberId` is subscribed to the request with the given `key` */\n  isSubscribed(subscriberId, key) {\n    return this.subscribers.get(subscriberId)?.has(key) ?? false;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy91dGlscy9TdWJzY3JpYmFibGVSZXF1ZXN0UXVldWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNkM7O0FBRTdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsTUFBTUMsd0JBQXdCLENBQUM7RUFDNUM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7O0VBRUU7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7O0VBRUVDLFdBQVdBLENBQUNDLGlCQUFpQixFQUFFQyxzQkFBc0IsRUFBRTtJQUNyRCxJQUFJLE9BQU9ELGlCQUFpQixLQUFLLFFBQVEsSUFBSUEsaUJBQWlCLEtBQUtFLFNBQVMsRUFBRTtNQUM1RSxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJTix3REFBWSxDQUFDRyxpQkFBaUIsRUFBRUMsc0JBQXNCLENBQUM7SUFDMUUsQ0FBQyxNQUFNO01BQ0wsSUFBSSxDQUFDRSxLQUFLLEdBQUdILGlCQUFpQjtJQUNoQztJQUNBLElBQUksQ0FBQ0ksZ0JBQWdCLEdBQUcsQ0FBQztJQUN6QixJQUFJLENBQUNDLFdBQVcsR0FBRyxJQUFJQyxHQUFHLENBQUMsQ0FBQztJQUM1QixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJRCxHQUFHLENBQUMsQ0FBQztFQUMzQjs7RUFFQTtFQUNBRSxVQUFVQSxDQUFDQyxHQUFHLEVBQUVDLEtBQUssRUFBRTtJQUNyQixNQUFNSCxRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRLENBQUNJLEdBQUcsQ0FBQ0YsR0FBRyxDQUFDO0lBQ3ZDLElBQUlGLFFBQVEsRUFBRTtNQUNaLEtBQUssTUFBTTtRQUNUSyxPQUFPO1FBQ1BDO01BQ0YsQ0FBQyxJQUFJTixRQUFRLEVBQUU7UUFDYkssT0FBTyxDQUFDRixLQUFLLENBQUM7UUFDZCxJQUFJLENBQUNMLFdBQVcsQ0FBQ00sR0FBRyxDQUFDRSxZQUFZLENBQUMsRUFBRUMsTUFBTSxDQUFDTCxHQUFHLENBQUM7TUFDakQ7TUFDQSxJQUFJLENBQUNGLFFBQVEsQ0FBQ08sTUFB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L0BhaWNzL3dlYi0zZC12aWV3ZXIvLi4vdm9sdW1lLXZpZXdlci9lcy91dGlscy9TdWJzY3JpYmFibGVSZXF1ZXN0UXVldWUuanM/YTAzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVxdWVzdFF1ZXVlIGZyb20gXCIuL1JlcXVlc3RRdWV1ZS5qc1wiO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4vKipcclxuICogQW4gZXh0ZW5zaW9uIG9mIGBSZXF1ZXN0UXVldWVgIHRoYXQgYWRkcyBhIGNvbmNlcHQgb2YgXCJzdWJzY3JpYmVycyxcIiB3aGljaCBtYXkgc2hhcmUgcmVmZXJlbmNlcyB0byBhIHNpbmdsZSByZXF1ZXN0XHJcbiAqIG9yIGNhbmNlbCB0aGVpciBzdWJzY3JpcHRpb24gd2l0aG91dCBkaXNydXB0aW5nIHRoZSByZXF1ZXN0IGZvciBvdGhlciBzdWJzY3JpYmVycy5cclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWJzY3JpYmFibGVSZXF1ZXN0UXVldWUge1xuICAvKiogVGhlIG5leHQgdW51c2VkIHN1YnNjcmliZXIgSUQuIEluY3JlbWVudHMgd2hlbmV2ZXIgYSBzdWJzY3JpYmVyIGlzIGFkZGVkLiAqL1xuXG4gIC8qKlxyXG4gICAqIE1hcCBvZiBzdWJzY3JpYmVycyBrZXllZCBieSBJRC4gU3Vic2NyaWJlcnMgc3RvcmUgYSBtYXAgdG8gYWxsIHRoZWlyIHN1YnNjcmlwdGlvbnMgYnkgcmVxdWVzdCBrZXkuXHJcbiAgICogU3Vic2NyaWJlcnMgYXJlIG9ubHkgdXNlZnVsIGFzIGhhbmRsZXMgdG8gY2FuY2VsIHN1YnNjcmlwdGlvbnMgZWFybHksIHNvIHdlIG9ubHkgbmVlZCB0byBzdG9yZSByZWplY3RlcnMgaGVyZS5cclxuICAgKi9cblxuICAvKiogTWFwIGZyb20gXCJpbm5lclwiIHJlcXVlc3QgKG1hbmFnZWQgYnkgYHF1ZXVlYCkgdG8gXCJvdXRlclwiIHByb21pc2VzIGdlbmVyYXRlZCBwZXItc3Vic2NyaWJlci4gKi9cblxuICAvKipcclxuICAgKiBTaW5jZSBgU3Vic2NyaWJhYmxlUmVxdWVzdFF1ZXVlYCB3cmFwcyBgUmVxdWVzdFF1ZXVlYCwgaXRzIGNvbnN0cnVjdG9yIG1heSBlaXRoZXIgdGFrZSB0aGUgc2FtZSBhcmd1bWVudHMgYXMgdGhlXHJcbiAgICogYFJlcXVlc3RRdWV1ZWAgY29uc3RydWN0b3IgYW5kIGNyZWF0ZSBhIG5ldyBgUmVxdWVzdFF1ZXVlYCwgb3IgaXQgbWF5IHRha2UgYW4gZXhpc3RpbmcgYFJlcXVlc3RRdWV1ZWAgdG8gd3JhcC5cclxuICAgKi9cblxuICBjb25zdHJ1Y3RvcihtYXhBY3RpdmVSZXF1ZXN0cywgbWF4TG93UHJpb3JpdHlSZXF1ZXN0cykge1xuICAgIGlmICh0eXBlb2YgbWF4QWN0aXZlUmVxdWVzdHMgPT09IFwibnVtYmVyXCIgfHwgbWF4QWN0aXZlUmVxdWVzdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBSZXF1ZXN0UXVldWUobWF4QWN0aXZlUmVxdWVzdHMsIG1heExvd1ByaW9yaXR5UmVxdWVzdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnF1ZXVlID0gbWF4QWN0aXZlUmVxdWVzdHM7XG4gICAgfVxuICAgIHRoaXMubmV4dFN1YnNjcmliZXJJZCA9IDA7XG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnJlcXVlc3RzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLyoqIFJlc29sdmVzIGFsbCBzdWJzY3JpcHRpb25zIHRvIHJlcXVlc3QgYGtleWAgd2l0aCBgdmFsdWVgICovXG4gIHJlc29sdmVBbGwoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHJlcXVlc3RzID0gdGhpcy5yZXF1ZXN0cy5nZXQoa2V5KTtcbiAgICBpZiAocmVxdWVzdHMpIHtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICByZXNvbHZlLFxuICAgICAgICBzdWJzY3JpYmVySWRcbiAgICAgIH0gb2YgcmVxdWVzdHMpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlcnMuZ2V0KHN1YnNjcmliZXJJZCk/LmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXF1ZXN0cy5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cblxuICAvKiogUmVqZWN0cyBhbGwgc3Vic2NyaXB0aW9ucyB0byByZXF1ZXN0IGBrZXlgIHdpdGggYHJlYXNvbmAgKi9cbiAgcmVqZWN0QWxsKGtleSwgcmVhc29uKSB7XG4gICAgY29uc3QgcmVxdWVzdHMgPSB0aGlzLnJlcXVlc3RzLmdldChrZXkpO1xuICAgIGlmIChyZXF1ZXN0cykge1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIHJlamVjdCxcbiAgICAgICAgc3Vic2NyaWJlcklkXG4gICAgICB9IG9mIHJlcXVlc3RzKSB7XG4gICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmdldChzdWJzY3JpYmVySWQpPy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVxdWVzdHMuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEFkZHMgYSBuZXcgcmVxdWVzdCBzdWJzY3JpYmVyLiBSZXR1cm5zIGEgdW5pcXVlIElEIHRvIGlkZW50aWZ5IHRoaXMgc3Vic2NyaWJlci4gKi9cbiAgYWRkU3Vic2NyaWJlcigpIHtcbiAgICBjb25zdCBzdWJzY3JpYmVySWQgPSB0aGlzLm5leHRTdWJzY3JpYmVySWQ7XG4gICAgdGhpcy5uZXh0U3Vic2NyaWJlcklkKys7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5zZXQoc3Vic2NyaWJlcklkLCBuZXcgTWFwKCkpO1xuICAgIHJldHVybiBzdWJzY3JpYmVySWQ7XG4gIH1cblxuICAvKipcclxuICAgKiBRdWV1ZXMgYSBuZXcgcmVxdWVzdCwgb3IgYWRkcyBhIHN1YnNjcmlwdGlvbiBpZiB0aGUgcmVxdWVzdCBpcyBhbHJlYWR5IHF1ZXVlZC9ydW5uaW5nLlxyXG4gICAqXHJcbiAgICogSWYgYHN1YnNjcmliZXJJZGAgaXMgYWxyZWFkeSBzdWJzY3JpYmVkIHRvIHRoZSByZXF1ZXN0LCB0aGlzIHJlamVjdHMgdGhlIGV4aXN0aW5nIHByb21pc2UgYW5kIHJldHVybnMgYSBuZXcgb25lLlxyXG4gICAqL1xuICBhZGRSZXF1ZXN0KGtleSwgc3Vic2NyaWJlcklkLCByZXF1ZXN0QWN0aW9uLCBsb3dQcmlvcml0eSwgZGVsYXlNcykge1xuICAgIC8vIENyZWF0ZSBzaW5nbGUgdW5kZXJseWluZyByZXF1ZXN0IGlmIGl0IGRvZXMgbm90IHlldCBleGlzdFxuICAgIHRoaXMucXVldWUuYWRkUmVxdWVzdChrZXksIHJlcXVlc3RBY3Rpb24sIGxvd1ByaW9yaXR5LCBkZWxheU1zKS50aGVuKHZhbHVlID0+IHRoaXMucmVzb2x2ZUFsbChrZXksIHZhbHVlKSkuY2F0Y2gocmVhc29uID0+IHRoaXMucmVqZWN0QWxsKGtleSwgcmVhc29uKSk7XG4gICAgaWYgKCF0aGlzLnJlcXVlc3RzLmhhcyhrZXkpKSB7XG4gICAgICB0aGlzLnJlcXVlc3RzLnNldChrZXksIFtdKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBzdWJzY3JpYmVyXG4gICAgaWYgKHN1YnNjcmliZXJJZCA+PSB0aGlzLm5leHRTdWJzY3JpYmVySWQgfHwgc3Vic2NyaWJlcklkIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJzY3JpYmFibGVSZXF1ZXN0UXVldWU6IHN1YnNjcmliZXIgaWQgJHtzdWJzY3JpYmVySWR9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkYCk7XG4gICAgfVxuICAgIGNvbnN0IHN1YnNjcmliZXIgPSB0aGlzLnN1YnNjcmliZXJzLmdldChzdWJzY3JpYmVySWQpO1xuICAgIGlmICghc3Vic2NyaWJlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJzY3JpYmFibGVSZXF1ZXN0UXVldWU6IHN1YnNjcmliZXIgaWQgJHtzdWJzY3JpYmVySWR9IGhhcyBiZWVuIHJlbW92ZWRgKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdSZXF1ZXN0ID0gc3Vic2NyaWJlci5nZXQoa2V5KTtcbiAgICBpZiAoZXhpc3RpbmdSZXF1ZXN0KSB7XG4gICAgICB0aGlzLnJlamVjdFN1YnNjcmlwdGlvbihrZXksIGV4aXN0aW5nUmVxdWVzdCwgXCJTdWJzY3JpYmFibGVSZXF1ZXN0UXVldWU6IHJlcXVlc3QgcmUtcXVldWVkIHdoaWxlIHJ1bm5pbmdcIik7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHByb21pc2UgYW5kIGFkZCB0byBsaXN0IG9mIHJlcXVlc3RzXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVxdWVzdHMuZ2V0KGtleSk/LnB1c2goe1xuICAgICAgICByZXNvbHZlLFxuICAgICAgICByZWplY3QsXG4gICAgICAgIHN1YnNjcmliZXJJZFxuICAgICAgfSk7XG4gICAgICB0aGlzLnN1YnNjcmliZXJzLmdldChzdWJzY3JpYmVySWQpPy5zZXQoa2V5LCByZWplY3QpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXHJcbiAgICogUmVqZWN0cyBhIHN1YnNjcmlwdGlvbiBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBsaXN0IG9mIHN1YnNjcmlwdGlvbnMgZm9yIGEgcmVxdWVzdCwgdGhlbiBjYW5jZWxzIHRoZSB1bmRlcmx5aW5nXHJcbiAgICogcmVxdWVzdCBpZiBpdCBpcyBubyBsb25nZXIgc3Vic2NyaWJlZCBhbmQgaXMgbm90IHJ1bm5pbmcgYWxyZWFkeS5cclxuICAgKi9cbiAgcmVqZWN0U3Vic2NyaXB0aW9uKGtleSwgcmVqZWN0LCBjYW5jZWxSZWFzb24pIHtcbiAgICAvLyBSZWplY3QgdGhlIG91dGVyIFwic3Vic2NyaXB0aW9uXCIgcHJvbWlzZVxuICAgIHJlamVjdChjYW5jZWxSZWFzb24pO1xuXG4gICAgLy8gR2V0IHRoZSBsaXN0IG9mIHN1YnNjcmlwdGlvbnMgZm9yIHRoaXMgcmVxdWVzdFxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnJlcXVlc3RzLmdldChrZXkpO1xuICAgIGlmICghc3Vic2NyaXB0aW9ucykge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGlzIHJlcXVlc3Qgc3Vic2NyaXB0aW9uIGJ5IHJlZiBlcXVhbGl0eSB0byBgcmVqZWN0YFxuICAgIGNvbnN0IGlkeCA9IHN1YnNjcmlwdGlvbnMuZmluZEluZGV4KHN1YiA9PiBzdWIucmVqZWN0ID09PSByZWplY3QpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgc3Vic2NyaXB0aW9ucy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdGhlIHVuZGVybHlpbmcgcmVxdWVzdCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBzdWJzY3JpYmVycyBhbmQgdGhlIHJlcXVlc3QgaXMgbm90IGFscmVhZHkgcnVubmluZ1xuICAgIGlmIChzdWJzY3JpcHRpb25zLmxlbmd0aCA8IDEgJiYgIXRoaXMucXVldWUucmVxdWVzdFJ1bm5pbmcoa2V5KSkge1xuICAgICAgdGhpcy5xdWV1ZS5jYW5jZWxSZXF1ZXN0KGtleSwgY2FuY2VsUmVhc29uKTtcbiAgICAgIHRoaXMucmVxdWVzdHMuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIENhbmNlbHMgYSByZXF1ZXN0IHN1YnNjcmlwdGlvbiwgYW5kIGNhbmNlbHMgdGhlIHVuZGVybHlpbmcgcmVxdWVzdCBpZiBpdCBpcyBubyBsb25nZXIgc3Vic2NyaWJlZCBvciBydW5uaW5nLiAqL1xuICBjYW5jZWxSZXF1ZXN0KGtleSwgc3Vic2NyaWJlcklkLCBjYW5jZWxSZWFzb24pIHtcbiAgICBjb25zdCBzdWJzY3JpYmVyID0gdGhpcy5zdWJzY3JpYmVycy5nZXQoc3Vic2NyaWJlcklkKTtcbiAgICBpZiAoIXN1YnNjcmliZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcmVqZWN0ID0gc3Vic2NyaWJlci5nZXQoa2V5KTtcbiAgICBpZiAoIXJlamVjdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnJlamVjdFN1YnNjcmlwdGlvbihrZXksIHJlamVjdCwgY2FuY2VsUmVhc29uKTtcbiAgICBzdWJzY3JpYmVyLmRlbGV0ZShrZXkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIFJlbW92ZXMgYSBzdWJzY3JpYmVyIGFuZCBjYW5jZWxzIGl0cyByZW1haW5pbmcgc3Vic2NyaXB0aW9ucy4gKi9cbiAgcmVtb3ZlU3Vic2NyaWJlcihzdWJzY3JpYmVySWQsIGNhbmNlbFJlYXNvbikge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmliZXJzLmdldChzdWJzY3JpYmVySWQpO1xuICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHJlamVjdF0gb2Ygc3Vic2NyaXB0aW9ucy5lbnRyaWVzKCkpIHtcbiAgICAgICAgdGhpcy5yZWplY3RTdWJzY3JpcHRpb24oa2V5LCByZWplY3QsIGNhbmNlbFJlYXNvbik7XG4gICAgICB9XG4gICAgICB0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShzdWJzY3JpYmVySWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHdoZXRoZXIgYSByZXF1ZXN0IHdpdGggdGhlIGdpdmVuIGBrZXlgIGlzIHJ1bm5pbmcgb3Igd2FpdGluZyBpbiB0aGUgcXVldWUgKi9cbiAgaGFzUmVxdWVzdChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZS5oYXNSZXF1ZXN0KGtleSk7XG4gIH1cblxuICAvKiogUmV0dXJucyB3aGV0aGVyIGEgcmVxdWVzdCB3aXRoIHRoZSBnaXZlbiBga2V5YCBpcyBydW5uaW5nICovXG4gIHJlcXVlc3RSdW5uaW5nKGtleSkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlLnJlcXVlc3RSdW5uaW5nKGtleSk7XG4gIH1cblxuICAvKiogUmV0dXJucyB3aGV0aGVyIGEgc3Vic2NyaWJlciB3aXRoIHRoZSBnaXZlbiBgc3Vic2NyaWJlcklkYCBleGlzdHMgKi9cbiAgaGFzU3Vic2NyaWJlcihzdWJzY3JpYmVySWQpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmVycy5oYXMoc3Vic2NyaWJlcklkKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHdoZXRoZXIgYSBzdWJzY3JpYmVyIHdpdGggdGhlIGdpdmVuIGBzdWJzY3JpYmVySWRgIGlzIHN1YnNjcmliZWQgdG8gdGhlIHJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gYGtleWAgKi9cbiAgaXNTdWJzY3JpYmVkKHN1YnNjcmliZXJJZCwga2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlcnMuZ2V0KHN1YnNjcmliZXJJZCk/LmhhcyhrZXkpID8/IGZhbHNlO1xuICB9XG59Il0sIm5hbWVzIjpbIlJlcXVlc3RRdWV1ZSIsIlN1YnNjcmliYWJsZVJlcXVlc3RRdWV1ZSIsImNvbnN0cnVjdG9yIiwibWF4QWN0aXZlUmVxdWVzdHMiLCJtYXhMb3dQcmlvcml0eVJlcXVlc3RzIiwidW5kZWZpbmVkIiwicXVldWUiLCJuZXh0U3Vic2NyaWJlcklkIiwic3Vic2NyaWJlcnMiLCJNYXAiLCJyZXF1ZXN0cyIsInJlc29sdmVBbGwiLCJrZXkiLCJ2YWx1ZSIsImdldCIsInJlc29sdmUiLCJzdWJzY3JpYmVySWQiLCJkZWxldGUiLCJyZWplY3RBbGwiLCJyZWFzb24iLCJyZWplY3QiLCJhZGRTdWJzY3JpYmVyIiwic2V0IiwiYWRkUmVxdWVzdCIsInJlcXVlc3RBY3Rpb24iLCJsb3dQcmlvcml0eSIsImRlbGF5TXMiLCJ0aGVuIiwiY2F0Y2giLCJoYXMiLCJFcnJvciIsInN1YnNjcmliZXIiLCJleGlzdGluZ1JlcXVlc3QiLCJyZWplY3RTdWJzY3JpcHRpb24iLCJQcm9taXNlIiwicHVzaCIsImNhbmNlbFJlYXNvbiIsInN1YnNjcmlwdGlvbnMiLCJpZHgiLCJmaW5kSW5kZXgiLCJzdWIiLCJzcGxpY2UiLCJsZW5ndGgiLCJyZXF1ZXN0UnVubmluZyIsImNhbmNlbFJlcXVlc3QiLCJyZW1vdmVTdWJzY3JpYmVyIiwiZW50cmllcyIsImhhc1JlcXVlc3QiLCJoYXNTdWJzY3JpYmVyIiwiaXNTdWJzY3JpYmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../volume-viewer/es/utils/SubscribableRequestQueue.js\n");

/***/ }),

/***/ "../volume-viewer/es/workers/VolumeLoadWorker.js":
/*!*******************************************************!*\
  !*** ../volume-viewer/es/workers/VolumeLoadWorker.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var serialize_error__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! serialize-error */ \"../volume-viewer/node_modules/serialize-error/index.js\");\n/* harmony import */ var _VolumeCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VolumeCache.js */ \"../volume-viewer/es/VolumeCache.js\");\n/* harmony import */ var _loaders_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../loaders/index.js */ \"../volume-viewer/es/loaders/index.js\");\n/* harmony import */ var _loaders_VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../loaders/VolumeLoadError.js */ \"../volume-viewer/es/loaders/VolumeLoadError.js\");\n/* harmony import */ var _utils_RequestQueue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/RequestQueue.js */ \"../volume-viewer/es/utils/RequestQueue.js\");\n/* harmony import */ var _utils_SubscribableRequestQueue_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/SubscribableRequestQueue.js */ \"../volume-viewer/es/utils/SubscribableRequestQueue.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types.js */ \"../volume-viewer/es/workers/types.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util.js */ \"../volume-viewer/es/workers/util.js\");\n\n\n\n\n\n\n\n\nlet cache = undefined;\nlet queue = undefined;\nlet subscribableQueue = undefined;\nlet loader = undefined;\nlet initialized = false;\nlet copyOnLoad = false;\nconst messageHandlers = {\n  [_types_js__WEBPACK_IMPORTED_MODULE_5__.WorkerMsgType.INIT]: ({\n    maxCacheSize,\n    maxActiveRequests,\n    maxLowPriorityRequests\n  }) => {\n    if (!initialized) {\n      cache = new _VolumeCache_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](maxCacheSize);\n      queue = new _utils_RequestQueue_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](maxActiveRequests, maxLowPriorityRequests);\n      subscribableQueue = new _utils_SubscribableRequestQueue_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](queue);\n      initialized = true;\n    }\n    return Promise.resolve();\n  },\n  [_types_js__WEBPACK_IMPORTED_MODULE_5__.WorkerMsgType.CREATE_LOADER]: async ({\n    path,\n    options\n  }) => {\n    const pathString = Array.isArray(path) ? path[0] : path;\n    const fileType = options?.fileType || (0,_loaders_index_js__WEBPACK_IMPORTED_MODULE_1__.pathToFileType)(pathString);\n    copyOnLoad = fileType === _loaders_index_js__WEBPACK_IMPORTED_MODULE_1__.VolumeFileFormat.JSON;\n    loader = await (0,_loaders_index_js__WEBPACK_IMPORTED_MODULE_1__.createVolumeLoader)(path, {\n      ...options,\n      cache,\n      queue: subscribableQueue\n    });\n    return loader !== undefined;\n  },\n  [_types_js__WEBPACK_IMPORTED_MODULE_5__.WorkerMsgType.CREATE_VOLUME]: async loadSpec => {\n    if (loader === undefined) {\n      throw new _loaders_VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_2__.VolumeLoadError(\"No loader created\");\n    }\n    return await loader.createImageInfo((0,_util_js__WEBPACK_IMPORTED_MODULE_6__.rebuildLoadSpec)(loadSpec));\n  },\n  [_types_js__WEBPACK_IMPORTED_MODULE_5__.WorkerMsgType.LOAD_DIMS]: async loadSpec => {\n    if (loader === undefined) {\n      throw new _loaders_VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_2__.VolumeLoadError(\"No loader created\");\n    }\n    return await loader.loadDims((0,_util_js__WEBPACK_IMPORTED_MODULE_6__.rebuildLoadSpec)(loadSpec));\n  },\n  [_types_js__WEBPACK_IMPORTED_MODULE_5__.WorkerMsgType.LOAD_VOLUME_DATA]: ({\n    imageInfo,\n    loadSpec,\n    loaderId,\n    loadId\n  }) => {\n    if (loader === undefined) {\n      throw new _loaders_VolumeLoadError_js__WEBPACK_IMPORTED_MODULE_2__.VolumeLoadError(\"No loader created\");\n    }\n    return loader.loadRawChannelData((0,_util_js__WEBPACK_IMPORTED_MODULE_6__.rebuildImageInfo)(imageInfo), (0,_util_js__WEBPACK_IMPORTED_MODULE_6__.rebuildLoadSpec)(loadSpec), (imageInfo, loadSpec) => {\n      const message = {\n        responseResult: _types_js__WEBPACK_IMPORTED_MODULE_5__.WorkerResponseResult.EVENT,\n        eventType: _types_js__WEBPACK_IMPORTED_MODULE_5__.WorkerEventType.METADATA_UPDATE,\n        loaderId,\n        loadId,\n        imageInfo,\n        loadSpec\n      };\n      self.postMessage(message);\n    }, (channelIndex, data, ranges, atlasDims) => {\n      const message = {\n        responseResult: _types_js__WEBPACK_IMPORTED_MODULE_5__.WorkerResponseResult.EVENT,\n        eventType: _types_js__WEBPACK_IMPORTED_MODULE_5__.WorkerEventType.CHANNEL_LOAD,\n        loaderId,\n        loadId,\n        channelIndex,\n        data,\n        ranges,\n        atlasDims\n      };\n      self.postMessage(message, copyOnLoad ? [] : data.map(d => d.buffer));\n    });\n  },\n  [_types_js__WEBPACK_IMPORTED_MODULE_5__.WorkerMsgType.SET_PREFETCH_PRIORITY_DIRECTIONS]: directions => {\n    // Silently does nothing if the loader isn't an `OMEZarrLoader`\n    loader?.setPrefetchPriority(directions);\n    return Promise.resolve();\n  },\n  [_types_js__WEBPACK_IMPORTED_MODULE_5__.WorkerMsgType.SYNCHRONIZE_MULTICHANNEL_LOADING]: syncChannels => {\n    loader?.syncMultichannelLoading(syncChannels);\n    return Promise.resolve();\n  }\n};\nself.onmessage = async ({\n  data\n}) => {\n  const {\n    msgId,\n    type,\n    payload\n  } = data;\n  let message;\n  try {\n    const response = await messageHandlers[type](payload);\n    message = {\n      responseResult: _types_js__WEBPACK_IMPORTED_MODULE_5__.WorkerResponseResult.SUCCESS,\n      msgId,\n      type,\n      payload: response\n    };\n  } catch (e) {\n    message = {\n      responseResult: _types_js__WEBPACK_IMPORTED_MODULE_5__.WorkerResponseResult.ERROR,\n      msgId,\n      type,\n      payload: (0,serialize_error__WEBPACK_IMPORTED_MODULE_7__.serializeError)(e)\n    };\n  }\n  self.postMessage(message);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy93b3JrZXJzL1ZvbHVtZUxvYWRXb3JrZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlEO0FBQ0w7QUFDK0M7QUFDM0I7QUFDWjtBQUN3QjtBQUNNO0FBQ3BCO0FBQzlELElBQUlhLEtBQUssR0FBR0MsU0FBUztBQUNyQixJQUFJQyxLQUFLLEdBQUdELFNBQVM7QUFDckIsSUFBSUUsaUJBQWlCLEdBQUdGLFNBQVM7QUFDakMsSUFBSUcsTUFBTSxHQUFHSCxTQUFTO0FBQ3RCLElBQUlJLFdBQVcsR0FBRyxLQUFLO0FBQ3ZCLElBQUlDLFVBQVUsR0FBRyxLQUFLO0FBQ3RCLE1BQU1DLGVBQWUsR0FBRztFQUN0QixDQUFDWCxvREFBYSxDQUFDWSxJQUFJLEdBQUcsQ0FBQztJQUNyQkMsWUFBWTtJQUNaQyxpQkFBaUI7SUFDakJDO0VBQ0YsQ0FBQyxLQUFLO0lBQ0osSUFBSSxDQUFDTixXQUFXLEVBQUU7TUFDaEJMLEtBQUssR0FBRyxJQUFJWix1REFBVyxDQUFDcUIsWUFBWSxDQUFDO01BQ3JDUCxLQUFLLEdBQUcsSUFBSVQsOERBQVksQ0FBQ2lCLGlCQUFpQixFQUFFQyxzQkFBc0IsQ0FBQztNQUNuRVIsaUJBQWlCLEdBQUcsSUFBSVQsMEVBQXdCLENBQUNRLEtBQUssQ0FBQztNQUN2REcsV0FBVyxHQUFHLElBQUk7SUFDcEI7SUFDQSxPQUFPTyxPQUFPLENBQUNDLE9BQU8sQ0FBQyxDQUFDO0VBQzFCLENBQUM7RUFDRCxDQUFDakIsb0RBQWEsQ0FBQ2tCLGFBQWEsR0FBRyxPQUFPO0lBQ3BDQyxJQUFJO0lBQ0pDO0VBQ0YsQ0FBQyxLQUFLO0lBQ0osTUFBTUMsVUFBVSxHQUFHQyxLQUFLLENBQUNDLE9BQU8sQ0FBQ0osSUFBSSxDQUFDLEdBQUdBLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBR0EsSUFBSTtJQUN2RCxNQUFNSyxRQUFRLEdBQUdKLE9BQU8sRUFBRUksUUFBUSxJQUFJN0IsaUVBQWMsQ0FBQzBCLFVBQVUsQ0FB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LE9BQU87RUFDdEJiO0FBQ0YsQ0FBQyxLQUFLO0VBQ0osTUFBTTtJQUNKYyxLQUFLO0lBQ0xDLElBQUk7SUFDSkM7RUFDRixDQUFDLEdBQUdoQixJQUFJO0VBQ1IsSUFBSVIsT0FBTztFQUNYLElBQUk7SUFDRixNQUFNeUIsUUFBUSxHQUFHLE1BQU1sRCxlQUFlLENBQUNnRCxJQUFJLENBQUMsQ0FBQ0MsT0FBTyxDQUFDO0lBQ3JEeEIsT0FBTyxHQUFHO01BQ1JDLGNBQWMsRUFBRXBDLDJEQUFvQixDQUFDNkQsT0FBTztNQUM1Q0osS0FBSztNQUNMQyxJQUFJO01BQ0pDLE9BQU8sRUFBRUM7SUFDWCxDQUFDO0VBQ0gsQ0FBQyxDQUFDLE9BQU9FLENBQUMsRUFBRTtJQUNWM0IsT0FBTyxHQUFHO01BQ1JDLGNBQWMsRUFBRXBDLDJEQUFvQixDQUFDK0QsS0FBSztNQUMxQ04sS0FBSztNQUNMQyxJQUFJO01BQ0pDLE9BQU8sRUFBRXJFLCtEQUFjLENBQUN3RSxDQUFDO0lBQzNCLENBQUM7RUFDSDtFQUNBdEIsSUFBSSxDQUFDQyxXQUFXLENBQUNOLE9BQU8sQ0FBQztBQUMzQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uLi92b2x1bWUtdmlld2VyL2VzL3dvcmtlcnMvVm9sdW1lTG9hZFdvcmtlci5qcz9mNDJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlcmlhbGl6ZUVycm9yIH0gZnJvbSBcInNlcmlhbGl6ZS1lcnJvclwiO1xuaW1wb3J0IFZvbHVtZUNhY2hlIGZyb20gXCIuLi9Wb2x1bWVDYWNoZS5qc1wiO1xuaW1wb3J0IHsgVm9sdW1lRmlsZUZvcm1hdCwgY3JlYXRlVm9sdW1lTG9hZGVyLCBwYXRoVG9GaWxlVHlwZSB9IGZyb20gXCIuLi9sb2FkZXJzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBWb2x1bWVMb2FkRXJyb3IgfSBmcm9tIFwiLi4vbG9hZGVycy9Wb2x1bWVMb2FkRXJyb3IuanNcIjtcbmltcG9ydCBSZXF1ZXN0UXVldWUgZnJvbSBcIi4uL3V0aWxzL1JlcXVlc3RRdWV1ZS5qc1wiO1xuaW1wb3J0IFN1YnNjcmliYWJsZVJlcXVlc3RRdWV1ZSBmcm9tIFwiLi4vdXRpbHMvU3Vic2NyaWJhYmxlUmVxdWVzdFF1ZXVlLmpzXCI7XG5pbXBvcnQgeyBXb3JrZXJFdmVudFR5cGUsIFdvcmtlck1zZ1R5cGUsIFdvcmtlclJlc3BvbnNlUmVzdWx0IH0gZnJvbSBcIi4vdHlwZXMuanNcIjtcbmltcG9ydCB7IHJlYnVpbGRJbWFnZUluZm8sIHJlYnVpbGRMb2FkU3BlYyB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmxldCBjYWNoZSA9IHVuZGVmaW5lZDtcbmxldCBxdWV1ZSA9IHVuZGVmaW5lZDtcbmxldCBzdWJzY3JpYmFibGVRdWV1ZSA9IHVuZGVmaW5lZDtcbmxldCBsb2FkZXIgPSB1bmRlZmluZWQ7XG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmxldCBjb3B5T25Mb2FkID0gZmFsc2U7XG5jb25zdCBtZXNzYWdlSGFuZGxlcnMgPSB7XG4gIFtXb3JrZXJNc2dUeXBlLklOSVRdOiAoe1xuICAgIG1heENhY2hlU2l6ZSxcbiAgICBtYXhBY3RpdmVSZXF1ZXN0cyxcbiAgICBtYXhMb3dQcmlvcml0eVJlcXVlc3RzXG4gIH0pID0+IHtcbiAgICBpZiAoIWluaXRpYWxpemVkKSB7XG4gICAgICBjYWNoZSA9IG5ldyBWb2x1bWVDYWNoZShtYXhDYWNoZVNpemUpO1xuICAgICAgcXVldWUgPSBuZXcgUmVxdWVzdFF1ZXVlKG1heEFjdGl2ZVJlcXVlc3RzLCBtYXhMb3dQcmlvcml0eVJlcXVlc3RzKTtcbiAgICAgIHN1YnNjcmliYWJsZVF1ZXVlID0gbmV3IFN1YnNjcmliYWJsZVJlcXVlc3RRdWV1ZShxdWV1ZSk7XG4gICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfSxcbiAgW1dvcmtlck1zZ1R5cGUuQ1JFQVRFX0xPQURFUl06IGFzeW5jICh7XG4gICAgcGF0aCxcbiAgICBvcHRpb25zXG4gIH0pID0+IHtcbiAgICBjb25zdCBwYXRoU3RyaW5nID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGhbMF0gOiBwYXRoO1xuICAgIGNvbnN0IGZpbGVUeXBlID0gb3B0aW9ucz8uZmlsZVR5cGUgfHwgcGF0aFRvRmlsZVR5cGUocGF0aFN0cmluZyk7XG4gICAgY29weU9uTG9hZCA9IGZpbGVUeXBlID09PSBWb2x1bWVGaWxlRm9ybWF0LkpTT047XG4gICAgbG9hZGVyID0gYXdhaXQgY3JlYXRlVm9sdW1lTG9hZGVyKHBhdGgsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBjYWNoZSxcbiAgICAgIHF1ZXVlOiBzdWJzY3JpYmFibGVRdWV1ZVxuICAgIH0pO1xuICAgIHJldHVybiBsb2FkZXIgIT09IHVuZGVmaW5lZDtcbiAgfSxcbiAgW1dvcmtlck1zZ1R5cGUuQ1JFQVRFX1ZPTFVNRV06IGFzeW5jIGxvYWRTcGVjID0+IHtcbiAgICBpZiAobG9hZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBWb2x1bWVMb2FkRXJyb3IoXCJObyBsb2FkZXIgY3JlYXRlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGxvYWRlci5jcmVhdGVJbWFnZUluZm8ocmVidWlsZExvYWRTcGVjKGxvYWRTcGVjKSk7XG4gIH0sXG4gIFtXb3JrZXJNc2dUeXBlLkxPQURfRElNU106IGFzeW5jIGxvYWRTcGVjID0+IHtcbiAgICBpZiAobG9hZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBWb2x1bWVMb2FkRXJyb3IoXCJObyBsb2FkZXIgY3JlYXRlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGxvYWRlci5sb2FkRGltcyhyZWJ1aWxkTG9hZFNwZWMobG9hZFNwZWMpKTtcbiAgfSxcbiAgW1dvcmtlck1zZ1R5cGUuTE9BRF9WT0xVTUVfREFUQV06ICh7XG4gICAgaW1hZ2VJbmZvLFxuICAgIGxvYWRTcGVjLFxuICAgIGxvYWRlcklkLFxuICAgIGxvYWRJZFxuICB9KSA9PiB7XG4gICAgaWYgKGxvYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgVm9sdW1lTG9hZEVycm9yKFwiTm8gbG9hZGVyIGNyZWF0ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBsb2FkZXIubG9hZFJhd0NoYW5uZWxEYXRhKHJlYnVpbGRJbWFnZUluZm8oaW1hZ2VJbmZvKSwgcmVidWlsZExvYWRTcGVjKGxvYWRTcGVjKSwgKGltYWdlSW5mbywgbG9hZFNwZWMpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgIHJlc3BvbnNlUmVzdWx0OiBXb3JrZXJSZXNwb25zZVJlc3VsdC5FVkVOVCxcbiAgICAgICAgZXZlbnRUeXBlOiBXb3JrZXJFdmVudFR5cGUuTUVUQURBVEFfVVBEQVRFLFxuICAgICAgICBsb2FkZXJJZCxcbiAgICAgICAgbG9hZElkLFxuICAgICAgICBpbWFnZUluZm8sXG4gICAgICAgIGxvYWRTcGVjXG4gICAgICB9O1xuICAgICAgc2VsZi5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICB9LCAoY2hhbm5lbEluZGV4LCBkYXRhLCByYW5nZXMsIGF0bGFzRGltcykgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgcmVzcG9uc2VSZXN1bHQ6IFdvcmtlclJlc3BvbnNlUmVzdWx0LkVWRU5ULFxuICAgICAgICBldmVudFR5cGU6IFdvcmtlckV2ZW50VHlwZS5DSEFOTkVMX0xPQUQsXG4gICAgICAgIGxvYWRlcklkLFxuICAgICAgICBsb2FkSWQsXG4gICAgICAgIGNoYW5uZWxJbmRleCxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcmFuZ2VzLFxuICAgICAgICBhdGxhc0RpbXNcbiAgICAgIH07XG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIGNvcHlPbkxvYWQgPyBbXSA6IGRhdGEubWFwKGQgPT4gZC5idWZmZXIpKTtcbiAgICB9KTtcbiAgfSxcbiAgW1dvcmtlck1zZ1R5cGUuU0VUX1BSRUZFVENIX1BSSU9SSVRZX0RJUkVDVElPTlNdOiBkaXJlY3Rpb25zID0+IHtcbiAgICAvLyBTaWxlbnRseSBkb2VzIG5vdGhpbmcgaWYgdGhlIGxvYWRlciBpc24ndCBhbiBgT01FWmFyckxvYWRlcmBcbiAgICBsb2FkZXI/LnNldFByZWZldGNoUHJpb3JpdHkoZGlyZWN0aW9ucyk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9LFxuICBbV29ya2VyTXNnVHlwZS5TWU5DSFJPTklaRV9NVUxUSUNIQU5ORUxfTE9BRElOR106IHN5bmNDaGFubmVscyA9PiB7XG4gICAgbG9hZGVyPy5zeW5jTXVsdGljaGFubmVsTG9hZGluZyhzeW5jQ2hhbm5lbHMpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufTtcbnNlbGYub25tZXNzYWdlID0gYXN5bmMgKHtcbiAgZGF0YVxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgbXNnSWQsXG4gICAgdHlwZSxcbiAgICBwYXlsb2FkXG4gIH0gPSBkYXRhO1xuICBsZXQgbWVzc2FnZTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1lc3NhZ2VIYW5kbGVyc1t0eXBlXShwYXlsb2FkKTtcbiAgICBtZXNzYWdlID0ge1xuICAgICAgcmVzcG9uc2VSZXN1bHQ6IFdvcmtlclJlc3BvbnNlUmVzdWx0LlNVQ0NFU1MsXG4gICAgICBtc2dJZCxcbiAgICAgIHR5cGUsXG4gICAgICBwYXlsb2FkOiByZXNwb25zZVxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBtZXNzYWdlID0ge1xuICAgICAgcmVzcG9uc2VSZXN1bHQ6IFdvcmtlclJlc3BvbnNlUmVzdWx0LkVSUk9SLFxuICAgICAgbXNnSWQsXG4gICAgICB0eXBlLFxuICAgICAgcGF5bG9hZDogc2VyaWFsaXplRXJyb3IoZSlcbiAgICB9O1xuICB9XG4gIHNlbGYucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG59OyJdLCJuYW1lcyI6WyJzZXJpYWxpemVFcnJvciIsIlZvbHVtZUNhY2hlIiwiVm9sdW1lRmlsZUZvcm1hdCIsImNyZWF0ZVZvbHVtZUxvYWRlciIsInBhdGhUb0ZpbGVUeXBlIiwiVm9sdW1lTG9hZEVycm9yIiwiUmVxdWVzdFF1ZXVlIiwiU3Vic2NyaWJhYmxlUmVxdWVzdFF1ZXVlIiwiV29ya2VyRXZlbnRUeXBlIiwiV29ya2VyTXNnVHlwZSIsIldvcmtlclJlc3BvbnNlUmVzdWx0IiwicmVidWlsZEltYWdlSW5mbyIsInJlYnVpbGRMb2FkU3BlYyIsImNhY2hlIiwidW5kZWZpbmVkIiwicXVldWUiLCJzdWJzY3JpYmFibGVRdWV1ZSIsImxvYWRlciIsImluaXRpYWxpemVkIiwiY29weU9uTG9hZCIsIm1lc3NhZ2VIYW5kbGVycyIsIklOSVQiLCJtYXhDYWNoZVNpemUiLCJtYXhBY3RpdmVSZXF1ZXN0cyIsIm1heExvd1ByaW9yaXR5UmVxdWVzdHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsIkNSRUFURV9MT0FERVIiLCJwYXRoIiwib3B0aW9ucyIsInBhdGhTdHJpbmciLCJBcnJheSIsImlzQXJyYXkiLCJmaWxlVHlwZSIsIkpTT04iLCJDUkVBVEVfVk9MVU1FIiwibG9hZFNwZWMiLCJjcmVhdGVJbWFnZUluZm8iLCJMT0FEX0RJTVMiLCJsb2FkRGltcyIsIkxPQURfVk9MVU1FX0RBVEEiLCJpbWFnZUluZm8iLCJsb2FkZXJJZCIsImxvYWRJZCIsImxvYWRSYXdDaGFubmVsRGF0YSIsIm1lc3NhZ2UiLCJyZXNwb25zZVJlc3VsdCIsIkVWRU5UIiwiZXZlbnRUeXBlIiwiTUVUQURBVEFfVVBEQVRFIiwic2VsZiIsInBvc3RNZXNzYWdlIiwiY2hhbm5lbEluZGV4IiwiZGF0YSIsInJhbmdlcyIsImF0bGFzRGltcyIsIkNIQU5ORUxfTE9BRCIsIm1hcCIsImQiLCJidWZmZXIiLCJTRVRfUFJFRkVUQ0hfUFJJT1JJVFlfRElSRUNUSU9OUyIsImRpcmVjdGlvbnMiLCJzZXRQcmVmZXRjaFByaW9yaXR5IiwiU1lOQ0hST05JWkVfTVVMVElDSEFOTkVMX0xPQURJTkciLCJzeW5jQ2hhbm5lbHMiLCJzeW5jTXVsdGljaGFubmVsTG9hZGluZyIsIm9ubWVzc2FnZSIsIm1zZ0lkIiwidHlwZSIsInBheWxvYWQiLCJyZXNwb25zZSIsIlNVQ0NFU1MiLCJlIiwiRVJST1IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../volume-viewer/es/workers/VolumeLoadWorker.js\n");

/***/ }),

/***/ "../volume-viewer/es/workers/types.js":
/*!********************************************!*\
  !*** ../volume-viewer/es/workers/types.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WorkerEventType: () => (/* binding */ WorkerEventType),\n/* harmony export */   WorkerMsgType: () => (/* binding */ WorkerMsgType),\n/* harmony export */   WorkerResponseResult: () => (/* binding */ WorkerResponseResult)\n/* harmony export */ });\n/** The types of requests that can be made to the worker. Mostly corresponds to methods on `IVolumeLoader`. */\nlet WorkerMsgType = /*#__PURE__*/function (WorkerMsgType) {\n  WorkerMsgType[WorkerMsgType[\"INIT\"] = 0] = \"INIT\";\n  WorkerMsgType[WorkerMsgType[\"CREATE_LOADER\"] = 1] = \"CREATE_LOADER\";\n  WorkerMsgType[WorkerMsgType[\"CREATE_VOLUME\"] = 2] = \"CREATE_VOLUME\";\n  WorkerMsgType[WorkerMsgType[\"LOAD_DIMS\"] = 3] = \"LOAD_DIMS\";\n  WorkerMsgType[WorkerMsgType[\"LOAD_VOLUME_DATA\"] = 4] = \"LOAD_VOLUME_DATA\";\n  WorkerMsgType[WorkerMsgType[\"SET_PREFETCH_PRIORITY_DIRECTIONS\"] = 5] = \"SET_PREFETCH_PRIORITY_DIRECTIONS\";\n  WorkerMsgType[WorkerMsgType[\"SYNCHRONIZE_MULTICHANNEL_LOADING\"] = 6] = \"SYNCHRONIZE_MULTICHANNEL_LOADING\";\n  return WorkerMsgType;\n}({});\n\n/** The kind of response a worker can return - `SUCCESS`, `ERROR`, or `EVENT`. */\nlet WorkerResponseResult = /*#__PURE__*/function (WorkerResponseResult) {\n  WorkerResponseResult[WorkerResponseResult[\"SUCCESS\"] = 0] = \"SUCCESS\";\n  WorkerResponseResult[WorkerResponseResult[\"ERROR\"] = 1] = \"ERROR\";\n  WorkerResponseResult[WorkerResponseResult[\"EVENT\"] = 2] = \"EVENT\";\n  return WorkerResponseResult;\n}({});\n\n/** The kind of events that can occur when loading */\nlet WorkerEventType = /*#__PURE__*/function (WorkerEventType) {\n  WorkerEventType[WorkerEventType[\"METADATA_UPDATE\"] = 0] = \"METADATA_UPDATE\";\n  WorkerEventType[WorkerEventType[\"CHANNEL_LOAD\"] = 1] = \"CHANNEL_LOAD\";\n  return WorkerEventType;\n}({});\n\n/** All messages to/from a worker carry a `msgId`, a `type`, and a `payload` (whose type is determined by `type`). */\n\n/** Maps each `WorkerMsgType` to the type of the payload of requests of that type. */\n\n/** Maps each `WorkerMsgType` to the type of the payload of responses of that type. */\n\n/** Event for when a batch of channel data loads. */\n\n/** Event for when metadata updates. */\n\n/** All valid types of worker requests, with some `WorkerMsgType` and a matching payload type. */\n\n/** All valid types of worker responses: `SUCCESS` with a matching payload, `ERROR` with a message, or an `EVENT`. *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy93b3JrZXJzL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ08sSUFBSUEsYUFBYSxHQUFHLGFBQWEsVUFBVUEsYUFBYSxFQUFFO0VBQy9EQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNO0VBQ2pEQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxlQUFlO0VBQ25FQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxlQUFlO0VBQ25FQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxXQUFXO0VBQzNEQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLGtCQUFrQjtFQUN6RUEsYUFBYSxDQUFDQSxhQUFhLENBQUMsa0NBQWtDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxrQ0FBa0M7RUFDekdBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLGtDQUFrQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsa0NBQWtDO0VBQ3pHLE9BQU9BLGFBQWE7QUFDdEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDOztBQUVMO0FBQ08sSUFBSUMsb0JBQW9CLEdBQUcsYUFBYSxVQUFVQSxvQkFBb0IsRUFBRTtFQUM3RUEsb0JBQW9CLENBQUNBLG9CQUFvQixDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFNBQVM7RUFDckVBLG9CQUFvQixDQUFDQSxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxPQUFPO0VBQ2pFQSxvQkFBb0IsQ0FBQ0Esb0JBQW9CLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsT0FBTztFQUNqRSxPQUFPQSxvQkFBb0I7QUFDN0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDOztBQUVMO0FBQ08sSUFBSUMsZUFBZSxHQUFHLGFBQWEsVUFBVUEsZUFBZSxFQUFFO0VBQ25FQSxlQUFlLENBQUNBLGVBQWUsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLGlCQUFpQjtFQUMzRUEsZUFBZSxDQUFDQSxlQUFlLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsY0FBYztFQUNyRSxPQUFPQSxlQUFlO0FBQ3hCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWNzL3dlYi0zZC12aWV3ZXIvLi4vdm9sdW1lLXZpZXdlci9lcy93b3JrZXJzL3R5cGVzLmpzP2Y3YjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFRoZSB0eXBlcyBvZiByZXF1ZXN0cyB0aGF0IGNhbiBiZSBtYWRlIHRvIHRoZSB3b3JrZXIuIE1vc3RseSBjb3JyZXNwb25kcyB0byBtZXRob2RzIG9uIGBJVm9sdW1lTG9hZGVyYC4gKi9cbmV4cG9ydCBsZXQgV29ya2VyTXNnVHlwZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoV29ya2VyTXNnVHlwZSkge1xuICBXb3JrZXJNc2dUeXBlW1dvcmtlck1zZ1R5cGVbXCJJTklUXCJdID0gMF0gPSBcIklOSVRcIjtcbiAgV29ya2VyTXNnVHlwZVtXb3JrZXJNc2dUeXBlW1wiQ1JFQVRFX0xPQURFUlwiXSA9IDFdID0gXCJDUkVBVEVfTE9BREVSXCI7XG4gIFdvcmtlck1zZ1R5cGVbV29ya2VyTXNnVHlwZVtcIkNSRUFURV9WT0xVTUVcIl0gPSAyXSA9IFwiQ1JFQVRFX1ZPTFVNRVwiO1xuICBXb3JrZXJNc2dUeXBlW1dvcmtlck1zZ1R5cGVbXCJMT0FEX0RJTVNcIl0gPSAzXSA9IFwiTE9BRF9ESU1TXCI7XG4gIFdvcmtlck1zZ1R5cGVbV29ya2VyTXNnVHlwZVtcIkxPQURfVk9MVU1FX0RBVEFcIl0gPSA0XSA9IFwiTE9BRF9WT0xVTUVfREFUQVwiO1xuICBXb3JrZXJNc2dUeXBlW1dvcmtlck1zZ1R5cGVbXCJTRVRfUFJFRkVUQ0hfUFJJT1JJVFlfRElSRUNUSU9OU1wiXSA9IDVdID0gXCJTRVRfUFJFRkVUQ0hfUFJJT1JJVFlfRElSRUNUSU9OU1wiO1xuICBXb3JrZXJNc2dUeXBlW1dvcmtlck1zZ1R5cGVbXCJTWU5DSFJPTklaRV9NVUxUSUNIQU5ORUxfTE9BRElOR1wiXSA9IDZdID0gXCJTWU5DSFJPTklaRV9NVUxUSUNIQU5ORUxfTE9BRElOR1wiO1xuICByZXR1cm4gV29ya2VyTXNnVHlwZTtcbn0oe30pO1xuXG4vKiogVGhlIGtpbmQgb2YgcmVzcG9uc2UgYSB3b3JrZXIgY2FuIHJldHVybiAtIGBTVUNDRVNTYCwgYEVSUk9SYCwgb3IgYEVWRU5UYC4gKi9cbmV4cG9ydCBsZXQgV29ya2VyUmVzcG9uc2VSZXN1bHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFdvcmtlclJlc3BvbnNlUmVzdWx0KSB7XG4gIFdvcmtlclJlc3BvbnNlUmVzdWx0W1dvcmtlclJlc3BvbnNlUmVzdWx0W1wiU1VDQ0VTU1wiXSA9IDBdID0gXCJTVUNDRVNTXCI7XG4gIFdvcmtlclJlc3BvbnNlUmVzdWx0W1dvcmtlclJlc3BvbnNlUmVzdWx0W1wiRVJST1JcIl0gPSAxXSA9IFwiRVJST1JcIjtcbiAgV29ya2VyUmVzcG9uc2VSZXN1bHRbV29ya2VyUmVzcG9uc2VSZXN1bHRbXCJFVkVOVFwiXSA9IDJdID0gXCJFVkVOVFwiO1xuICByZXR1cm4gV29ya2VyUmVzcG9uc2VSZXN1bHQ7XG59KHt9KTtcblxuLyoqIFRoZSBraW5kIG9mIGV2ZW50cyB0aGF0IGNhbiBvY2N1ciB3aGVuIGxvYWRpbmcgKi9cbmV4cG9ydCBsZXQgV29ya2VyRXZlbnRUeXBlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChXb3JrZXJFdmVudFR5cGUpIHtcbiAgV29ya2VyRXZlbnRUeXBlW1dvcmtlckV2ZW50VHlwZVtcIk1FVEFEQVRBX1VQREFURVwiXSA9IDBdID0gXCJNRVRBREFUQV9VUERBVEVcIjtcbiAgV29ya2VyRXZlbnRUeXBlW1dvcmtlckV2ZW50VHlwZVtcIkNIQU5ORUxfTE9BRFwiXSA9IDFdID0gXCJDSEFOTkVMX0xPQURcIjtcbiAgcmV0dXJuIFdvcmtlckV2ZW50VHlwZTtcbn0oe30pO1xuXG4vKiogQWxsIG1lc3NhZ2VzIHRvL2Zyb20gYSB3b3JrZXIgY2FycnkgYSBgbXNnSWRgLCBhIGB0eXBlYCwgYW5kIGEgYHBheWxvYWRgICh3aG9zZSB0eXBlIGlzIGRldGVybWluZWQgYnkgYHR5cGVgKS4gKi9cblxuLyoqIE1hcHMgZWFjaCBgV29ya2VyTXNnVHlwZWAgdG8gdGhlIHR5cGUgb2YgdGhlIHBheWxvYWQgb2YgcmVxdWVzdHMgb2YgdGhhdCB0eXBlLiAqL1xuXG4vKiogTWFwcyBlYWNoIGBXb3JrZXJNc2dUeXBlYCB0byB0aGUgdHlwZSBvZiB0aGUgcGF5bG9hZCBvZiByZXNwb25zZXMgb2YgdGhhdCB0eXBlLiAqL1xuXG4vKiogRXZlbnQgZm9yIHdoZW4gYSBiYXRjaCBvZiBjaGFubmVsIGRhdGEgbG9hZHMuICovXG5cbi8qKiBFdmVudCBmb3Igd2hlbiBtZXRhZGF0YSB1cGRhdGVzLiAqL1xuXG4vKiogQWxsIHZhbGlkIHR5cGVzIG9mIHdvcmtlciByZXF1ZXN0cywgd2l0aCBzb21lIGBXb3JrZXJNc2dUeXBlYCBhbmQgYSBtYXRjaGluZyBwYXlsb2FkIHR5cGUuICovXG5cbi8qKiBBbGwgdmFsaWQgdHlwZXMgb2Ygd29ya2VyIHJlc3BvbnNlczogYFNVQ0NFU1NgIHdpdGggYSBtYXRjaGluZyBwYXlsb2FkLCBgRVJST1JgIHdpdGggYSBtZXNzYWdlLCBvciBhbiBgRVZFTlRgLiAqLyJdLCJuYW1lcyI6WyJXb3JrZXJNc2dUeXBlIiwiV29ya2VyUmVzcG9uc2VSZXN1bHQiLCJXb3JrZXJFdmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../volume-viewer/es/workers/types.js\n");

/***/ }),

/***/ "../volume-viewer/es/workers/util.js":
/*!*******************************************!*\
  !*** ../volume-viewer/es/workers/util.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rebuildImageInfo: () => (/* binding */ rebuildImageInfo),\n/* harmony export */   rebuildLoadSpec: () => (/* binding */ rebuildLoadSpec)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"../volume-viewer/node_modules/three/build/three.module.js\");\n\n/** Recreates a `LoadSpec` that has just been sent to/from a worker to restore three.js object prototypes */\nfunction rebuildLoadSpec(spec) {\n  return {\n    ...spec,\n    subregion: new three__WEBPACK_IMPORTED_MODULE_0__.Box3(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(spec.subregion.min), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(spec.subregion.max))\n  };\n}\n\n/** Recreates an `ImageInfo` that has just been sent to/from a worker to restore three.js object prototypes */\nfunction rebuildImageInfo(imageInfo) {\n  return {\n    ...imageInfo,\n    originalSize: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(imageInfo.originalSize),\n    atlasTileDims: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2().copy(imageInfo.atlasTileDims),\n    volumeSize: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(imageInfo.volumeSize),\n    subregionSize: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(imageInfo.subregionSize),\n    subregionOffset: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(imageInfo.subregionOffset),\n    physicalPixelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(imageInfo.physicalPixelSize),\n    transform: {\n      translation: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(imageInfo.transform.translation),\n      rotation: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(imageInfo.transform.rotation)\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vdm9sdW1lLXZpZXdlci9lcy93b3JrZXJzL3V0aWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStDO0FBQy9DO0FBQ08sU0FBU0csZUFBZUEsQ0FBQ0MsSUFBSSxFQUFFO0VBQ3BDLE9BQU87SUFDTCxHQUFHQSxJQUFJO0lBQ1BDLFNBQVMsRUFBRSxJQUFJTCx1Q0FBSSxDQUFDLElBQUlFLDBDQUFPLENBQUMsQ0FBQyxDQUFDSSxJQUFJLENBQUNGLElBQUksQ0FBQ0MsU0FBUyxDQUFDRSxHQUFHLENBQUMsRUFBRSxJQUFJTCwwQ0FBTyxDQUFDLENBQUMsQ0FBQ0ksSUFBSSxDQUFDRixJQUFJLENBQUNDLFNBQVMsQ0FBQ0csR0FBRyxDQUFDO0VBQ3BHLENBQUM7QUFDSDs7QUFFQTtBQUNPLFNBQVNDLGdCQUFnQkEsQ0FBQ0MsU0FBUyxFQUFFO0VBQzFDLE9BQU87SUFDTCxHQUFHQSxTQUFTO0lBQ1pDLFlBQVksRUFBRSxJQUFJVCwwQ0FBTyxDQUFDLENBQUMsQ0FBQ0ksSUFBSSxDQUFDSSxTQUFTLENBQUNDLFlBQVksQ0FBQztJQUN4REMsYUFBYSxFQUFFLElBQUlYLDBDQUFPLENBQUMsQ0FBQyxDQUFDSyxJQUFJLENBQUNJLFNBQVMsQ0FBQ0UsYUFBYSxDQUFDO0lBQzFEQyxVQUFVLEVBQUUsSUFBSVgsMENBQU8sQ0FBQyxDQUFDLENBQUNJLElBQUksQ0FBQ0ksU0FBUyxDQUFDRyxVQUFVLENBQUM7SUFDcERDLGFBQWEsRUFBRSxJQUFJWiwwQ0FBTyxDQUFDLENBQUMsQ0FBQ0ksSUFBSSxDQUFDSSxTQUFTLENBQUNJLGFBQWEsQ0FBQztJQUMxREMsZUFBZSxFQUFFLElBQUliLDBDQUFPLENBQUMsQ0FBQyxDQUFDSSxJQUFJLENBQUNJLFNBQVMsQ0FBQ0ssZUFBZSxDQUFDO0lBQzlEQyxpQkFBaUIsRUFBRSxJQUFJZCwwQ0FBTyxDQUFDLENBQUMsQ0FBQ0ksSUFBSSxDQUFDSSxTQUFTLENBQUNNLGlCQUFpQixDQUFDO0lBQ2xFQyxTQUFTLEVBQUU7TUFDVEMsV0FBVyxFQUFFLElBQUloQiwwQ0FBTyxDQUFDLENBQUMsQ0FBQ0ksSUFBSSxDQUFDSSxTQUFTLENBQUNPLFNBQVMsQ0FBQ0MsV0FBVyxDQUFDO01BQ2hFQyxRQUFRLEVBQUUsSUFBSWpCLDBDQUFPLENBQUMsQ0FBQyxDQUFDSSxJQUFJLENBQUNJLFNBQVMsQ0FBQ08sU0FBUyxDQUFDRSxRQUFRO0lBQzNEO0VBQ0YsQ0FBQztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFpY3Mvd2ViLTNkLXZpZXdlci8uLi92b2x1bWUtdmlld2VyL2VzL3dvcmtlcnMvdXRpbC5qcz8zYWEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJveDMsIFZlY3RvcjIsIFZlY3RvcjMgfSBmcm9tIFwidGhyZWVcIjtcbi8qKiBSZWNyZWF0ZXMgYSBgTG9hZFNwZWNgIHRoYXQgaGFzIGp1c3QgYmVlbiBzZW50IHRvL2Zyb20gYSB3b3JrZXIgdG8gcmVzdG9yZSB0aHJlZS5qcyBvYmplY3QgcHJvdG90eXBlcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYnVpbGRMb2FkU3BlYyhzcGVjKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc3BlYyxcbiAgICBzdWJyZWdpb246IG5ldyBCb3gzKG5ldyBWZWN0b3IzKCkuY29weShzcGVjLnN1YnJlZ2lvbi5taW4pLCBuZXcgVmVjdG9yMygpLmNvcHkoc3BlYy5zdWJyZWdpb24ubWF4KSlcbiAgfTtcbn1cblxuLyoqIFJlY3JlYXRlcyBhbiBgSW1hZ2VJbmZvYCB0aGF0IGhhcyBqdXN0IGJlZW4gc2VudCB0by9mcm9tIGEgd29ya2VyIHRvIHJlc3RvcmUgdGhyZWUuanMgb2JqZWN0IHByb3RvdHlwZXMgKi9cbmV4cG9ydCBmdW5jdGlvbiByZWJ1aWxkSW1hZ2VJbmZvKGltYWdlSW5mbykge1xuICByZXR1cm4ge1xuICAgIC4uLmltYWdlSW5mbyxcbiAgICBvcmlnaW5hbFNpemU6IG5ldyBWZWN0b3IzKCkuY29weShpbWFnZUluZm8ub3JpZ2luYWxTaXplKSxcbiAgICBhdGxhc1RpbGVEaW1zOiBuZXcgVmVjdG9yMigpLmNvcHkoaW1hZ2VJbmZvLmF0bGFzVGlsZURpbXMpLFxuICAgIHZvbHVtZVNpemU6IG5ldyBWZWN0b3IzKCkuY29weShpbWFnZUluZm8udm9sdW1lU2l6ZSksXG4gICAgc3VicmVnaW9uU2l6ZTogbmV3IFZlY3RvcjMoKS5jb3B5KGltYWdlSW5mby5zdWJyZWdpb25TaXplKSxcbiAgICBzdWJyZWdpb25PZmZzZXQ6IG5ldyBWZWN0b3IzKCkuY29weShpbWFnZUluZm8uc3VicmVnaW9uT2Zmc2V0KSxcbiAgICBwaHlzaWNhbFBpeGVsU2l6ZTogbmV3IFZlY3RvcjMoKS5jb3B5KGltYWdlSW5mby5waHlzaWNhbFBpeGVsU2l6ZSksXG4gICAgdHJhbnNmb3JtOiB7XG4gICAgICB0cmFuc2xhdGlvbjogbmV3IFZlY3RvcjMoKS5jb3B5KGltYWdlSW5mby50cmFuc2Zvcm0udHJhbnNsYXRpb24pLFxuICAgICAgcm90YXRpb246IG5ldyBWZWN0b3IzKCkuY29weShpbWFnZUluZm8udHJhbnNmb3JtLnJvdGF0aW9uKVxuICAgIH1cbiAgfTtcbn0iXSwibmFtZXMiOlsiQm94MyIsIlZlY3RvcjIiLCJWZWN0b3IzIiwicmVidWlsZExvYWRTcGVjIiwic3BlYyIsInN1YnJlZ2lvbiIsImNvcHkiLCJtaW4iLCJtYXgiLCJyZWJ1aWxkSW1hZ2VJbmZvIiwiaW1hZ2VJbmZvIiwib3JpZ2luYWxTaXplIiwiYXRsYXNUaWxlRGltcyIsInZvbHVtZVNpemUiLCJzdWJyZWdpb25TaXplIiwic3VicmVnaW9uT2Zmc2V0IiwicGh5c2ljYWxQaXhlbFNpemUiLCJ0cmFuc2Zvcm0iLCJ0cmFuc2xhdGlvbiIsInJvdGF0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../volume-viewer/es/workers/util.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// the startup function
/******/ 	__webpack_require__.x = () => {
/******/ 		// Load entry module and return exports
/******/ 		// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 		var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors-volume-viewer_node_modules_zarrita_core_dist_src_errors_js-volume-viewer_node_modules-4b02bd","vendors-volume-viewer_node_modules_zarrita_core_dist_src_open_js-volume-viewer_node_modules_z-5b7efc"], () => (__webpack_require__("../volume-viewer/es/workers/VolumeLoadWorker.js")))
/******/ 		__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 		return __webpack_exports__;
/******/ 	};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and sibling chunks for the entrypoint
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundle.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and sibling chunks for the entrypoint
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = self.location + "";
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"volume-viewer_es_workers_VolumeLoadWorker_js": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk_aics_web_3d_viewer"] = self["webpackChunk_aics_web_3d_viewer"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup chunk dependencies */
/******/ 	(() => {
/******/ 		var next = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			return Promise.all([
/******/ 				__webpack_require__.e("vendors-volume-viewer_node_modules_zarrita_core_dist_src_errors_js-volume-viewer_node_modules-4b02bd"),
/******/ 				__webpack_require__.e("vendors-volume-viewer_node_modules_zarrita_core_dist_src_open_js-volume-viewer_node_modules_z-5b7efc")
/******/ 			]).then(next);
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// run startup
/******/ 	var __webpack_exports__ = __webpack_require__.x();
/******/ 	
/******/ })()
;